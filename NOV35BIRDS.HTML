<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bird Window</title>
    <style>
        html, body {
    width: 100%;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    position: fixed;
}
.window {
    width: 100vw !important;
    height: 100vh !important;
    margin: 0;
    padding: 0;
    overflow: hidden;
    position: absolute;
    top: 0;
    left: 0;
}
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 200px;
            max-height: 80vh;
            overflow-y: auto;
            font-size: 12px;
            z-index: 10;
            color: #3366CC
        }
        
        .info-panel h3 {
            margin-top: 0;
        }
        
        .toggle-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
            color: #000000; /* Add this line to make text black */
        }
        
        .control-panel {
            position: absolute;
            left: 10px;
            bottom: 50px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
            max-height: 70vh;
            overflow-y: auto;
            width: 200px; /* Add this line to make it narrower */
        }
        
        .control-group {
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 50px;
        }

        .control-group h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #333;
        }

        .control-panel button {
            margin: 3px;
            padding: 5px 8px;
            cursor: pointer;
            border-radius: 3px;
            border: 1px solid #ccc;
            background: #f8f8f8;
        }

        .control-panel button:hover {
            background: #e8e8e8;
        }
        
        @media (max-width: 768px) {
            .info-panel {
                max-width: 150px;
                font-size: 10px;
            }
            .toggle-panel, .curtain-toggle, .controls-hint {
                font-size: 10px;
                padding: 3px 6px;
            }
        }
        .screenshot-btn {
        margin-top: 10px;
        padding: 5px 10px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background 0.3s;
    }
    
    .screenshot-btn:hover {
        background: #45a049;
    }
    
    .screenshot-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 5px;
        z-index: 1000;
        display: none;
        animation: fadeInOut 2s ease-in-out;
    }
    
    @keyframes fadeInOut {
        0% { opacity: 0; }
        20% { opacity: 1; }
        80% { opacity: 1; }
        100% { opacity: 0; }
    }

    .manual-btn {
        margin-top: 5px;
        padding: 5px 10px;
        background: #2196F3;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background 0.3s;
    }

    .manual-btn:hover {
        background: #0b7dda;
    }

    .mute-btn {
        margin-top: 5px;
        padding: 5px 10px;
        background: #FF9800;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background 0.3s;
    }

    .mute-btn:hover {
        background: #F57C00;
    }

    .mute-btn.muted {
        background: #f44336;
    }

    .mute-btn.muted:hover {
        background: #d32f2f;
    }

    .instruction-manual {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 1001;
        display: none;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: #333;
    }

    .instruction-manual h2 {
        margin-top: 0;
        color: #2196F3;
        border-bottom: 2px solid #2196F3;
        padding-bottom: 10px;
    }

    .instruction-manual h3 {
        color: #4CAF50;
        margin-top: 15px;
        margin-bottom: 5px;
    }

    .instruction-manual ul {
        margin: 5px 0;
        padding-left: 20px;
    }

    .instruction-manual li {
        margin-bottom: 5px;
    }

    .instruction-manual .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #f44336;
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
    }

    .instruction-manual .close-btn:hover {
        background: #d32f2f;
    }

    .instruction-manual .section {
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(240, 240, 240, 0.5);
        border-radius: 5px;
    }

    .instruction-manual .new-feature {
        background: rgba(76, 175, 80, 0.1);
        border-left: 3px solid #4CAF50;
        padding: 8px;
        margin: 5px 0;
    }

    @media (max-width: 768px) {
        .instruction-manual {
            max-width: 90vw;
            max-height: 85vh;
            padding: 15px;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
    <div class="window">
        <canvas id="gardenCanvas"></canvas>
        <div class="info-panel" id="infoPanel" style="display: none;">
            <h3>Garden Ecosystem</h3>
            <div id="stats"></div>
            <div style="margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; flex-direction: column; gap: 8px;">
                <label style="cursor: pointer; user-select: none;" title="Show Real-Time Clock & Forecast">
                    <input type="checkbox" id="clockToggle" style="margin-right: 5px;">
                    üïê
                </label>
                <label style="cursor: pointer; user-select: none;" title="Show Garden Diary">
                    <input type="checkbox" id="diaryToggle" style="margin-right: 5px;">
                    üìñ
                </label>
                <label style="cursor: pointer; user-select: none;" title="Developer Tools">
                    <input type="checkbox" id="debugToggle" style="margin-right: 5px;">
                    üîß
                </label>
            </div>
            <button id="screenshotBtn" class="screenshot-btn">üì∑ Take Screenshot</button>
            <button id="manualBtn" class="manual-btn">üìñ Guide & Features</button>
            <button id="muteBtn" class="mute-btn">üîä Mute</button>
        </div>
        <!-- Add missing toggle buttons -->
        <button id="toggleInfo" class="toggle-panel">‚ÑπÔ∏è Show Info</button>
        <button id="toggleMushroom" class="toggle-panel" style="display: none; top: 60px; background-color: #f8f8f8;">üçÑ Mushroom Mode</button>
       
      
        <div class="control-panel" id="controlPanel">
            <div style="text-align: right; margin-bottom: 10px;">
                <button id="keepVisualsBtn">üëÅÔ∏è Close ("C" to bring panel back)</button>
            </div>
            <button id="addBirdBtn">üê¶ Add Bird</button>
            <button id="addFoodBtn">üåΩ Scatter Food</button>
            <button id="toggleRainBtn">‚òî Toggle Rain</button>
            <button id="spawnWormBtn">ü™± Spawn Worms</button>
            <button id="spawnAntsBtn">üêú Spawn Ants</button>
            <button id="addBabyBirdBtn">üê§ Add Baby Bird</button>
            <button id="hatchEggsBtn">ü•ö Hatch All Eggs Now</button>
            <button id="addSquirrelBtn">üêøÔ∏è Add Squirrel</button>
            <button id="addRatKingBtn">üëëüêÄ Add Rat King</button>
            <button id="addSpecialTwigBtn">‚ú®üåø Add Special Twig</button>
            <button id="addBirdhouseBtn">üè† Add Birdhouse</button>
            <button id="spawnOwlBtn">ü¶â Spawn Owl</button>
            <button id="spawnScarecrowBtn">üßπ Create Scarecrow</button>
            <button id="toggleWindChimeBtn">üîî Wind Chimes: OFF</button>
            <button id="toggleMushroomModeBtn">üçÑ Mushroom Mode</button>
            <button id="spawnGameboyBtn">üéÆ Spawn Gameboy</button>
            <button id="triggerPeckingBtn">üçΩÔ∏è Trigger Pecking</button>
            <button id="testChirpBtn">üéµ Test Chirps</button>
            <button id="addRatBtn">üêÄ Add Rat</button>
            <button id="spawnPondBtn">üíß Spawn Pond</button>
            <button id="spawnFrogBtn">üê∏ Spawn Frog</button>
            <button id="spawnKoiBtn">üêü Spawn Koi</button>
            <button id="triggerRainbowBtn">üåà Trigger Rainbow</button>
            <button id="triggerMeteorBtn">‚òÑÔ∏è Trigger Meteor Shower</button>
            <button id="triggerEclipseBtn">üåë Trigger Eclipse</button>
            <button id="triggerUFOBtn">üõ∏ Trigger UFO</button>
            <button id="triggerMigrationBtn">ü¶Ö Trigger Migration</button>
            <button id="triggerFirefliesBtn">‚ú® Trigger Fireflies</button>
        </div>

    <div id="screenshotMessage" class="screenshot-message">Screenshot saved!</div>

    <!-- Instruction Manual -->
    <div id="instructionManual" class="instruction-manual">
        <button class="close-btn" id="closeManualBtn">√ó</button>
        <h2>üåø Garden View Ecosystem</h2>

        <div class="section">
            <p><em>A living, breathing ecosystem designed for <strong>relaxation and observation</strong>. Birds perch for 6+ minutes, hop on ground for 2+ minutes, and display calm, natural behaviors. This is slow, contemplative birdwatching - perfect for unwinding.</em></p>

            <h3>‚ö° Quick Start</h3>
            <ul>
                <li><strong>Click/Tap:</strong> Drop food for birds (they investigate 80% of the time!)</li>
                <li><strong>Info button (‚ÑπÔ∏è):</strong> See ecosystem stats, toggle clock display, and access settings</li>
                <li><strong>Clock toggle:</strong> In info panel, enable real-time clock with weather forecast</li>
                <li><strong>Diary toggle:</strong> View your garden's story and bird families</li>
                <li><strong>Be patient:</strong> Birds spend most time perched or on ground. Watch them settle and relax!</li>
            </ul>

            <p><em>Want to know more? Expand the sections below:</em></p>
        </div>

        <details class="detail-section">
            <summary>üê¶ Bird Behavior Systems</summary>
            <ul>
                <li><strong>States:</strong> Birds transition between Flying, Perched, Hopping, Pecking, Bathing, Sleeping, Feeding babies, Building nests, and Fleeing</li>
                <li><strong>Relaxing behavior:</strong> Birds perch for ~6 minutes, sleep for ~2.5 minutes, hop on ground for ~2 minutes, and only fly for brief 5-second bursts between locations. This creates a calm, contemplative atmosphere.</li>
                <li><strong>Perching:</strong> Birds can perch anywhere on trees including all throughout the green leafy canopy (25 positions per tree). They settle comfortably and stay for long periods.</li>
                <li><strong>Ground life:</strong> Birds land and stay on ground for hopping, pecking (~20 seconds), and feeding (~30 seconds). They forage naturally with visible, relaxing ground behaviors.</li>
                <li><strong>Sleeping:</strong> Birds fall asleep at night while perched, showing floating "ZzZz" above them. They wake at dawn or if danger approaches</li>
                <li><strong>Player food priority:</strong> Birds investigate player-added food 80% of the time, even when not hungry! This helps attract birds to specific areas.</li>
                <li><strong>Nesting:</strong> Non-wild birds collect twigs to build nests in trees. Special golden twigs speed up construction</li>
                <li><strong>Parenting:</strong> Adult birds feed hungry baby birds, prioritizing critically hungry ones</li>
                <li><strong>Flocking:</strong> Birds of similar types recognize each other and coordinate behaviors</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üéµ Musical Chirping & Communication</summary>
            <ul>
                <li><strong>Musical voices:</strong> Each bird has a unique voice (Melodic, Bright, Exotic, or Songbird)</li>
                <li><strong>Musical scales:</strong> Chirps use pentatonic, major, and minor scales for pleasant sounds</li>
                <li><strong>Ambient chirping:</strong> Birds chirp randomly while perched or idle</li>
                <li><strong>Visual notes:</strong> Musical notes appear above chirping birds</li>
                <li><strong>Chirp types:</strong>
                    <ul>
                        <li>üéµ <strong>Social</strong> - General communication</li>
                        <li>üåΩ <strong>Food Call</strong> - "Found food here!"</li>
                        <li>üìû <strong>Contact Call</strong> - "Where is everyone?"</li>
                        <li>‚ö†Ô∏è <strong>Alert</strong> - Warning of danger</li>
                        <li>üèÜ <strong>Victory</strong> - Won a territorial dispute</li>
                        <li>üõ°Ô∏è <strong>Territorial</strong> - Defending territory</li>
                    </ul>
                </li>
                <li><strong>Synchronized chirping:</strong> Social chirps can trigger nearby birds to chirp back</li>
                <li><strong>Mute button:</strong> Available in info panel (üîä/üîá)</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üå≥ Trees & Environment</summary>
            <ul>
                <li><strong>Tree lifecycle:</strong> Trees age, produce flowers, and eventually fall. New trees regrow</li>
                <li><strong>Rare tall trees:</strong> 2% of trees spawn as majestic tall variants - 33% taller with thicker trunks and more branches for extra perching spots</li>
                <li><strong>Perching positions:</strong> Each tree offers 25 perching spots throughout its canopy, including all through the leafy areas</li>
                <li><strong>Perching preferences:</strong> Birds prefer shelter during rain/night, healthy trees during day</li>
                <li><strong>Branch traversal:</strong> Squirrels can jump between nearby trees</li>
                <li><strong>Flowers:</strong> Appear on healthy trees during the day, attract butterflies</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üíß Water Systems & Ponds</summary>
            <ul>
                <li><strong>Puddles:</strong> Form during rain, birds bathe in them, evaporate over time</li>
                <li><strong>Ponds:</strong> Permanent water sources (10% chance to spawn on load or after 5 rains)</li>
                <li><strong>Koi fish:</strong> Swim in ponds in 8 traditional colors (orange-red, gold, crimson, brown, slate grey), get excited when birds approach, and may jump out of water!</li>
                <li><strong>Frogs:</strong> Live near ponds, jump away from birds, croak warnings, catch ants</li>
                <li><strong>Bird interactions:</strong> Birds visit ponds to drink and bathe, can hop below ground to reach them</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üêøÔ∏è Squirrels & Ground Creatures</summary>
            <ul>
                <li><strong>Squirrels:</strong> Wander, forage for nuts, climb trees, jump between branches</li>
                <li><strong>Nest raiding:</strong> Squirrels may damage bird nests if they share a tree</li>
                <li><strong>Bird interactions:</strong> Birds may chase squirrels from trees</li>
                <li><strong>Ants:</strong> Form colonies at ant hills, forage for food, frogs hunt them</li>
                <li><strong>Worms:</strong> Emerge from ground, more active at night and after rain</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>ü¶â Nocturnal & Predators</summary>
            <ul>
                <li><strong>Owls:</strong> Hunt rats at night, may deliver gameboy after day 30</li>
                <li><strong>Rats:</strong> Scavenge on the ground, flee from owls and birds</li>
                <li><strong>Rat Kings:</strong> Rare, larger with crown, attract more rats and owls</li>
                <li><strong>Crows:</strong> Visit when worm population exceeds 30</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>‚òÅÔ∏è Weather & Time</summary>
            <ul>
                <li><strong>Day/Night cycle:</strong> ~4 minutes per full cycle (perfectly balanced!)</li>
                <li><strong>Rain:</strong> Spawns puddles and worms, birds seek shelter</li>
                <li><strong>Thunder:</strong> Can occur during heavy rain with lightning strikes</li>
                <li><strong>Rainbow:</strong> Rare, appears after rain with right conditions</li>
                <li><strong>Weather Forecast:</strong> 3-icon forecast in clock display with 95% accuracy</li>
                <li><strong>Sky gradient:</strong> Smooth 3-color gradients for atmospheric perspective</li>
                <li><strong>Night behaviors:</strong> Worms emerge, owls hunt, birds sleep and shelter in birdhouses</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üè† Birdhouses & Shelter</summary>
            <ul>
                <li><strong>Construction:</strong> Birds build birdhouses similar to nests using twigs</li>
                <li><strong>Shelter:</strong> During rain or night, birds seek birdhouses for protection</li>
                <li><strong>Capacity:</strong> Multiple birds can shelter together</li>
                <li><strong>Behavior:</strong> Birds sleep inside, emerge at dawn</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üìñ Garden Diary</summary>
            <ul>
                <li><strong>Auto-Generated Story:</strong> Click the üìñ button in info panel to view your garden's history</li>
                <li><strong>Event Chronicle:</strong> Major moments automatically recorded (births, nests, weather, visitors)</li>
                <li><strong>Bird Lineages:</strong> Birds receive names and track family generations (Ruby ‚Üí Ruby Jr. ‚Üí Ruby III)</li>
                <li><strong>Timeline View:</strong> See your garden's story unfold day by day</li>
                <li><strong>Family Trees:</strong> Watch bird families grow across generations</li>
                <li><strong>Milestone Tracking:</strong> First nest, pond formation, special events recorded</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üéÆ Special Features & Easter Eggs</summary>
            <ul>
                <li><strong>Real-Time Clock & Forecast:</strong> Toggle in info panel for a large transparent 24-hour clock with weather forecast. Birds perch on numbers! Clock chimes hourly with different melodies.</li>
                <li><strong>Gameboy:</strong> After day 30, an owl may deliver a magical gameboy. Click it to visit a 1-bit window game!</li>
                <li><strong>Mushroom Mode:</strong> Psychedelic visual mode with rainbow colors and bird trails. Find the magic mushroom to unlock!</li>
                <li><strong>Scarecrow:</strong> Birds avoid scarecrows. Stays for 1 day/night cycle</li>
                <li><strong>Butterflies:</strong> Flutter peacefully through the garden near flowers</li>
                <li><strong>Screenshots:</strong> Capture special moments with the üì∑ button</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üí° Tips & Strategies</summary>
            <ul>
                <li><strong>Patience is key:</strong> Birds now spend 6+ minutes perched and 2+ minutes hopping. This is a slow, contemplative experience - perfect for relaxing!</li>
                <li><strong>Attracting birds:</strong> Click to drop food anywhere. Birds investigate player food 80% of the time, even when not hungry, so you can guide them to favorite spots</li>
                <li><strong>Watch the canopies:</strong> Birds can perch anywhere in the leafy green areas - look for them throughout the entire tree, not just on branches</li>
                <li><strong>Ground activity:</strong> Birds land and stay on ground for extended periods. Watch for hopping, pecking, and feeding behaviors that last 20-120 seconds</li>
                <li><strong>Rare discoveries:</strong> Keep an eye out for rare colored birds (1.5% chance) and tall trees (2% spawn). They're automatically noted in your diary</li>
                <li><strong>Nest success:</strong> Keep trees healthy, scatter twigs, minimize squirrel interference</li>
                <li><strong>Baby bird survival:</strong> Adult birds will feed babies automatically if food is available</li>
                <li><strong>Ecosystem balance:</strong> Too many rats? Wait for owls. Too many worms? Crows will visit</li>
                <li><strong>Debug controls:</strong> Triple-click top of screen to access spawning, weather, and testing tools</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>‚ú® Special Events & Phenomena</summary>
            <ul>
                <li><strong>Meteor Showers:</strong> Rare nighttime celestial events with streaking meteors. Birds become alarmed and may take shelter!</li>
                <li><strong>Solar Eclipse:</strong> Extremely rare daytime event where the sky darkens gradually. Birds become confused during totality!</li>
                <li><strong>Migration Waves:</strong> Flocks of 10-15 birds pass through in V-formation or straight lines, flying across the sky</li>
                <li><strong>UFO Encounters:</strong> Very rare nighttime visitors! UFOs may beam up birdhouses, scarecrows, or ants:
                    <ul>
                        <li>Birdhouses & Scarecrows: Returned after 10-20 seconds with green glow effect</li>
                        <li>Ants: Transformed into giant glowing ants! Remain giant for 3 days, then revert to normal size but keep the glow</li>
                    </ul>
                </li>
                <li><strong>Double Rainbows:</strong> 1% chance after rain for a spectacular double rainbow with reversed color order!</li>
                <li><strong>Mushroom Mode Events:</strong> All special events have psychedelic rainbow versions when mushroom mode is active!</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üåü Nighttime Wonders</summary>
            <ul>
                <li><strong>Fireflies:</strong> Glowing insects appear on 35% of nights. Birds can hunt and catch them for food!</li>
                <li><strong>Pulsing Glow:</strong> Fireflies have a gentle pulsing light effect as they flutter through the air</li>
                <li><strong>Dawn Departure:</strong> All fireflies disappear when the sun rises</li>
                <li><strong>Owl Activity:</strong> Owls hunt during firefly nights, creating a living nighttime ecosystem</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üçÑ Advanced Ecosystem Mechanics</summary>
            <ul>
                <li><strong>Food Caching:</strong> Squirrels and crows cache food for later (3-day lifespan). Rats can dig up these caches!</li>
                <li><strong>Nest Degradation:</strong> Abandoned nests decay 2-4x faster based on how long they've been empty</li>
                <li><strong>Mushroom Clusters:</strong> Non-magic mushrooms spawn near trees after rain (40% chance), age out after 5 minutes</li>
                <li><strong>Fallen Branches:</strong> Squirrels occasionally knock branches from trees while foraging. These become available twigs!</li>
                <li><strong>Pond Drinking:</strong> Birds visit ponds to drink water, not just to bathe</li>
                <li><strong>Rare Color Variants:</strong> 1.5% of birds spawn with special colors: Albino, Melanistic, Golden, Azure, Rose, or Emerald! Extremely rare combo birds (~0.3%) combine two colors! Each rare bird is automatically noted in your garden diary.</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üîî Wind Chimes</summary>
            <ul>
                <li><strong>Spawn Chance:</strong> 10% chance for wind chimes to appear at game start (hanging from trees)</li>
                <li><strong>Owl Delivery:</strong> After day 15, owls may deliver wind chimes at night</li>
                <li><strong>Visual Design:</strong> Metallic chimes with 4-6 tubes that sway gently in the breeze</li>
                <li><strong>Musical Sounds:</strong> Chimes play pleasant notes every 15-45 seconds (realistic timing, mute button compatible)</li>
                <li><strong>Creature Interactions:</strong> Birds, squirrels, rats, and owls trigger chimes when passing through</li>
                <li><strong>Tree Dependency:</strong> Falls gracefully if tree disappears, owl may deliver replacement after 15 days</li>
                <li><strong>Aesthetic:</strong> Adds calm, meditative atmosphere to your garden</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>üìã Recent Major Updates</summary>
            <ul>
                <li><strong>V40 - Ultimate Chill Overhaul (LATEST):</strong> Birds now truly relaxed! Perch throughout entire tree canopies (25 spots per tree), land and stay on ground with proper thresholds (30px), enforced ground positioning prevents drift. Extended behavior durations: 6min perched, 2.5min sleeping, 2min hopping, 30s feeding, 20s pecking, 5s flying. Player food gets 80% investigation priority even when not hungry. Rare birds (1.5%) auto-noted in diary. Rare tall trees (2% spawn, 33% taller). Fixed screenshot function and wind chime timing. This is the calm, contemplative bird experience!</li>
                <li><strong>V39 - Behavior & Duration Fixes:</strong> Fixed critical bug where MIN_STATE_DURATION overrode flying time. Extended all behavior durations for visibility. Birds now display natural, observable behaviors instead of rapid state-switching.</li>
                <li><strong>Sleep System & Visual Polish:</strong> Birds sleep at night with floating "ZzZz", 8 colorful koi varieties, 95% accurate weather forecasts, smooth sky gradients, baby bird hover info, perfected camera centering</li>
                <li><strong>Special Events & UFO System:</strong> Meteor showers, eclipses, migration waves, and UFO encounters! All with mushroom mode support.</li>
                <li><strong>Fireflies & Night Life:</strong> Glowing fireflies appear on some nights, creating a magical nighttime ecosystem.</li>
                <li><strong>Advanced Mechanics:</strong> Food caching, nest degradation, mushroom clusters, fallen branches, and rare bird color variants!</li>
                <li><strong>Hourly Musical Chimes:</strong> When clock is enabled, birds sing a different melody every hour from a rotating playlist of 24 songs. No repeats until all 24 are played!</li>
                <li><strong>Garden Diary System:</strong> Complete narrative tracking with auto-generated story entries, bird naming system with 80 names (nature + people), family lineage tracking across generations, and timeline view of major events.</li>
                <li><strong>24-Hour Clock Display:</strong> Clock now shows 24-hour format without AM/PM, double-sized for better visibility. Birds can perch on the massive numbers, which become more opaque when occupied.</li>
                <li><strong>Real-Time Clock & Weather Forecast:</strong> Large transparent clock in the sky with 3-icon weather forecast. Birds perch on clock numbers! Includes max history tracking for ponds, frogs, koi, and birdhouses.</li>
            </ul>
        </details>

        <div class="section philosophy">
            <p><strong>Relax. Watch. Enjoy. üåø</strong></p>
        </div>
    </div>

    <!-- Garden Diary -->
    <div id="gardenDiary" class="instruction-manual" style="display: none;">
        <button class="close-btn" id="closeDiaryBtn">√ó</button>
        <h2>üìñ Garden Diary</h2>

        <div class="section">
            <p><em>A chronicle of life in your garden ecosystem.</em></p>
            <p><strong>Day <span id="diaryDayCount">0</span></strong></p>
        </div>

        <div class="section">
            <h3>üìú Recent Events</h3>
            <div id="diaryEntries" style="max-height: 400px; overflow-y: auto; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                <p style="color: #999; font-style: italic;">Your garden story will appear here as events unfold...</p>
            </div>
        </div>

        <div class="section">
            <h3>üê¶ Bird Families</h3>
            <div id="birdFamilies" style="max-height: 300px; overflow-y: auto; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                <p style="color: #999; font-style: italic;">Bird lineages will be tracked here...</p>
            </div>
        </div>

        <!-- Philosophy quote removed per user request -->
    </div>

    <script>
        // ========================================
        // BIRD WINDOW - Garden Ecosystem Simulator
        // Version: V40 (Ultimate Chill Overhaul)
        // ========================================
        // A relaxing, contemplative birdwatching experience featuring:
        // - Extended behavior durations (6min perched, 2min hopping)
        // - Full canopy perching (25 spots per tree)
        // - Enforced ground positioning for natural hopping
        // - Comprehensive ecosystem with 40+ interacting systems
        // - Weather, special events, garden diary, and more
        // ========================================

        // Debug mode with severity levels
        let debugMode = true; // Set to false in production
        let debugVisuals = false; // Start with debug visuals OFF

        const DEBUG_LEVELS = {
            INFO: 1,
            WARNING: 1,
            ERROR: 2
        };

        let currentDebugLevel = DEBUG_LEVELS.WARNING; // Only show warnings and errors by default
        
        // Limit Debug Logging with throttling
        window.debugLogThrottling = {};
        
        function debugLog(message, level = DEBUG_LEVELS.INFO) {
            if (debugMode && level >= currentDebugLevel) {
                // Add throttling for common messages to reduce console spam
                if (level === DEBUG_LEVELS.INFO) {
                    // Use message hashing to track frequency
                    const messageHash = message.split(' ')[0] + message.split(' ')[1];
                    const now = Date.now();
                    
                    // Only log this type of message once every 5 seconds
                    if (!window.debugLogThrottling[messageHash] || 
                        now - window.debugLogThrottling[messageHash] > 5000) {
                        console.log(`DEBUG: ${message}`);
                        window.debugLogThrottling[messageHash] = now;
                    }
                } else {
                    // Always log warnings and errors
                    console.log(`DEBUG: ${message}`);
                }
            }
        }

        // Info panel
        const infoPanel = document.getElementById('infoPanel');
        const toggleInfo = document.getElementById('toggleInfo');
        const statsDisplay = document.getElementById('stats');
        
        if (toggleInfo) {  // Add a safety check
            toggleInfo.addEventListener('click', () => {
                if (infoPanel.style.display === 'none') {
                    infoPanel.style.display = 'block';
                    toggleInfo.textContent = '‚ÑπÔ∏è Hide Info';
                } else {
                    infoPanel.style.display = 'none';
                    toggleInfo.textContent = '‚ÑπÔ∏è Show Info';
                }
            });
        }

        // Curtain toggle
        const toggleCurtains = document.getElementById('toggleCurtains');
        let showCurtains = false;
        
        if (toggleCurtains) {  // Add a safety check
            toggleCurtains.addEventListener('click', () => {
                showCurtains = !showCurtains;
                toggleCurtains.textContent = showCurtains ? 'ü™ü Hide Curtains' : 'ü™ü Show Curtains';
            });
        }

        // Debug toggle with keyboard
        function updateDebugVisuals() {
            // Update the controls hint visibility based on debug state
            const controlsHint = document.getElementById('controlsHint');
            if (controlsHint) {  // Add a safety check
                controlsHint.style.display = 'block'; // Always show the controls hint
                if (debugVisuals) {
                    controlsHint.textContent = "Debug visuals ON (T to toggle)";
                } else {
                    controlsHint.textContent = "Tap/Click to add food";
                }
            }
            
            // Show or hide control panel based on debug mode
            const controlPanel = document.getElementById('controlPanel');
            const keepVisualsActive = document.getElementById('keepVisualsActive');
            
            if (controlPanel) {  // Add a safety check
                if (debugVisuals && !keepVisualsActive) {
                    controlPanel.style.display = 'block';
                } else {
                    controlPanel.style.display = 'none';
                }
            }
        }
        
// ADD YOUR NEW FUNCTION RIGHT HERE:
function activateMushroomMode() {
    // Start mushroom mode
    mushroomMode = true;
    colorCycleTimer = 0;
    
    // Show the toggle button
    const toggleMushroom = document.getElementById('toggleMushroom');
    if (toggleMushroom) {
        toggleMushroom.style.display = 'block';
    }
    
    // Hide the mushroom object
    magicMushroom = null;
    
    // Add special effects for activation
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            addSpecialEffect({
                type: 'sparkle',
                x: canvas.width / 2,
                y: canvas.height / 2,
                duration: 3000,
                intensity: 0.8
            });
        }, i * 300);
    }

    debugLog("üçÑ Mushroom mode activated! Groovy!");
    addDiaryEntry("The magic mushroom reveals psychedelic wonders! Reality becomes a rainbow.", 'special');
}


        // Draw off-screen indicator circles in debug mode
        function drawOffscreenIndicators() {
            if (!debugVisuals) return;
            
            const margin = 30; // Distance from edge of screen
            
            // Check for off-screen birds
            for (const bird of birds) {
                if (bird.x < 0 || bird.x > canvas.width || bird.y < 0 || bird.y > canvas.height) {
                    // Determine indicator position on screen edge
                    let indicatorX = bird.x;
                    let indicatorY = bird.y;
                    
                    // Clamp to screen edge with margin
                    if (bird.x < 0) indicatorX = margin;
                    if (bird.x > canvas.width) indicatorX = canvas.width - margin;
                    if (bird.y < 0) indicatorY = margin;
                    if (bird.y > canvas.height) indicatorY = canvas.height - margin;
                    
                    // Draw indicator circle
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = bird.birdType.bodyColor;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw arrow pointing to off-screen bird
                    const angle = Math.atan2(bird.y - indicatorY, bird.x - indicatorX);
                    ctx.beginPath();
                    ctx.moveTo(indicatorX, indicatorY);
                    ctx.lineTo(
                        indicatorX + Math.cos(angle) * 8,
                        indicatorY + Math.sin(angle) * 8
                    );
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // For other entities like rats or squirrels
            for (const rat of rats) {
                if (rat.x < 0 || rat.x > canvas.width || rat.y < 0 || rat.y > canvas.height) {
                    let indicatorX = rat.x;
                    let indicatorY = rat.y;
                    
                    if (rat.x < 0) indicatorX = margin;
                    if (rat.x > canvas.width) indicatorX = canvas.width - margin;
                    if (rat.y < 0) indicatorY = margin;
                    if (rat.y > canvas.height) indicatorY = canvas.height + margin;
                    
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = rat.isRatKing ? '#4B0082' : '#696969';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            for (const squirrel of squirrels) {
                if (squirrel.x < 0 || squirrel.x > canvas.width || squirrel.y < 0 || squirrel.y > canvas.height) {
                    let indicatorX = squirrel.x;
                    let indicatorY = squirrel.y;
                    
                    if (squirrel.x < 0) indicatorX = margin;
                    if (squirrel.x > canvas.width) indicatorX = canvas.width - margin;
                    if (squirrel.y < 0) indicatorY = margin;
                    if (squirrel.y > canvas.height) indicatorY = margin;
                    
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#B25D18';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Enhanced debugging mode toggle with 'd' key
        document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        // Escape key: close all UI elements for clean view
        const instructionManual = document.getElementById('instructionManual');
        const gardenDiary = document.getElementById('gardenDiary');
        const infoPanel = document.getElementById('infoPanel');
        const toggleInfo = document.getElementById('toggleInfo');
        const diaryToggle = document.getElementById('diaryToggle');

        // Close guide/features menu
        if (instructionManual && instructionManual.style.display === 'block') {
            instructionManual.style.display = 'none';
            debugLog("Guide menu closed with Escape");
        }

        // Close diary
        if (gardenDiary && gardenDiary.style.display === 'block') {
            gardenDiary.style.display = 'none';
            if (diaryToggle) diaryToggle.checked = false;
            debugLog("Diary closed with Escape");
        }

        // Close info panel
        if (infoPanel && infoPanel.style.display === 'block') {
            infoPanel.style.display = 'none';
            debugLog("Info panel closed with Escape");
        }

        // Hide show info button for UI-free view (only if not locked on animal)
        if (!lockedAnimal && toggleInfo && toggleInfo.style.display !== 'none') {
            toggleInfo.style.display = 'none';
            window.showInfoButtonHidden = true;
            debugLog("Show info button hidden with Escape - click anywhere to restore");
        }

        // Unlock animal and reset camera if locked
        if (lockedAnimal) {
            lockedAnimal = null;
            lockedAnimalType = null;
            debugLog("Unlocked animal and reset camera with Escape");
        }
    } else if (e.key === 't' || e.key === 'T') {
        debugVisuals = !debugVisuals;
        updateDebugVisuals();
    } else if (e.key === 'd' || e.key === 'D') {
        // Toggle advanced debugging with performance stats
        debugVisuals = !debugVisuals;

        if (debugVisuals) {
            // Add additional debug info display
            let debugInfo = document.getElementById('advancedDebug');
            if (!debugInfo) {
                debugInfo = document.createElement('div');
                debugInfo.id = 'advancedDebug';
                debugInfo.style.position = 'absolute';
                debugInfo.style.top = '50px';
                debugInfo.style.right = '10px';
                debugInfo.style.background = 'rgba(0, 0, 0, 0.1)';
                debugInfo.style.color = 'white';
                debugInfo.style.padding = '10px';
                debugInfo.style.borderRadius = '5px';
                debugInfo.style.zIndex = '100';
                debugInfo.style.fontSize = '10px';
                debugInfo.style.maxWidth = '200px';
                document.body.appendChild(debugInfo);
            }
        } else {
            const debugElement = document.getElementById('advancedDebug');
            if (debugElement) debugElement.remove();
        }

        updateDebugVisuals();
    } else if (e.key === 'c' || e.key === 'C') {
        // Restore control panel functionality
        const keepVisualsElem = document.getElementById('keepVisualsActive');
        if (keepVisualsElem) {
            keepVisualsElem.remove();
            debugLog("Control panel functionality restored");
            updateDebugVisuals(); // Update UI state
        }
    }
});




function drawBirdTrails() {
    if (!mushroomMode) return; // Only draw trails in mushroom mode
    
    // Draw each trail
    for (const trail of birdTrails) {
        if (trail.positions.length < 2) continue; // Need at least 2 points for a trail
        
        // Create a gradient for the trail
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw each segment with decreasing opacity
        for (let i = 1; i < trail.positions.length; i++) {
            const pos = trail.positions[i];
            const prevPos = trail.positions[i-1];
            
            // Calculate opacity based on position in trail (newer = more opaque)
            // Make trails fade more gradually by using a slower decay
            const opacity = Math.min(1, i / (trail.positions.length * 0.7)); // Slower decay
            
            // Get color based on time and position for rainbow effect
            const hue = (colorCycleTimer / 50 + i * 15) % 360;
            ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${opacity})`;
            
            // Draw line segment
            ctx.beginPath();
            ctx.moveTo(prevPos.x, prevPos.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
    }
    
    // Reset line properties
    ctx.lineWidth = 1;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
}


function updateBirdTrails() {
    if (!mushroomMode) {
        // Clear trails when not in mushroom mode to save memory
        birdTrails = [];
        return;
    }

    // PERFORMANCE OPTIMIZATION: Check if we have too many trail segments across all birds
    // Count total trail points to ensure we don't exceed a reasonable limit
    let totalTrailPoints = 0;
    for (const trail of birdTrails) {
        totalTrailPoints += trail.positions.length;
    }
    
    // If we have too many points, aggressively trim all trails
    const MAX_TOTAL_TRAIL_POINTS = 1000; // Hard cap on total trail points for performance
    if (totalTrailPoints > MAX_TOTAL_TRAIL_POINTS) {
        // Trim all trails by removing 25% of their oldest points
        for (const trail of birdTrails) {
            if (trail.positions.length > 10) { // Keep at least 10 points
                const pointsToRemove = Math.floor(trail.positions.length * 0.25);
                trail.positions.splice(0, pointsToRemove);
            }
        }
        debugLog(`Performance: Trimmed bird trails (${totalTrailPoints} points)`);
    }
    
    // Initialize trail array if needed
    if (birdTrails.length === 0) {
        for (let i = 0; i < birds.length; i++) {
            birdTrails.push({
                birdIndex: i,
                positions: []
            });
        }
    }
    
    // Make sure we have a trail for each bird
    while (birdTrails.length < birds.length) {
        birdTrails.push({
            birdIndex: birdTrails.length,
            positions: []
        });
    }
    
    // Remove trails for birds that no longer exist
    birdTrails = birdTrails.filter(trail => trail.birdIndex < birds.length);
    
    // Update each trail with current bird positions
    for (let i = 0; i < birds.length; i++) {
        const bird = birds[i];
        const trail = birdTrails.find(t => t.birdIndex === i);
        
        if (trail) {
            // Only add a new position if the bird has moved significantly
            const lastPos = trail.positions[trail.positions.length - 1];
            if (!lastPos || distance(bird.x, bird.y, lastPos.x, lastPos.y) > 2) {
                // Add current position to the end
                trail.positions.push({
                    x: bird.x,
                    y: bird.y
                });
                
                // Only limit trail length if positions exceed MAX_TRAIL_LENGTH by a lot
                // This makes trails fade away much more slowly
                if (trail.positions.length > MAX_TRAIL_LENGTH * 2) {
                    // Remove oldest positions, but keep more positions than before
                    trail.positions.splice(0, Math.floor(trail.positions.length * 0.1)); // Remove just 10% of oldest positions
                }
            }
        }
    }
}




        // Update advanced debug stats
        function updateAdvancedDebug(deltaTime) {
            if (!debugVisuals) return;
            
            const debugElement = document.getElementById('advancedDebug');
            if (!debugElement) return;
            
            // Count bird states
            const birdStates = {};
            birds.forEach(bird => {
                birdStates[bird.state] = (birdStates[bird.state] || 0) + 1;
            });
            
            // Format bird states
            let birdStateText = '';
            for (const [state, count] of Object.entries(birdStates)) {
                birdStateText += `${state}: ${count}<br>`;
            }
            
            // Compute performance metrics
            const fps = Math.round(1000 / deltaTime);
            
            debugElement.innerHTML = `
                <strong>Performance:</strong>
                <ul>
                    <li>FPS: ${fps}</li>
                    <li>Entities: ${birds.length + babyBirds.length + worms.length + twigs.length + nests.length}</li>
                </ul>
                <strong>Bird States:</strong><br>
                ${birdStateText}
                <strong>Baby Birds:</strong> ${babyBirds.length}<br>
                <strong>Nest Completion:</strong><br>
                ${nests.map(n => Math.round(n.materialsCollected / NEST_MATERIALS_NEEDED * 100) + '%').join(', ')}
            `;
        }

        function updateStats() {
        
        if (infoPanel.style.display === 'none') return;
    
        // Calculate AM/PM time from currentHour
        let displayHour12 = currentHour % 12;
        if (displayHour12 === 0) displayHour12 = 12; // 0 should display as 12 in 12-hour format
        const amPm = currentHour < 12 ? 'AM' : 'PM';
        
        // 24-hour format is just currentHour
        const displayHour24 = currentHour;
        
        // Calculate minutes (approximation based on timeOfDay)
        const timeOfDayFraction = timeOfDay < 1 ? timeOfDay * 12 : 12 + (timeOfDay - 1) * 12;
        const minuteFraction = timeOfDayFraction - Math.floor(timeOfDayFraction);
        const minutes = Math.floor(minuteFraction * 60);
        
        // Update history maxes
        maxTreesEver = Math.max(maxTreesEver, trees.length);
        maxBirdsEver = Math.max(maxBirdsEver, birds.length);
        maxSquirrelsEver = Math.max(maxSquirrelsEver, squirrels.length);
        maxRatsEver = Math.max(maxRatsEver, rats.length);
        maxWormsEver = Math.max(maxWormsEver, worms.length);
        maxFlowersEver = Math.max(maxFlowersEver, flowers.length);
        maxNestsEver = Math.max(maxNestsEver, nests.length);
        maxPondsEver = Math.max(maxPondsEver, ponds.length);
        maxFrogsEver = Math.max(maxFrogsEver, frogs.length);
        maxKoiEver = Math.max(maxKoiEver, koi.length);
        maxBirdhousesEver = Math.max(maxBirdhousesEver, birdhouses.length);

        statsDisplay.innerHTML = `
    <strong>Entities (Current / Max):</strong>
    <ul>
        <li>Trees: ${trees.length} / ${maxTreesEver}</li>
        <li>Birds: ${birds.length} / ${maxBirdsEver}</li>
        <li>Baby Birds: ${babyBirds.length} (Total Born: ${totalBabiesBorn})</li>
        <li>Nests: ${nests.length} / ${maxNestsEver}</li>
        <li>Birdhouses: ${birdhouses.length} / ${maxBirdhousesEver}</li>
        <li>Worms: ${worms.length} / ${maxWormsEver}</li>
        <li>Twigs: ${twigs.length}</li>
        <li>Rats: ${rats.length} / ${maxRatsEver}</li>
        <li>Squirrels: ${squirrels.length} / ${maxSquirrelsEver}</li>
        <li>Puddles: ${puddles.length}</li>
        <li>Ponds: ${ponds.length} / ${maxPondsEver}</li>
        <li>Frogs: ${frogs.length} / ${maxFrogsEver}</li>
        <li>Koi: ${koi.length} / ${maxKoiEver}</li>
        <li>Food: ${foodItems.length}</li>
        <li>Flowers: ${flowers.length} / ${maxFlowersEver}</li>
    </ul>
    <strong>Time:</strong> ${timeOfDay < 1 ? 'Day' : 'Night'} (${displayHour12}:${minutes.toString().padStart(2, '0')})<br>
    <strong>Weather:</strong> ${isRaining ? (isThundering ? 'Thunderstorm' : 'Raining') : 'Clear'}<br>
    <strong>Days Elapsed:</strong> ${dayNightCycleCount}<br>
    <strong>Rainbows Seen:</strong> ${rainbowsShown}
`;
    }

// Gameboy object and tracking variables
let gameboy = null;
let gameboyOwlDelivered = false;

// Function to spawn the gameboy
function spawnGameboy(x, y, byOwl = false) {
    // If no coords provided, use center of screen
    if (!x || !y) {
        x = canvas.width / 2;
        y = canvas.height * GROUND_HEIGHT_RATIO - 20;
    }
    
    gameboy = {
        x: x,
        y: y,
        width: 30,
        height: 45,
        bobTimer: 0,
        glowTimer: 0,
        byOwl: byOwl,
        clicked: false
    };
    
    // Add sparkle effect
    addSpecialEffect({
        type: 'sparkle',
        x: x,
        y: y - 20,
        duration: 2000,
        intensity: 0.7
    });
    
    debugLog(`Gameboy spawned at (${x}, ${y})${byOwl ? ' by an owl' : ''}`);
}

// Draw the gameboy
function drawGameboy() {
    if (!gameboy) return;
    
    // Simple bobbing animation
    gameboy.bobTimer += 0.03;
    const bobAmount = Math.sin(gameboy.bobTimer) * 2;
    
    // Gameboy body
    ctx.fillStyle = mushroomMode ? getMushroomColor('#333333') : '#333333';
    ctx.fillRect(
        gameboy.x - gameboy.width/2, 
        gameboy.y - gameboy.height + bobAmount, 
        gameboy.width, 
        gameboy.height
    );
    
    // Screen
    ctx.fillStyle = mushroomMode ? getMushroomColor('#7BBA71') : '#7BBA71'; // Classic greenish screen
    ctx.fillRect(
        gameboy.x - gameboy.width/2 + 5, 
        gameboy.y - gameboy.height + 5 + bobAmount, 
        gameboy.width - 10, 
        gameboy.height/2 - 5
    );
    
    // D-pad
    ctx.fillStyle = mushroomMode ? getMushroomColor('#222222') : '#222222';
    ctx.fillRect(
        gameboy.x - gameboy.width/2 + 5, 
        gameboy.y - gameboy.height/2 + 5 + bobAmount, 
        12, 
        12
    );
    
    // A/B buttons
    ctx.beginPath();
    ctx.arc(
        gameboy.x + gameboy.width/2 - 10, 
        gameboy.y - gameboy.height/2 + 8 + bobAmount, 
        4, 0, Math.PI * 2
    );
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(
        gameboy.x + gameboy.width/2 - 8, 
        gameboy.y - gameboy.height/2 + 15 + bobAmount, 
        4, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Start/Select
    ctx.fillRect(
        gameboy.x - 12, 
        gameboy.y - 5 + bobAmount, 
        8, 
        3
    );
    
    ctx.fillRect(
        gameboy.x + 4, 
        gameboy.y - 5 + bobAmount, 
        8, 
        3
    );
    
    // Optional glow effect
    if (mushroomMode || gameboy.glowTimer > 0) {
        gameboy.glowTimer++;
        const glowOpacity = 0.3 + Math.sin(gameboy.glowTimer * 0.05) * 0.2;
        
        ctx.fillStyle = `rgba(200, 255, 200, ${glowOpacity})`;
        ctx.beginPath();
        ctx.arc(
            gameboy.x, 
            gameboy.y - gameboy.height/2 + bobAmount, 
            gameboy.width, 
            0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // Draw debug click hint
    if (debugVisuals) {
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText('Click to play', gameboy.x - 25, gameboy.y - gameboy.height - 10 + bobAmount);
    }
}

// Check for owl delivery of gameboy
function checkOwlGameboyDelivery() {
    // Only try to deliver if gameboy doesn't exist and hasn't been delivered yet
    if (gameboy || gameboyOwlDelivered) return;
    
    // Check if we're past day 30
    if (dayNightCycleCount >= 30) {
        // Small chance for an owl to bring the gameboy
        if (timeOfDay >= 1 && Math.random() < 0.1 && owls.length === 0) {
            // Create a special owl to deliver the gameboy
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const x = side === 'left' ? -30 : canvas.width + 30;
            const y = canvas.height * 0.3 + Math.random() * 100;
            
            const owl = new Owl(x, y);
            owl.isDelivering = true; // Special property
            owls.push(owl);
            
            // Override the owl's update method to make it drop the gameboy
            const originalUpdate = owl.update;
            owl.update = function(deltaTime) {
                // If in middle of screen, drop the gameboy
                if (!gameboyOwlDelivered && 
                    this.x > canvas.width * 0.4 && 
                    this.x < canvas.width * 0.6) {
                    
                    spawnGameboy(this.x, canvas.height * GROUND_HEIGHT_RATIO - 20, true);
                    gameboyOwlDelivered = true;
                    this.isDelivering = false;

                    // Add diary entry for gameboy delivery
                    addDiaryEntry("An owl delivered a mysterious gameboy from the skies!", 'special');

                    // Play a special sound if wind chimes enabled
                    if (windChimeEnabled && audioContext) {
                        const notes = ['C4', 'G4', 'C5'];
                        for (let i = 0; i < notes.length; i++) {
                            setTimeout(() => {
                                playNote(notes[i], 0.8);
                            }, i * 150);
                        }
                    }
                }
                
                // Call original update
                return originalUpdate.call(this, deltaTime);
            }
            
            // Override the draw method to show the owl carrying something
            const originalDraw = owl.draw;
            owl.draw = function() {
                originalDraw.call(this);
                
                // Draw small package under owl if still delivering
                if (this.isDelivering) {
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(
                        this.x - 15, 
                        this.y + 20, 
                        30, 
                        15
                    );
                    
                    // String connecting to owl
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + 5);
                    ctx.lineTo(this.x, this.y + 20);
                    ctx.stroke();
                }
            }
            
            debugLog("Special owl bringing Gameboy has appeared!");
        }
    }
}

// Check for owl delivery of wind chimes
function checkOwlWindChimeDelivery() {
    // No trees, can't deliver
    if (trees.length === 0) return;

    // Check for initial delivery (after day 15, no chimes delivered yet)
    const needsInitialDelivery = !windChimeOwlDelivered && dayNightCycleCount >= 15;

    // Check for replacement delivery (15 days after loss)
    const needsReplacement = windChimeReplacementScheduled &&
                             windChimeLostDay !== null &&
                             dayNightCycleCount >= (windChimeLostDay + 15);

    if (!needsInitialDelivery && !needsReplacement) return;

    // Small chance for an owl to bring wind chimes at night
    if (timeOfDay >= 1 && Math.random() < 0.1 && owls.length === 0) {
            // Create a special owl to deliver wind chimes
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const x = side === 'left' ? -30 : canvas.width + 30;
            const y = canvas.height * 0.3 + Math.random() * 100;

            const owl = new Owl(x, y);
            owl.isDeliveringChimes = true; // Special property
            owls.push(owl);

            // Override the owl's update method to make it drop the wind chimes
            const originalUpdate = owl.update;
            owl.update = function(deltaTime) {
                // V40 FIX: Slow down delivery owl to ensure drop happens
                if (this.isDeliveringChimes && this.x > canvas.width * 0.3 && this.x < canvas.width * 0.7) {
                    // Slow down in drop zone
                    this.velocity.x *= 0.7;
                }

                // V40 FIX: Wider drop window (30%-70% of screen instead of 40%-60%)
                if (this.isDeliveringChimes &&
                    this.x > canvas.width * 0.35 &&
                    this.x < canvas.width * 0.65) {

                    // Find a random tree to hang the wind chimes on
                    const randomTree = trees[Math.floor(Math.random() * trees.length)];
                    const windChime = createWindChime(randomTree.x, randomTree.y, randomTree.trunkHeight);
                    windChime.treeId = randomTree.id;
                    windChimes.push(windChime);

                    windChimeOwlDelivered = true;
                    windChimeEnabled = true; // Auto-enable

                    // FIX: Initialize audio and start playing wind chimes
                    if (!audioContext) {
                        initializeAudio();
                    }
                    lastWindChimeTime = 0; // Reset to trigger immediate chime
                    playWindChimes(); // Start the wind chime playback loop

                    this.isDeliveringChimes = false;

                    // Add diary entry for wind chime delivery (check BEFORE resetting flags)
                    const isReplacement = windChimeReplacementScheduled;
                    if (isReplacement) {
                        addDiaryEntry("An owl delivered replacement wind chimes! They now hang from a tree.", 'special');
                    } else {
                        addDiaryEntry("An owl delivered beautiful wind chimes! They now hang from a tree.", 'special');
                    }

                    // Reset replacement tracking if this was a replacement delivery
                    if (windChimeReplacementScheduled) {
                        windChimeReplacementScheduled = false;
                        windChimeLostDay = null;
                    }

                    // Play a special sound
                    if (audioContext) {
                        const notes = ['E5', 'G5', 'A5', 'C6', 'E6'];
                        for (let i = 0; i < notes.length; i++) {
                            setTimeout(() => {
                                playNote(notes[i], 0.5);
                            }, i * 200);
                        }
                    }

                    debugLog(`Owl delivered wind chimes to tree at (${randomTree.x}) at position (${this.x}, ${this.y})`);
                }

                // Call original update
                return originalUpdate.call(this, deltaTime);
            }

            // Override the draw method to show the owl carrying wind chimes
            const originalDraw = owl.draw;
            owl.draw = function() {
                originalDraw.call(this);

                // Draw small package under owl if still delivering
                if (this.isDeliveringChimes) {
                    // Draw a small wind chime shape under the owl
                    ctx.fillStyle = '#DAA520'; // Golden
                    ctx.beginPath();
                    ctx.arc(this.x, this.y + 22, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw small tubes
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = '#C0C0C0'; // Silver
                        ctx.fillRect(this.x - 6 + i * 4, this.y + 28, 2, 8);
                    }

                    // String connecting to owl
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + 5);
                    ctx.lineTo(this.x, this.y + 20);
                    ctx.stroke();
                }
            }

            debugLog("Special owl bringing wind chimes has appeared!");
    }
}

// Check for gameboy clicks
function checkGameboyClicks(x, y) {
    if (!gameboy) return false;
    
    // Check if click is on gameboy
    if (x >= gameboy.x - gameboy.width/2 && 
        x <= gameboy.x + gameboy.width/2 && 
        y >= gameboy.y - gameboy.height && 
        y <= gameboy.y) {
        
        // List of URLs to randomly choose from
        const gameUrls = [
            "https://www.emptyspeechbubble.com/1bitcat",
            "https://www.emptyspeechbubble.com/1bitwindow",
            "https://www.emptyspeechbubble.com/bba",
            "https://www.emptyspeechbubble.com/bb2",
            
            // Add more URLs as needed
        ];
        
        // Randomly select a URL from the array
        const randomUrl = gameUrls[Math.floor(Math.random() * gameUrls.length)];
        
        // Open the randomly selected URL in a new window
        window.open(randomUrl, "_blank");
        
        // Visual feedback
        gameboy.glowTimer = 1;
        
        debugLog(`Gameboy clicked, opening ${randomUrl}`);
        return true;
    }
    
    return false;
}

// Update function to add to main loop
function updateGameboy(deltaTime) {
    // Check for owl delivery
    checkOwlGameboyDelivery();
    checkOwlWindChimeDelivery(); // Also check for wind chime delivery

    // Draw gameboy if it exists
    if (gameboy) {
        drawGameboy();
    }
}
        // Animation control
        let animationRunning = false;
        let animationTimers = [];

        // Improved timer management - helper function for adding timers with proper type tracking
        function addTimer(timer, isInterval = false) {
            const timerObj = { id: timer, isInterval: isInterval };
            animationTimers.push(timerObj);
        }
        
        // Improved stopAnimation function to handle both types properly
        function stopAnimation() {
            animationRunning = false;
            
            // Properly clear all timers based on their type
            animationTimers.forEach(timer => {
                if (timer.isInterval) {
                    clearInterval(timer.id);
                } else {
                    clearTimeout(timer.id);
                }
            });
            
            animationTimers = [];
            debugLog("Animation stopped");
        }

        // Enable full screen mode on mobile
        function enableFullscreen() {
            const elem = document.documentElement;
            
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
        }

        // Check if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            document.addEventListener('touchstart', function() {
                // Try to enable fullscreen on first touch
                if (!document.fullscreenElement) {
                    enableFullscreen();
                }
            }, {once: true});
        }

        // Canvas setup with error handling
        const canvas = document.getElementById('gardenCanvas');
        if (!canvas) throw new Error("Canvas element not found!");
        debugLog("Canvas element found.");

        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error("Could not get 2D rendering context!");
        debugLog("2D rendering context acquired.");

        // Initialize canvas size immediately
        function initializeCanvasSize() {
            // Immediate sizing on page load
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Set initial reference sizes
            originalWidth = window.innerWidth;
            originalHeight = window.innerHeight;
            
            debugLog(`Canvas initialized to full screen: ${canvas.width}x${canvas.height}`);
        }
        
        // Global variables
        let worms = [];
        let birdPoops = [];
        let rats = [];
        let trees = [];
        let bushes = []; // Ground-level bushes for perching, food, and creature spawns
        let twigs = [];
        let butterflies = [];
const MAX_BUTTERFLIES = 10;
const dayNightDuration = 240000; // 4 minutes for a full day/night cycle
let owls = []; // Array to hold owls
const MAX_OWLS = 2; // Maximum number of owls at once
const OWL_SPAWN_CHANCE = 0.008; // Base chance per check
const RAT_KING_OWL_ATTRACTION = 0.2; // Higher chance of owl spawning when rat king present
        let lightningStrikes = [];
        let birds = [];
        let eggs = []; // NEW: Egg incubation stage before baby birds
        let babyBirds = [];
        let squirrels = [];
        let foodItems = [];
        let nests = [];
        let birdhouses = [];
        let puddles = [];
        let ponds = []; // Array for permanent ponds
        let frogs = []; // Array for frogs
        let koi = []; // Array for koi fish
        let flowers = []; // Array for flowers
        let stones = []; // Array for decorative stones/rocks
        let specialEffects = []; // Added for special visual effects
        let crows = [];
let crowVisitInProgress = false;
let crowVisitTimer = 0;
const CROW_VISIT_DURATION = 60000; // 1 minute crow visit
const CROW_WORM_THRESHOLD = 30; // Spawn crows when worms exceed this number
const MAX_CROWS = 7; // Size of a murder of crows
let antHill = null;
let ants = [];

        let isTabVisible = true; // Add this line here
        let totalBabiesBorn = 0; // Track total babies born counter

        // Mouse tracking for bird hover/click interactions
        let mouseX = 0;
        let mouseY = 0;
        let hoveredBird = null;
        let hoveredBabyBird = null; // Track hovered baby birds
        let hoveredTree = null;
        let hoveredTreeStartTime = 0; // Track when tree hover started
        const TREE_HOVER_TIMEOUT = 10000; // 10 seconds
        let lockedAnimal = null; // Can be bird, squirrel, rat, crow, owl, or tree
        let lockedAnimalType = null; // Type of locked animal
        let lockedAnimalTime = 0; // Track when animal was locked for auto-fade
        const LOCKED_UI_FADE_TIME = 10000; // 10 seconds
        let cameraOffsetX = 0;
        let cameraOffsetY = 0;
        let cameraZoom = 1.0; // 1.0 = normal, 1.5 = 50% zoom

        // History tracking - maximum counts ever seen
        let maxTreesEver = 0;
        let maxBirdsEver = 0;
        let maxSquirrelsEver = 0;
        let maxRatsEver = 0;
        let maxWormsEver = 0;
        let maxFlowersEver = 0;
        let maxNestsEver = 0;
        let maxPondsEver = 0;
        let maxFrogsEver = 0;
        let maxKoiEver = 0;
        let maxBirdhousesEver = 0;

        let mushroomMode = false;
let colorCycleTimer = 0;
let lastColorCycleUpdate = 0;
let magicMushroomAppeared = false;
let magicMushroom = null;
let hadRainbow = false;
let hadAnts = false
let birdTrails = []; // Will store past positions of birds
const MAX_TRAIL_LENGTH = 100; // How many past positions to remember
let mushroomEffectSpeed = 0.03; // Control speed of mushroom mode effects

// Regular mushroom clusters (non-magic) - grow near tree bases after rain
let mushroomClusters = [];

// Food caching system for squirrels and crows
let foodCaches = []; // {x, y, type: 'nut'|'seed', ownerId, createdTime, expiresIn: 3 days}

// Firefly system - nighttime glowing insects
let fireflies = []; // {x, y, vx, vy, glowPhase, glowIntensity, caught}
let tallGrassPatches = []; // Ground-level tall grass sections
let fireflyNightActive = false; // Whether fireflies should appear this night

// UFO encounter system
let ufo = null; // {x, y, vx, vy, state, target, beamProgress, returnTime}
let ufoEncounterCooldown = 0; // Prevent UFO from appearing too frequently
const UFO_COOLDOWN_DURATION = 3 * 60000; // 3 minutes between possible encounters
let beamedUpEntities = []; // Track entities that were beamed up and returned glowing

// Special Events System
let meteorShower = null; // {active, meteors: [], duration, elapsed}
let eclipse = null; // {active, phase, elapsed, totalDuration}
let migrationWave = null; // {active, birds: [], duration, elapsed}
let specialEventCooldown = 0; // Prevent events from happening too close together
const EVENT_COOLDOWN_DURATION = 5 * 60000; // 5 minutes between events

let playingTheHits = false; // Flag to disable random chirps during playthehits performance
let foodMaxedOutTimer = 0; // Track how long food has been at max
const FOOD_MAX_RAT_ATTRACTION_TIME = 30000; // 30 seconds of max food attracts rats

// Rainbow variables
let rainbowVisible = false;
let rainbowOpacity = 0;
let rainbowTimer = 0;
let rainbowDuration = dayNightDuration; // Rainbow lasts for a full day/night cycle instead of 60000ms
let isDoubleRainbow = false; // 1% chance for double rainbow

// Scarecrow variables
let scarecrow = null;
let scarecrowCreated = false;
        
        let isRaining = false;
let isThundering = false;
let wasRaining = false;  // Track rain state change
let tallTreeCount = 0;
let simulationTime = 0; // Track total simulation time for better spawning control
let lastStatsUpdate = 0; // Track when we last updated the stats display
let cloudCover = 0; // For weather transition effects
let isMuted = false; // Global mute state for all audio

// FPS Monitoring for performance tracking
let fpsFrames = [];
let currentFPS = 60;
let lowFPSWarningShown = false;
let lastFPSWarningTime = 0;
let lastTime = Date.now(); // Animation timing variable

// === NEW BIRD BEHAVIOR SYSTEMS ===
// Danger zone memory - shared across all birds
let dangerZones = []; // {x, y, timestamp, threatType}
const DANGER_MEMORY_DURATION = 180000; // Remember danger for 3 minutes
const DANGER_ZONE_RADIUS = 150; // How far to avoid danger zones

// Shared flock knowledge for food locations
let sharedFoodKnowledge = []; // {x, y, timestamp, discoveredBy}
const FOOD_KNOWLEDGE_DURATION = 120000; // Share food knowledge for 2 minutes

// Chirp types for different communication
const CHIRP_TYPES = {
    SOCIAL: 'social',
    FOOD_CALL: 'food_call',
    CONTACT_CALL: 'contact_call',
    ALERT: 'alert',
    TERRITORIAL: 'territorial',
    VICTORY: 'victory'
};

// Active chirps in the world
let activeChirps = []; // {x, y, type, timestamp, birdId}

// EMOJI CONVERSATIONS: Birds sometimes have emoji conversations!
let emojiConversations = []; // {bird1, bird2, exchanges: [{bird, emoji, timestamp}], startTime}
let lastEmojiConversationTime = 0;

// ENHANCED: Emoji sets for different situations with much more variety
const EMOJI_SETS = {
    FOOD: ['üåΩ', 'üçû', 'üêõ', 'üå∞', 'üçá', 'ü•ú', 'üåæ', 'üçí', 'ü´ê', 'üçì', 'üåª', 'ü•ê', 'üßÄ', 'ü•®'],
    WEATHER: ['‚òÄÔ∏è', 'üåßÔ∏è', '‚ùÑÔ∏è', '‚òÅÔ∏è', 'üåà', '‚õàÔ∏è', 'üí®', 'üå§Ô∏è', '‚õÖ', 'üå•Ô∏è', 'üå¶Ô∏è', 'üå®Ô∏è', 'üíß', '‚ö°'],
    STATES: ['üòä', 'üò¥', 'ü§î', 'üòã', 'üò∞', 'üòé', 'ü•±', 'ü§ó', 'ü§©', 'üòå', 'ü•∞', 'üòÖ', 'üòÇ', 'ü§™', 'üòµ‚Äçüí´'],
    NATURE: ['üå≥', 'üå∏', 'üçÉ', 'üíê', 'üå∫', 'ü¶ã', 'üêù', 'üåª', 'üå∑', 'üåπ', 'üèµÔ∏è', 'üåº', 'üçÇ', 'üåø', 'ü™¥'],
    REACTIONS: ['‚ùì', '‚ùó', 'üí≠', 'üí¨', 'üëÄ', 'üëç', 'üòÖ', 'ü§∑', 'üëè', 'üôå', '‚úåÔ∏è', 'ü§ù', 'üí™'],
    RANDOM: ['üéµ', '‚ú®', 'üí´', '‚≠ê', 'üé®', 'üé≠', 'üé™', 'üéà', 'üéâ', 'üéä', 'üèÜ', 'üéØ', 'üé≤'],
    PHILOSOPHY: ['ü§î', 'üí≠', 'üåå', 'üîÆ', 'üìö', 'üß†', 'üí°', 'ü§Ø', 'üåü', 'ü™ê'],
    GOSSIP: ['üëÄ', 'ü§´', 'üòè', 'üó£Ô∏è', 'üëÇ', 'üí¨', 'üò≥', 'ü§≠', 'üëÅÔ∏è'],
    EXCITEMENT: ['ü§©', 'üéâ', 'ü•≥', 'üíÉ', 'üï∫', 'üôå', 'üéä', 'üéà', '‚ú®', 'üí•'],
    COMPLAINT: ['üò§', 'üòë', 'üôÑ', 'üòí', 'üòÆ‚Äçüí®', 'üò©', 'üò´', 'ü§¶', 'üí¢'],
    FRIENDSHIP: ['ü§ù', 'üíï', 'ü•∞', 'üòä', 'ü´Ç', 'üíñ', 'üåà', '‚ú®'],
    MYSTERY: ['üëª', 'üéÉ', 'üåô', '‚≠ê', 'üîÆ', 'ü™Ñ', '‚ú®', 'üåü', 'üí´']
};

// Sentinel rotation tracking
let currentSentinels = new Map(); // Maps flock groups to sentinel bird
let sentinelRotationTimers = new Map(); // Track when to rotate sentinel

// Mobbing coordination
let activeMobbings = []; // {targetX, targetY, participants: [], startTime}

// Territorial disputes tracking
let territorialDisputes = []; // {bird1, bird2, location, startTime}

// Constants for new behaviors
const SENTINEL_ROTATION_INTERVAL = 25000; // 25 seconds
const MOBBING_DURATION = 30000; // 30 seconds (updated to match BIRD_STATE_DURATION)
const MOBBING_DIVE_FREQUENCY = 2000; // Dive every 2 seconds
const GROUND_ESCAPE_DELAY = 250; // 250ms delay for ground birds
const PECKING_INTERVAL_SOLO = 800; // Solo bird pecking speed
const PECKING_INTERVAL_GROUP = 500; // Group feeding pecking speed
const FLOCK_DISTANCE = 200; // Birds within this distance are considered flockmates
const CONTACT_CALL_DISTANCE = 150; // Call when flockmates are this far
const TERRITORIAL_DISPLAY_DURATION = 20000; // 20 seconds (updated to match BIRD_STATE_DURATION)
const FEAR_OVERRIDE_HUNGER = 600; // Hunger level that overrides fear
let currentHour = 9; // Track the hour of day (0-23)
let lastHourlyUpdate = 0; // Track when we last updated the hourly activities
let timeOfDay = 0.75; // Track day/night cycle (0-1 = day, 1-2 = night)
let previousTimeOfDay = 0.75; // For tracking day/night transitions
let dayNightCycleCount = 0; // Count completed day/night cycles
let rainbowsShown = 0; // Track number of rainbows that have appeared
let rainsCompleted = 0; // Track number of completed rain events (for pond formation)
        
        // Wind Chime Sound Effect System
        let windChimeEnabled = false;
        let windChimes = []; // Array to hold visual wind chime objects
        let windChimeOwlDelivered = false; // Track if owl has delivered wind chimes
        let windChimeLostDay = null; // Track when a wind chime was lost for replacement scheduling
        let windChimeReplacementScheduled = false; // Track if replacement is already scheduled

        // Clock and Weather Forecast System
        let clockEnabled = false;
        let weatherForecast = []; // Array of {type: 'rain'|'thunder'|'clear', time: timestamp}
        let nextWeatherEvents = []; // Next 3 upcoming events for display
        let lastHourChimed = -1; // Track last hour that played a melody
        let hourlyMelodyPlaylist = []; // Shuffled playlist of 24 melodies
        let melodyPlaylistIndex = 0; // Current position in playlist

        // Garden Diary System
        let diaryEntries = []; // Array of {day: number, event: string, timestamp: number, type: string}
        let birdNames = []; // Pool of bird names
        let birdFamilies = new Map(); // Map bird ID to family info {name, generation, parents}
        let lastDiaryUpdate = 0;

        // Bird name pools (nature names + normal people names)
        const BIRD_NAME_POOL = [
            // Nature-inspired names
            'Ruby', 'Sky', 'Pepper', 'Sunny', 'Cloud', 'Storm', 'Willow', 'Cedar',
            'Maple', 'Birch', 'Ash', 'Rowan', 'Luna', 'Sol', 'Star', 'Dawn',
            'Dusk', 'River', 'Brook', 'Meadow', 'Forest', 'Sage', 'Basil', 'Rosemary',
            'Jasper', 'Onyx', 'Pearl', 'Amber', 'Jade', 'Coral', 'Ivy', 'Fern',
            'Thistle', 'Clover', 'Poppy', 'Daisy', 'Violet', 'Lily', 'Rose', 'Iris',
            // Additional nature names
            'Hazel', 'Indigo', 'Sapphire', 'Sienna', 'Topaz', 'Crimson', 'Azure', 'Olive',
            'Aspen', 'Cypress', 'Juniper', 'Magnolia', 'Sequoia', 'Sycamore', 'Zinnia', 'Azalea',
            'Canyon', 'Delta', 'Echo', 'Frost', 'Glacier', 'Harbor', 'Mesa', 'Prairie',
            // Normal American names
            'Alex', 'Sam', 'Jordan', 'Taylor', 'Morgan', 'Casey', 'Riley', 'Quinn',
            'Charlie', 'Jamie', 'Blake', 'Drew', 'Parker', 'Avery', 'Reese', 'Harper',
            'Elliot', 'Skylar', 'Peyton', 'Cameron', 'Dakota', 'Rowan', 'Sage', 'River',
            'Finley', 'Hayden', 'Logan', 'Ryan', 'Jesse', 'Kelly', 'Terry', 'Robin',
            'Pat', 'Chris', 'Nico', 'Ash', 'Jules', 'Max', 'Lee', 'Ray',
            // More American names
            'Ben', 'Emma', 'Jack', 'Olivia', 'Noah', 'Sophia', 'Liam', 'Ava',
            'Mason', 'Mia', 'Lucas', 'Ella', 'Ethan', 'Grace', 'James', 'Chloe',
            'Oliver', 'Zoe', 'Henry', 'Lily', 'Michael', 'Emily', 'Daniel', 'Hannah',
            'Matthew', 'Sarah', 'David', 'Rachel', 'Joseph', 'Madison', 'Andrew', 'Sophie',
            'John', 'Natalie', 'Luke', 'Abby', 'Nick', 'Katie', 'Tom', 'Molly',
            'Will', 'Annie', 'Jake', 'Maggie', 'Pete', 'Becky', 'Frank', 'Jenny',
            'Steve', 'Laura', 'Bob', 'Amy', 'Tim', 'Beth', 'Mark', 'Claire',
            'Paul', 'Diana', 'Rick', 'Fiona', 'Greg', 'Heather', 'Dan', 'Jessica',
            // Additional American names
            'William', 'Seth', 'Justin', 'Michelle', 'Romeo', 'Elizabeth', 'Anne', 'Brandon',
            'Samantha', 'Tyler', 'Ashley', 'Derek', 'Melissa', 'Trevor', 'Nicole', 'Dustin',
            'Brittany', 'Marcus', 'Vanessa', 'Keith', 'Stephanie', 'Jeremy', 'Christina', 'Vincent'
        ];

        // Squirrel name pool
        const SQUIRREL_NAME_POOL = [
            'Nutkin', 'Acorn', 'Hazel', 'Chester', 'Chip', 'Dale', 'Sandy', 'Rusty',
            'Whiskers', 'Scamper', 'Nibbles', 'Chipper', 'Fluffy', 'Bushy', 'Jumper', 'Chatter',
            'Twig', 'Branch', 'Leaf', 'Pinecone', 'Oak', 'Walnut', 'Pecan', 'Cashew',
            'Almond', 'Peanut', 'Pistachio', 'Macadamia', 'Hazelnut', 'Chestnut'
        ];

        // Rat name pool
        const RAT_NAME_POOL = [
            'Remy', 'Splinter', 'Templeton', 'Rizzo', 'Socrates', 'Ben', 'Willard', 'Nicodemus',
            'Ratticus', 'Squeaky', 'Whiskers', 'Shadow', 'Midnight', 'Scurry', 'Sneaky', 'Nibbler',
            'Rascal', 'Bandit', 'Thief', 'Scavenger', 'Prowler', 'Slinky', 'Snitch', 'Whisper',
            'Dusty', 'Smokey', 'Pepper', 'Ash', 'Coal', 'Soot'
        ];

        // Crow name pool
        const CROW_NAME_POOL = [
            'Edgar', 'Poe', 'Raven', 'Corvus', 'Huginn', 'Muninn', 'Crowley', 'Morrigan',
            'Odin', 'Shadow', 'Midnight', 'Coal', 'Jet', 'Obsidian', 'Noir', 'Shade',
            'Phantom', 'Spectre', 'Ghost', 'Spirit', 'Wraith', 'Gloom', 'Dusk', 'Eclipse',
            'Merlin', 'Salem', 'Gotham', 'Blackwing', 'Nightfall', 'Darkstar'
        ];

        // Owl name pool
        const OWL_NAME_POOL = [
            'Athena', 'Hoot', 'Archimedes', 'Hedwig', 'Errol', 'Pigwidgeon', 'Bubo', 'Jareth',
            'Glimmer', 'Twilight', 'Moonbeam', 'Starbright', 'Whisper', 'Silent', 'Hunter', 'Talon',
            'Screech', 'Barny', 'Horace', 'Minerva', 'Noctis', 'Luna', 'Celeste', 'Aurora',
            'Sage', 'Wisdom', 'Oracle', 'Seer', 'Prophet', 'Mystic'
        ];

        // Tree name pool - WHIMSICAL NAMES!
        const TREE_NAME_POOL = [
            'Mr. Branches', 'Lady Leafsworth', 'Sir Twiggins', 'Dame Barkley', 'Lord Canopy',
            'Professor Rootbeard', 'Captain Timber', 'Duchess Fernleaf', 'Baron von Shade',
            'Dr. Photosynthesis', 'Count Chlorophyll', 'Madame Greenery', 'General Oaksworth',
            'Colonel Conifer', 'Major Maple', 'Sergeant Sprout', 'Admiral Acorn',
            'Squire Sapwood', 'Prince Pinecone', 'King Knothole', 'Queen Quercus',
            'Chancellor Chestnut', 'Archbishop Ash', 'Duke Deciduous', 'Viscount Vine',
            'Baroness Birch', 'Earl Evergreen', 'Marquis Magnolia', 'Sultan Sycamore',
            'Emperor Elder', 'Empress Elm', 'Tsar Tamarack', 'Pharaoh Fig'
        ];

        const FROG_NAME_POOL = [
            'Lily', 'Croaker', 'Hoppy', 'Ribbit', 'Splash', 'Puddles', 'Leap', 'Tadpole',
            'Marsh', 'Pond', 'Mossy', 'Cricket', 'Bullfrog', 'Peeper', 'Spring', 'Dewdrop',
            'Kermit', 'Freddy', 'Toad', 'Bog', 'Swampy', 'Mire', 'Jumper', 'Hopper',
            'Greenie', 'Slimy', 'Webfoot', 'Croaky', 'Bumpy', 'Warty'
        ];

        const KOI_NAME_POOL = [
            'Kohaku', 'Tancho', 'Sanke', 'Showa', 'Kujaku', 'Ogon', 'Asagi', 'Shusui',
            'Goldie', 'Shimmer', 'Glimmer', 'Flash', 'Suki', 'Hana', 'Yuki', 'Sakura',
            'Bubbles', 'Finley', 'Splash', 'Ripple', 'Current', 'Float', 'Drift', 'Glide',
            'Pearl', 'Coral', 'Marina', 'Aqua', 'Wave', 'Tide'
        ];

        const ANT_NAME_POOL = [
            'Scout', 'Worker', 'Tiny', 'Speedy', 'Marcher', 'Hauler', 'Digger', 'Builder',
            'Forager', 'Soldier', 'Crawler', 'Climber', 'Antony', 'Adam', 'Andy', 'Atlas',
            'Busy', 'Dotty', 'Bit', 'Chip', 'Crumb', 'Grain', 'Speck', 'Mite',
            'Red', 'Black', 'Fire', 'Leaf', 'Carpenter', 'Harvester'
        ];

        let squirrelFamilies = new Map(); // Map squirrel ID to name
        let ratFamilies = new Map(); // Map rat ID to name
        let crowFamilies = new Map(); // Map crow ID to name
        let owlFamilies = new Map(); // Map owl ID to name
        let treeFamilies = new Map(); // Map tree ID to name
        let frogFamilies = new Map(); // Map frog ID to name
        let koiFamilies = new Map(); // Map koi ID to name
        let antFamilies = new Map(); // Map ant ID to name
        let windChimeSounds = [];
        let windChimeTimeout = null;
        let lastWindChimeTime = 0;
        let windChimeStartTime = 0; // When wind chimes were turned on
        let windChimeDuration = 15 * 60 * 1000; // 15 minutes in milliseconds
        
        // Audio system for wind chimes
        let audioContext = null;
        
        // Original viewport size to maintain proper object scale
        let originalWidth = window.innerWidth;
        let originalHeight = window.innerHeight;

        // Call this function right after getting the context
        initializeCanvasSize();

        // Update constants for better ecosystem balance
        const GROUND_HEIGHT_RATIO = 0.75;

        // Responsive scaling for pathfinding thresholds based on screen height
        // Baseline: 900px height (common laptop resolution)
        // Higher resolution monitors get proportionally larger thresholds
        // ENHANCED: Clamped to reasonable range to prevent extreme zoom issues
        const getResponsiveScale = () => {
            const scale = canvas.height / 900;
            return Math.max(0.8, Math.min(2.5, scale)); // Clamp between 0.8x and 2.5x
        };

        const BIRD_MAX_HUNGER = 800;
        const BIRD_HUNGER_RATE = 0.006; // Further reduced from 0.02 to encourage less food hunting
        const HUNGER_CRITICAL_THRESHOLD = 300;
        const BIRD_POOP_DELAY = 360000; // 6 minutes between poops
        const TREE_DEGRADATION_RATE = 0.25;
        const TREE_HEALTH_THRESHOLD = 0;
        const BIRD_VISION_RADIUS = 400; // Reduced from 500 for better gameplay balance
        const BIRD_FOOD_VISION_RADIUS = 800; // Reduced from 1080 for better balance
        const RAT_VISION_RADIUS = 80;
        const SQUIRREL_VISION_RADIUS = 70;
        const STAR_COUNT = 100;
        const WORM_WIGGLE_SPEED = 0.1;
        const MAX_RATS = 5; // Reduced from 6
        const RAT_KING_FORMATION_CHANCE = 0.03; // FIXED: Much rarer (3% instead of 10%)
        const MAX_SQUIRRELS = 3; // Reduced from 4
        const TWIG_SPAWN_RATE = 10000; // Every 10 (?) seconds
        const ANT_SPEED = 0.6;
        const FOOD_CARRY_SPEED = 0.4; // Slower when carrying food
        const MAX_ANTS = 20;
        const MAX_ANT_DISTANCE = 200; // Maximum distance ants can travel from hill
        const BIRD_SPAWN_RATE = 300000; // Every 5 minutes, check if we need more birds
        const WILD_BIRD_SPAWN_RATE = 120000; // Wild birds come every 2 minutes
        const WILD_BIRD_SPAWN_CHANCE = 0.2; // Reduced from 0.25
        const TREE_REGROWTH_RATE = 180000; // Every 2 minutes
        const GUARANTEED_TREE_CHECK_RATE = 40000; // Check for minimum tree count every 40 seconds
        const POOP_WASH_RATE = 0.2;
        const RAIN_SLOWDOWN_FACTOR = 0.6;
        const PUDDLE_EVAPORATION_RATE = 0.0003; // Increased from 0.0012 for faster evaporation
        const GRAVITY = 0.015;
        const AIR_RESISTANCE = 0.98;
        const MAX_TREES = 25;
        const MIN_TREES = 3;
        const TREE_LIFESPAN = 1200000; // 20 minutes
        const BRANCH_GROWTH_INTERVAL = 540000; // 9 minutes
        const LIGHTNING_CHANCE = 0.3; // 30% chance of lightning during rain
        const LIGHTNING_TREE_DAMAGE = 70; // Damage to tree from lightning
        const SPECIAL_TWIG_CHANCE = 0.7; // 70% chance of a twig being special after lightning
        const RAIN_PROBABILITY = 0.95; // 95% accuracy for weather forecast 
        const MAX_BIRDS = 50;
        const MAX_FOOD = 50; // REDUCED from 70 - encourage consumption
        const MAX_SPEED = 5; // Maximum speed for moving entities
        const MIN_STATE_DURATION = 3000; // Minimum 3 seconds to prevent rapid toggling (BIRD_STATE_DURATION handles visibility)
        const MAX_BIRD_POOPS = 10;
        const MAX_PUDDLES = 13; // Limit puddles for performance
        const MAX_WORMS = 30; // REDUCED from 45 - encourage consumption
        const MAX_TWIGS = 15; // REDUCED from 20 - encourage consumption
        const MAX_NEST_FIND_ATTEMPTS = 20; 
        const NEST_MATERIALS_NEEDED = 4;
        const WORM_SPAWN_RATE = 10000; // Every 10 seconds

        // Flower colors and types
        const FLOWER_COLORS = [
            "#FF5733", // Orange-red
            "#C70039", // Red
            "#900C3F", // Dark red
            "#581845", // Purple
            "#FFC300", // Yellow
            "#DAF7A6", // Light green
            "#FF5733", // Orange
            "#2980B9", // Blue
            "#8E44AD", // Purple
            "#F1C40F", // Yellow
            "#D35400", // Orange
            "#2ECC71", // Green
            "#E74C3C"  // Red
        ];

        const MAX_FLOWERS = 30; // Maximum number of flowers to display

        // V26: Adjusted bird behavior preferences for more perching and resting
        // IMPORTANT: These are RELATIVE PREFERENCE WEIGHTS, not probabilities
        // They are used independently in different decision contexts throughout the bird AI
        // - Some are used as direct probability thresholds (e.g., "if (random < PERCHING)")
        // - Some are combined additively for cumulative checks (e.g., "if (r < PERCHING + FEEDING)")
        // - They do NOT need to sum to 1.0 as they represent preference strengths, not a probability distribution
        // Higher values = stronger preference for that behavior in its specific context
        const BIRD_STATE_PREFERENCES = {
            PERCHING: 0.80,    // 80% preference - birds perch much more for calm vibe
    RESTING: 0.20,     // 20% preference - occasional ground resting
    FLYING: 0.02,      // 2% preference - minimal flying for calm atmosphere
    FEEDING: 0.25,     // 25% weight - used additively with other preferences
    FORAGING: 0.09,    // 9% preference - occasional foraging behavior
    BUILDING: 0.015,   // 1.5% preference - rare nest building attempts
    HOPPING: 0.70      // 70% preference - strong ground hopping for visible foraging
        };
        
        // V39: MAJOR BEHAVIOR DURATION OVERHAUL - All behaviors last 20-30+ seconds for visibility
        const BIRD_STATE_DURATION = {
            IDLE: 60000,        // 1 minute - calm idle time
    PERCHED: 360000,    // 6 minutes - birds spend most time perching peacefully
    FLEEING: 8000,      // 8 seconds - fleeing from danger
    SHELTERING: 45000,  // 45 seconds - taking shelter
    RESTING: 120000,    // 2 minutes - ground resting
    BATHING: 30000,     // 30 seconds - bathing behavior
    FLYING: 5000,       // 5 seconds - REDUCED to minimize exhausting flying
    HOPPING: 120000,    // 2 minutes - extended ground hopping (visible behavior)
    // Activity states
    HUNTING: 20000,     // 20 seconds to hunt target
    COLLECTING: 20000,  // 20 seconds to collect twig
    BUILDING: 25000,    // 25 seconds to build nest
    BUILDING_BIRDHOUSE: 25000, // 25 seconds to build birdhouse
    FEEDING: 30000,     // 30 seconds foraging on ground
    PECKING: 20000,     // 20 seconds pecking behavior
    MOBBING: 30000,     // 30 seconds harassing predator (more visible)
    TERRITORIAL_DISPLAY: 20000, // 20 seconds dominance display (more visible)
    FLEEING_GROUND: 500, // 0.5 seconds ground escape delay
    SENTINEL: 45000,    // 45 seconds standing guard (more visible)
    // Essential behaviors
    PREENING: 30000,    // 30 seconds - grooming session
    DRINKING: 8000,     // 8 seconds - drinking
    ALARM: 1500,        // 1.5 seconds - brief freeze before action
    NEST_SITTING: 180000, // 3 minutes - sitting on nest
    SLEEPING: 150000    // 2.5 minutes - sleeping (much longer, more visible at night)
        };
        
        // Morning food spawn rates
        const MORNING_WORM_SPAWN_COUNT = 20;
        const MORNING_FOOD_SPAWN_COUNT = 10;
        
        // Problem areas for bird movement
        const problemAreas = [
            // Original problematic areas
            {x: 100, radius: 60},
            {x: 928, radius: 60},
            {x: 888, radius: 60},
            {x: 904, radius: 60},
            // New problem areas identified from logs
            {x: 882, radius: 70},
            {x: 877, radius: 70},
            {x: 864, radius: 70},
            {x: 873, radius: 70},
            {x: 900, radius: 70},
            {x: 866, radius: 70},
            {x: 887, radius: 70},
            {x: 859, radius: 70},
            // Screen edges
            {x: 0, radius: 50},
            {x: canvas.width, radius: 50}
        ];
        
        for (const tree of trees) {
    problemAreas.push({
        x: tree.x,
        radius: tree.trunkWidth * tree.scale * 2
    });
}



        // Bird states
        const BIRD_STATES = {
            IDLE: 'idle',
            PERCHED: 'perched',
            HUNTING: 'hunting',
            COLLECTING: 'collecting',
            BUILDING: 'building',
            FEEDING: 'feeding',
            FLEEING: 'fleeing',
            SHELTERING: 'sheltering',
            RESTING: 'resting',
            BATHING: 'bathing',
            FLYING: 'flying',
            BUILDING_BIRDHOUSE: 'building_birdhouse',
            HOPPING: 'hopping',
            SENTINEL: 'sentinel', // Standing guard while others feed
            MOBBING: 'mobbing', // Harassing predators
            PECKING: 'pecking', // Ground pecking for food
            TERRITORIAL_DISPLAY: 'territorial_display', // Showing dominance
            FLEEING_GROUND: 'fleeing_ground', // Escaping from ground (slower)
            // Phase 1 - Essential Realism States
            PREENING: 'preening', // Grooming feathers
            DRINKING: 'drinking', // Drinking water (separate from bathing)
            ALARM: 'alarm', // Freeze response before fleeing
            NEST_SITTING: 'nest_sitting', // Incubating/warming nest
            SLEEPING: 'sleeping' // Sleeping at night or during rest
        };
        
        const BIRDHOUSE_MATERIALS_NEEDED = 5;

        // Bird types for variety
        const BIRD_TYPES = [
            {
                name: "Bluebird",
                color: "blue",
                bodyColor: "#3498db",
                bellyColor: "#a9cce3",
                wingColor: "#2980b9",
                sizeMultiplier: 1.0,
                speedMultiplier: 1.1,
                glideRatio: 0.3,
                wingFlapAmplitude: 1.0
            },
            {
                name: "Cardinal",
                color: "red",
                bodyColor: "#e74c3c",
                bellyColor: "#f5b7b1",
                wingColor: "#c0392b",
                sizeMultiplier: 1.05,
                speedMultiplier: 1.0,
                glideRatio: 0.2,
                wingFlapAmplitude: 1.2
            },
            {
                name: "Canary",
                color: "yellow",
                bodyColor: "#f1c40f",
                bellyColor: "#f9e79f",
                wingColor: "#d4ac0d",
                sizeMultiplier: 0.9,
                speedMultiplier: 1.2,
                glideRatio: 0.25,
                wingFlapAmplitude: 1.3
            },
            {
                name: "Sparrow",
                color: "brown",
                bodyColor: "#9c640c",
                bellyColor: "#d0a76a",
                wingColor: "#7e5109",
                sizeMultiplier: 0.85,
                speedMultiplier: 1.15,
                glideRatio: 0.2,
                wingFlapAmplitude: 1.4
            },
            {
                name: "Finch",
                color: "green",
                bodyColor: "#229954",
                bellyColor: "#a9dfbf",
                wingColor: "#196f3d",
                sizeMultiplier: 0.8,
                speedMultiplier: 1.25,
                glideRatio: 0.15,
                wingFlapAmplitude: 1.5
            }
        ];

        // Helper function to find safe X positions away from problem areas
        function findSafeX(problemAreas) {
            let attempts = 0;
            const maxAttempts = 10;
            let x;
            
            // Try to find a position at least 80px away from any problem area
            do {
                x = 100 + Math.random() * (canvas.width - 200);
                attempts++;
            } while (
                attempts < maxAttempts && 
                problemAreas.some(area => Math.abs(x - area.x) < 80)
            );
            
            return x;
        }

        // Generate stars
        let stars = [];
        function generateStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * GROUND_HEIGHT_RATIO,
                    size: Math.random() * 2 + 1
                });
            }
        }
        generateStars();






// Create a new flower at the given position
function createFlower(x, y) {
    // Limit flower count
    if (flowers.length >= MAX_FLOWERS) {
        // Remove oldest flower
        flowers.shift();
    }
    
    // Get ground level
    const groundY = canvas.height * GROUND_HEIGHT_RATIO;
    // Allow flowers to grow anywhere in the grass area (not just at the top)
    // Calculate a position between the top of grass and halfway down the grass area
    const grassHeight = (canvas.height - groundY) * 0.5; // Use half the grass height
    y = groundY + Math.random() * grassHeight;
    
    // Pick a random color
    const color = FLOWER_COLORS[Math.floor(Math.random() * FLOWER_COLORS.length)];
    
    // Create a new flower
    flowers.push({
        x: x,
        y: y,
        color: color,
        petalCount: 5 + Math.floor(Math.random() * 4), // 5-8 petals
        size: 10 + Math.random() * 5,
        swayAngle: 0,
        swaySpeed: 0.01 + Math.random() * 0.01
    });
    
    debugLog(`New flower created at (${x}, ${y})`);
}

       




        // Draw flowers
        function drawFlowers() {
    for (const flower of flowers) {
        // Update swaying animation
        flower.swayAngle += flower.swaySpeed;
        const sway = Math.sin(flower.swayAngle) * 2;
        
        // Draw stem
        ctx.strokeStyle = mushroomMode ? 
            getMushroomColor("#2ECC71", [70, 100], [40, 70]) : 
            "#2ECC71"; // Green stem
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(flower.x, flower.y);
        ctx.lineTo(flower.x + sway, flower.y - flower.size * 2);
        ctx.stroke();
        
        // Draw center of flower
        ctx.fillStyle = mushroomMode ? 
            getMushroomColor("#F1C40F", [80, 100], [50, 70]) : 
            "#F1C40F"; // Yellow center
        ctx.beginPath();
        ctx.arc(flower.x + sway, flower.y - flower.size * 2, flower.size / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw petals
        ctx.fillStyle = mushroomMode ? 
            getMushroomColor(flower.color, [80, 100], [50, 80]) : 
            flower.color;
        
        // In mushroom mode, add extra petals for more trippy visuals
        const petalCount = mushroomMode ? flower.petalCount * 1.5 : flower.petalCount;
        
        for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 2 + (mushroomMode ? colorCycleTimer / 5000 : 0);
            const distance = flower.size * (mushroomMode ? 1 + Math.sin(colorCycleTimer / 1000 + i) * 0.2 : 1);
            
            const petalX = flower.x + sway + Math.cos(angle) * distance;
            const petalY = flower.y - flower.size * 2 + Math.sin(angle) * distance;
            
            ctx.beginPath();
            ctx.ellipse(
                petalX, 
                petalY, 
                flower.size * 0.8, 
                flower.size * 0.4, 
                angle, 
                0, Math.PI * 2
            );
            ctx.fill();
            
            // In mushroom mode, add a highlight to each petal
            if (mushroomMode) {
                ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.beginPath();
                ctx.ellipse(
                    petalX, 
                    petalY, 
                    flower.size * 0.4, 
                    flower.size * 0.2, 
                    angle, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        // In mushroom mode, add pulsing glow effect
        if (mushroomMode) {
            const glowSize = flower.size * (1.3 + Math.sin(colorCycleTimer / 500) * 0.3);
            const glowOpacity = 0.2 + Math.sin(colorCycleTimer / 700) * 0.1;
            
            ctx.fillStyle = `hsla(${(colorCycleTimer / 50) % 360}, 100%, 70%, ${glowOpacity})`;
            ctx.beginPath();
            ctx.arc(flower.x + sway, flower.y - flower.size * 2, glowSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

        function drawMagicMushroom() {
    if (!magicMushroom) return;
    
    // Update animation
    magicMushroom.pulseTimer += 0.05;
    magicMushroom.glowSize = 1 + Math.sin(magicMushroom.pulseTimer) * 0.3;
    magicMushroom.glowOpacity = 0.3 + Math.sin(magicMushroom.pulseTimer * 1.3) * 0.1;
    
    // Pulsing rainbow glow
    const gradient = ctx.createRadialGradient(
        magicMushroom.x, magicMushroom.y - magicMushroom.size * 0.3,
        0,
        magicMushroom.x, magicMushroom.y - magicMushroom.size * 0.3,
        magicMushroom.size * 2 * magicMushroom.glowSize
    );
    
    // Rainbow gradient for the glow
    const hue1 = (Date.now() / 50) % 360;
    const hue2 = (hue1 + 120) % 360;
    const hue3 = (hue1 + 240) % 360;
    
    gradient.addColorStop(0, `hsla(${hue1}, 100%, 50%, ${magicMushroom.glowOpacity})`);
    gradient.addColorStop(0.5, `hsla(${hue2}, 100%, 50%, ${magicMushroom.glowOpacity * 0.7})`);
    gradient.addColorStop(1, `hsla(${hue3}, 100%, 50%, 0)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(
        magicMushroom.x, 
        magicMushroom.y - magicMushroom.size * 0.3,
        magicMushroom.size * 2 * magicMushroom.glowSize,
        0, Math.PI * 2
    );
    ctx.fill();
    
    gradient.addColorStop(0, `rgba(255, 50, 255, ${magicMushroom.glowOpacity})`);
    gradient.addColorStop(1, 'rgba(255, 50, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(
        magicMushroom.x, 
        magicMushroom.y - magicMushroom.size * 0.3,
        magicMushroom.size * 2 * magicMushroom.glowSize,
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Draw stem
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.rect(
        magicMushroom.x - magicMushroom.size * 0.15, 
        magicMushroom.y - magicMushroom.size * 0.5, 
        magicMushroom.size * 0.3, 
        magicMushroom.size * 0.5
    );
    ctx.fill();
    
    // Draw cap
    ctx.fillStyle = '#FF00AA';
    ctx.beginPath();
    ctx.ellipse(
        magicMushroom.x, 
        magicMushroom.y - magicMushroom.size * 0.5, 
        magicMushroom.size * 0.7, 
        magicMushroom.size * 0.4, 
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Draw spots on cap
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < 5; i++) {
        const spotAngle = i / 5 * Math.PI * 2 + magicMushroom.pulseTimer;
        const spotDistance = magicMushroom.size * 0.3;
        ctx.beginPath();
        ctx.arc(
            magicMushroom.x + Math.cos(spotAngle) * spotDistance * 0.7, 
            magicMushroom.y - magicMushroom.size * 0.5 + Math.sin(spotAngle) * spotDistance * 0.4,
            magicMushroom.size * 0.08,
            0, Math.PI * 2
        );
        ctx.fill();
    }
}

        // Regular Mushroom Cluster System
        function spawnMushroomCluster(treeX, treeY) {
            // Create a small cluster of 3-5 mushrooms near tree base
            const numMushrooms = 3 + Math.floor(Math.random() * 3);
            const cluster = {
                x: treeX + (Math.random() - 0.5) * 60, // Near tree base
                y: treeY + 5, // Slightly below ground
                mushrooms: [],
                age: 0,
                maxAge: 5 * 60 * 1000 // Lasts for 5 minutes before slowly fading
            };

            for (let i = 0; i < numMushrooms; i++) {
                cluster.mushrooms.push({
                    offsetX: (Math.random() - 0.5) * 30,
                    offsetY: (Math.random() - 0.5) * 10,
                    size: 5 + Math.random() * 8,
                    capHue: 15 + Math.random() * 30, // Brown/orange caps
                    stemShade: 220 + Math.random() * 20 // Light gray stems
                });
            }

            mushroomClusters.push(cluster);
        }

        function updateMushroomClusters(deltaTime) {
            // Age clusters and remove old ones
            mushroomClusters = mushroomClusters.filter(cluster => {
                cluster.age += deltaTime;
                return cluster.age < cluster.maxAge;
            });
        }

        function drawMushroomClusters() {
            mushroomClusters.forEach(cluster => {
                // Calculate fade opacity for old clusters
                const fadeStart = cluster.maxAge * 0.7;
                const opacity = cluster.age > fadeStart
                    ? 1 - ((cluster.age - fadeStart) / (cluster.maxAge - fadeStart))
                    : 1;

                cluster.mushrooms.forEach(m => {
                    const x = cluster.x + m.offsetX;
                    const y = cluster.y + m.offsetY;

                    ctx.globalAlpha = opacity;

                    // Draw stem
                    ctx.fillStyle = `hsl(0, 0%, ${m.stemShade}%)`;
                    ctx.fillRect(
                        x - m.size * 0.15,
                        y - m.size * 0.4,
                        m.size * 0.3,
                        m.size * 0.5
                    );

                    // Draw cap
                    ctx.fillStyle = `hsl(${m.capHue}, 50%, 45%)`;
                    ctx.beginPath();
                    ctx.ellipse(
                        x,
                        y - m.size * 0.4,
                        m.size * 0.5,
                        m.size * 0.3,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();

                    // Draw spots on cap
                    ctx.fillStyle = `rgba(255, 255, 255, 0.5)`;
                    for (let i = 0; i < 3; i++) {
                        const spotAngle = i / 3 * Math.PI * 2;
                        const spotDist = m.size * 0.2;
                        ctx.beginPath();
                        ctx.arc(
                            x + Math.cos(spotAngle) * spotDist * 0.5,
                            y - m.size * 0.4 + Math.sin(spotAngle) * spotDist * 0.3,
                            m.size * 0.06,
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                });

                ctx.globalAlpha = 1;
            });
        }

        // Wind Chime Visual System
        function createWindChime(treeX, treeY, trunkHeight) {
            // Wind chime hangs from tree branch
            const windChime = {
                x: treeX + (Math.random() - 0.5) * 25, // FIXED: Reduced offset (was 40, now 25) to keep chime closer to tree
                y: treeY - trunkHeight * 0.75, // FIXED: Hang from slightly higher position (was 0.7, now 0.75) to ensure it touches tree
                swingAngle: 0,
                swingSpeed: 0.004 + Math.random() * 0.004, // Further slowed to 0.004-0.008 (80% slower than original)
                swingAmplitude: 0.04 + Math.random() * 0.04, // Further reduced to 0.04-0.08 (gentle sway)
                tubeCount: 4 + Math.floor(Math.random() * 3), // 4-6 tubes
                treeId: null, // Will be set to tree reference
                lastChimeTime: Date.now(), // Initialize to current time
                chimeInterval: 15000 + Math.random() * 30000 // Chime every 15-45 seconds (realistic timing)
            };

            return windChime;
        }

        function updateWindChimes(deltaTime) {
            windChimes.forEach(chime => {
                // FIXED: Check if tree still exists, if not, make chime fall to ground
                if (chime.treeId) {
                    const tree = trees.find(t => t.id === chime.treeId);
                    if (!tree) {
                        // Tree disappeared, make chime fall
                        if (!chime.falling) {
                            chime.falling = true;
                            chime.fallVelocity = 0;
                            // Schedule replacement in 15 days
                            if (!windChimeReplacementScheduled) {
                                windChimeLostDay = dayNightCycleCount;
                                windChimeReplacementScheduled = true;
                                debugLog(`Wind chime falling - tree disappeared! Replacement scheduled for day ${dayNightCycleCount + 15}`);
                                addDiaryEntry("The wind chimes fell when their tree disappeared. Perhaps an owl will bring another in time...", 'special');
                            } else {
                                debugLog("Wind chime falling - tree disappeared!");
                            }
                        }
                    }
                }

                // Handle falling animation
                if (chime.falling) {
                    const groundLevel = canvas.height * GROUND_HEIGHT_RATIO;
                    if (chime.y < groundLevel) {
                        chime.fallVelocity += 0.2; // Gravity
                        chime.y += chime.fallVelocity;
                        // Remove tree association while falling
                        chime.treeId = null;
                    } else {
                        // Landed on ground - play jumbled notes if not already played
                        if (!chime.hasPlayedFallSound && windChimeEnabled && audioContext) {
                            chime.hasPlayedFallSound = true;
                            // Play 4-6 random jumbled notes quickly (chaotic crash sound)
                            const notes = ['C', 'D', 'E', 'G', 'A'];
                            const numNotes = 4 + Math.floor(Math.random() * 3);
                            for (let i = 0; i < numNotes; i++) {
                                setTimeout(() => {
                                    const randomNote = notes[Math.floor(Math.random() * notes.length)];
                                    playNote(randomNote, 2);
                                }, i * (30 + Math.random() * 40)); // Chaotic timing 30-70ms apart
                            }
                        }
                        chime.y = groundLevel;
                        chime.falling = false;
                        chime.fallVelocity = 0;
                    }
                }

                // Swing animation
                chime.swingAngle += chime.swingSpeed * (deltaTime / 16);

                // Initialize collision tracking
                if (!chime.recentCollisions) {
                    chime.recentCollisions = new Set();
                }

                // FIXED: Check for creatures crossing wind chimes
                if (windChimeEnabled && audioContext) {
                    const chimeDetectionRadius = 40; // Detection radius around chime
                    const chimeNotes = ['C', 'D', 'E', 'G', 'A'];

                    // Check all creatures
                    const allCreatures = [
                        ...birds.map(b => ({entity: b, id: `bird_${b.name || Math.random()}`})),
                        ...squirrels.map(s => ({entity: s, id: `squirrel_${s.name || Math.random()}`})),
                        ...rats.map(r => ({entity: r, id: `rat_${r.name || Math.random()}`})),
                        ...owls.map(o => ({entity: o, id: `owl_${o.name || Math.random()}`}))
                    ];

                    allCreatures.forEach(({entity, id}) => {
                        const dist = Math.sqrt(
                            Math.pow(entity.x - chime.x, 2) +
                            Math.pow(entity.y - (chime.y + 30), 2)
                        );

                        if (dist < chimeDetectionRadius) {
                            // Creature is near - check if we haven't played sound recently for this entity
                            if (!chime.recentCollisions.has(id)) {
                                // Play 2-3 notes quickly as creature bumps through chimes
                                const numNotes = 2 + Math.floor(Math.random() * 2); // 2-3 notes
                                const startIdx = Math.floor(Math.random() * (chimeNotes.length - 1));

                                for (let i = 0; i < numNotes; i++) {
                                    setTimeout(() => {
                                        const noteIdx = (startIdx + i) % chimeNotes.length;
                                        playNote(chimeNotes[noteIdx], 4);
                                    }, i * 60); // Quick succession - 60ms apart
                                }

                                chime.recentCollisions.add(id);

                                // Clear this collision after 1 second
                                setTimeout(() => {
                                    chime.recentCollisions.delete(id);
                                }, 1000);

                                debugLog(`Creature triggered wind chime!`);
                            }
                        }
                    });
                }

                // NOTE: Automatic wind chiming is handled by playWindChimes() function
                // Only creature collisions trigger notes here (see above)
            });
        }

        function drawWindChimes() {
            windChimes.forEach(chime => {
                ctx.save();

                // Calculate swing offset
                const swingOffset = Math.sin(chime.swingAngle) * chime.swingAmplitude * 10;

                // Draw hanging string
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(chime.x, chime.y);
                ctx.lineTo(chime.x + swingOffset, chime.y + 30);
                ctx.stroke();

                // Draw top circle/ring
                ctx.fillStyle = 'rgba(184, 134, 11, 0.9)'; // Dark golden
                ctx.beginPath();
                ctx.arc(chime.x + swingOffset, chime.y + 30, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Draw chime tubes hanging from ring
                const tubeSpacing = 12 / chime.tubeCount;
                for (let i = 0; i < chime.tubeCount; i++) {
                    const tubeX = chime.x + swingOffset + (i - chime.tubeCount / 2) * 4;
                    const tubeY = chime.y + 35;
                    const tubeLength = 15 + i * 3; // Varied lengths
                    const tubeSway = Math.sin(chime.swingAngle + i * 0.5) * 2;

                    // Draw tube string
                    ctx.strokeStyle = 'rgba(139, 69, 19, 0.4)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(chime.x + swingOffset, chime.y + 32);
                    ctx.lineTo(tubeX + tubeSway, tubeY);
                    ctx.stroke();

                    // Draw metal tube
                    const gradient = ctx.createLinearGradient(
                        tubeX + tubeSway - 1.5,
                        tubeY,
                        tubeX + tubeSway + 1.5,
                        tubeY
                    );
                    gradient.addColorStop(0, 'rgba(192, 192, 192, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(192, 192, 192, 0.9)');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(tubeX + tubeSway - 1.5, tubeY, 3, tubeLength);

                    // Tube rim
                    ctx.fillStyle = 'rgba(169, 169, 169, 0.9)';
                    ctx.fillRect(tubeX + tubeSway - 1.5, tubeY + tubeLength, 3, 1);
                }

                // Draw center clapper (striker)
                const clapperSway = Math.sin(chime.swingAngle * 1.5) * 3;
                ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                ctx.beginPath();
                ctx.arc(chime.x + swingOffset + clapperSway, chime.y + 50, 2.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        // Food Caching System
        function createFoodCache(x, y, type, ownerId) {
            const cache = {
                x: x,
                y: y,
                type: type, // 'nut' or 'seed'
                ownerId: ownerId,
                createdTime: Date.now(),
                expiresAt: Date.now() + (3 * dayNightDuration), // 3 game days
                retrieved: false
            };
            foodCaches.push(cache);
            debugLog(`Food cache created at (${x}, ${y}) by ${ownerId}`);
            return cache;
        }

        function updateFoodCaches(deltaTime) {
            const now = Date.now();
            // Remove expired caches
            foodCaches = foodCaches.filter(cache => {
                if (cache.retrieved) return false;
                if (now > cache.expiresAt) {
                    debugLog(`Food cache at (${cache.x}, ${cache.y}) expired`);
                    return false;
                }
                return true;
            });
        }

        // Find nearest cache for an owner
        function findNearestCache(x, y, ownerId) {
            let nearest = null;
            let nearestDist = Infinity;

            for (const cache of foodCaches) {
                if (cache.retrieved) continue;
                if (cache.ownerId !== ownerId) continue;

                const dist = distance(x, y, cache.x, cache.y);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = cache;
                }
            }

            return nearest;
        }

        // Check if an entity (squirrel/crow) should cache food
        function shouldCacheFood(entity, entityType) {
            // Only cache if entity has recently collected food and is in a safe spot
            if (entityType === 'squirrel') {
                // Squirrels cache when they have a nut and are on the ground
                return entity.nutCollected && entity.y >= canvas.height * GROUND_HEIGHT_RATIO - 20;
            } else if (entityType === 'crow') {
                // Crows cache when they have food and are on the ground
                return entity.hasFood && entity.isOnGround;
            }
            return false;
        }

        // Firefly System - Enhanced to prefer tall grass areas
        function spawnFireflies() {
            // Only spawn at night
            if (timeOfDay < 1) return;

            // Spawn 3-8 fireflies
            const count = 3 + Math.floor(Math.random() * 6);
            for (let i = 0; i < count; i++) {
                let x, y;

                // 70% chance to spawn near tall grass if it exists
                if (tallGrassPatches.length > 0 && Math.random() < 0.7) {
                    const grassPatch = tallGrassPatches[Math.floor(Math.random() * tallGrassPatches.length)];
                    // Spawn near the grass patch (within 100px)
                    x = grassPatch.x + (Math.random() - 0.5) * (grassPatch.width + 100);
                    // Lower height, near grass (just above ground)
                    y = grassPatch.y - 30 - Math.random() * 60; // 30-90px above ground
                } else {
                    // Random position across scene
                    x = Math.random() * canvas.width;
                    y = canvas.height * 0.3 + Math.random() * (canvas.height * 0.4);
                }

                fireflies.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.3,
                    glowPhase: Math.random() * Math.PI * 2,
                    glowSpeed: 0.02 + Math.random() * 0.02,
                    glowIntensity: 0,
                    caught: false,
                    size: 2 + Math.random(),
                    // NEW: Attraction to tall grass
                    preferredGrassPatch: tallGrassPatches.length > 0 ?
                        tallGrassPatches[Math.floor(Math.random() * tallGrassPatches.length)] : null
                });
            }
            debugLog(`Spawned ${count} fireflies for the night`);
        }

        function updateFireflies(deltaTime) {
            // Remove caught fireflies
            fireflies = fireflies.filter(f => !f.caught);

            // Spawn fireflies at night if this is a firefly night and there are few
            if (timeOfDay >= 1 && fireflyNightActive && fireflies.length < 3 && Math.random() < 0.01) {
                spawnFireflies();
            }

            // Remove all fireflies at dawn and reset flag
            if (timeOfDay < 1 && fireflies.length > 0) {
                fireflies = [];
                fireflyNightActive = false;
            }

            fireflies.forEach(firefly => {
                // Gentle attraction to tall grass patches
                if (firefly.preferredGrassPatch) {
                    const grassX = firefly.preferredGrassPatch.x;
                    const grassY = firefly.preferredGrassPatch.y - 50; // Hover above grass
                    const distToGrass = distance(firefly.x, firefly.y, grassX, grassY);

                    // Gentle pull toward grass if too far (subtle, not forced)
                    if (distToGrass > 80 && Math.random() < 0.05) {
                        const dx = grassX - firefly.x;
                        const dy = grassY - firefly.y;
                        firefly.vx += (dx / distToGrass) * 0.05;
                        firefly.vy += (dy / distToGrass) * 0.05;

                        // Cap velocity
                        const speed = Math.sqrt(firefly.vx * firefly.vx + firefly.vy * firefly.vy);
                        if (speed > 0.6) {
                            firefly.vx = (firefly.vx / speed) * 0.6;
                            firefly.vy = (firefly.vy / speed) * 0.6;
                        }
                    }
                }

                // Update position with gentle wandering
                firefly.x += firefly.vx;
                firefly.y += firefly.vy;

                // Random direction changes
                if (Math.random() < 0.02) {
                    firefly.vx = (Math.random() - 0.5) * 0.5;
                    firefly.vy = (Math.random() - 0.5) * 0.3;
                }

                // Keep within bounds
                if (firefly.x < 50) firefly.vx = Math.abs(firefly.vx);
                if (firefly.x > canvas.width - 50) firefly.vx = -Math.abs(firefly.vx);
                if (firefly.y < canvas.height * 0.2) firefly.vy = Math.abs(firefly.vy);
                if (firefly.y > canvas.height * GROUND_HEIGHT_RATIO) firefly.vy = -Math.abs(firefly.vy);

                // Update glow phase
                firefly.glowPhase += firefly.glowSpeed * (deltaTime / 16);
                firefly.glowIntensity = (Math.sin(firefly.glowPhase) + 1) / 2; // 0 to 1

                // Check if any bird is hunting this firefly
                for (const bird of birds) {
                    if (bird.state === BIRD_STATES.HUNTING) {
                        const dist = distance(bird.x, bird.y, firefly.x, firefly.y);
                        if (dist < 15) {
                            // Bird caught the firefly!
                            firefly.caught = true;
                            bird.hunger = Math.max(0, bird.hunger - 50);
                            debugLog(`Bird caught a firefly!`);
                            break;
                        }
                    }
                }
            });
        }

        function drawFireflies() {
            fireflies.forEach(firefly => {
                // Validate firefly position and properties (fix NaN crash)
                if (!isFinite(firefly.x) || !isFinite(firefly.y) ||
                    !isFinite(firefly.size) || !isFinite(firefly.glowIntensity)) {
                    debugLog("Invalid firefly detected, skipping draw", DEBUG_LEVELS.WARNING);
                    return;
                }

                ctx.save();

                // Draw glow effect (same as UFO will use)
                const glowRadius = firefly.size * 3 * firefly.glowIntensity;

                // Additional safety check for glowRadius
                if (!isFinite(glowRadius) || glowRadius <= 0) {
                    ctx.restore();
                    return;
                }

                const gradient = ctx.createRadialGradient(
                    firefly.x, firefly.y, 0,
                    firefly.x, firefly.y, glowRadius
                );

                const glowColor = `rgba(255, 255, 100, ${firefly.glowIntensity * 0.6})`;
                gradient.addColorStop(0, glowColor);
                gradient.addColorStop(0.5, `rgba(255, 255, 100, ${firefly.glowIntensity * 0.3})`);
                gradient.addColorStop(1, 'rgba(255, 255, 100, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(firefly.x, firefly.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                // Draw firefly body
                ctx.fillStyle = `rgba(200, 200, 50, ${0.7 + firefly.glowIntensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(firefly.x, firefly.y, firefly.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        // UFO Encounter System
        function attemptUFOSpawn() {
            // Only spawn at night
            if (timeOfDay < 1) return;

            // Check if UFO already exists or on cooldown
            if (ufo || Date.now() < ufoEncounterCooldown) return;

            // SUPER RARE spawn chance (0.0002% = once every 2-3 hours at 60fps)
            if (Math.random() > 0.000002) return;

            // Find potential targets
            const potentialTargets = [];

            // Check for birdhouses
            birdhouses.forEach(house => {
                if (house.isComplete) {
                    potentialTargets.push({type: 'birdhouse', entity: house});
                }
            });

            // Check for scarecrow
            if (scarecrow) {
                potentialTargets.push({type: 'scarecrow', entity: scarecrow});
            }

            // Check for ants (need at least 3)
            if (ants.length >= 3) {
                potentialTargets.push({type: 'ant', entity: null}); // Will select random ant later
            }

            // Need at least one target
            if (potentialTargets.length === 0) return;

            // Select random target
            const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];

            // If target is ant, select a random ant
            if (target.type === 'ant') {
                target.entity = ants[Math.floor(Math.random() * ants.length)];
            }

            // Create UFO
            ufo = {
                x: Math.random() * canvas.width,
                y: -100, // Start above screen
                vx: 0,
                vy: 1.5, // Descend speed
                state: 'approaching', // approaching, beaming, leaving
                target: target,
                beamProgress: 0,
                beamWidth: 0,
                rotation: 0,
                glowPhase: 0,
                hoverOffset: 0
            };

            debugLog(`UFO encounter! Target: ${target.type}`);
        }

        function updateUFO(deltaTime) {
            if (!ufo) return;

            const dt = deltaTime / 16;

            // Update animation
            ufo.glowPhase += 0.05 * dt;
            ufo.rotation += 0.02 * dt;
            ufo.hoverOffset = Math.sin(ufo.glowPhase) * 5;

            switch(ufo.state) {
                case 'approaching':
                    // Move down to hover position
                    ufo.y += ufo.vy * dt;

                    // Get target position
                    let targetX = ufo.target.entity.x;
                    let targetY = 200; // Hover height

                    // Move toward target X
                    const dx = targetX - ufo.x;
                    ufo.x += Math.sign(dx) * Math.min(Math.abs(dx), 2 * dt);

                    // Once in position, start beaming
                    if (Math.abs(dx) < 20 && ufo.y >= targetY) {
                        ufo.state = 'beaming';
                        ufo.y = targetY;
                        ufo.beamProgress = 0;
                        debugLog(`UFO beaming up ${ufo.target.type}`);
                    }
                    break;

                case 'beaming':
                    // Expand beam
                    ufo.beamProgress += 0.015 * dt;
                    ufo.beamWidth = Math.min(80, ufo.beamProgress * 100);

                    // When beam complete, beam up target
                    if (ufo.beamProgress >= 1) {
                        beamUpTarget();
                        ufo.state = 'leaving';
                    }
                    break;

                case 'leaving':
                    // Ascend and leave
                    ufo.y -= 2 * dt;
                    ufo.beamWidth = Math.max(0, ufo.beamWidth - 3 * dt);

                    // Remove UFO when off screen
                    if (ufo.y < -150) {
                        ufo = null;
                        ufoEncounterCooldown = Date.now() + UFO_COOLDOWN_DURATION;
                    }
                    break;
            }
        }

        function beamUpTarget() {
            if (!ufo || !ufo.target) return;

            const target = ufo.target;
            const returnTime = Date.now() + 10000 + Math.random() * 10000; // Return in 10-20 seconds

            switch(target.type) {
                case 'birdhouse':
                    // Store birdhouse info for return
                    beamedUpEntities.push({
                        type: 'birdhouse',
                        entity: target.entity,
                        returnTime: returnTime,
                        originalX: target.entity.x,
                        originalY: target.entity.y
                    });
                    // Hide birdhouse temporarily
                    target.entity.beamedUp = true;
                    debugLog('Birdhouse beamed up by UFO!');
                    break;

                case 'scarecrow':
                    beamedUpEntities.push({
                        type: 'scarecrow',
                        entity: target.entity,
                        returnTime: returnTime,
                        originalX: target.entity.x,
                        originalY: target.entity.y
                    });
                    target.entity.beamedUp = true;
                    debugLog('Scarecrow beamed up by UFO!');
                    break;

                case 'ant':
                    // Make ant giant and glowing
                    target.entity.isGiant = true;
                    target.entity.giantUntil = Date.now() + (3 * dayNightDuration); // Giant for 3 days
                    target.entity.glowing = true; // Permanently glowing
                    target.entity.glowPhase = Math.random() * Math.PI * 2;
                    target.entity.size = 12; // FIXED: 3x bigger (normal is ~4 units)
                    debugLog('Ant transformed into GIANT glowing ant by UFO!');
                    break;
            }
        }

        function updateBeamedEntities() {
            const now = Date.now();

            for (let i = beamedUpEntities.length - 1; i >= 0; i--) {
                const beamed = beamedUpEntities[i];

                // Check if it's time to return
                if (now >= beamed.returnTime) {
                    // Return entity with green glow
                    beamed.entity.beamedUp = false;
                    beamed.entity.glowing = true;
                    beamed.entity.glowPhase = Math.random() * Math.PI * 2;

                    debugLog(`${beamed.type} returned by UFO with green glow!`);

                    // Remove from beamed list
                    beamedUpEntities.splice(i, 1);
                }
            }
        }

        function drawUFO() {
            if (!ufo) return;

            ctx.save();
            ctx.translate(ufo.x, ufo.y + ufo.hoverOffset);
            ctx.rotate(ufo.rotation);

            // Draw beam if beaming
            if (ufo.state === 'beaming' || (ufo.state === 'leaving' && ufo.beamWidth > 0)) {
                ctx.save();
                ctx.rotate(-ufo.rotation); // Counter-rotate beam

                // Beam gradient
                const beamGradient = ctx.createLinearGradient(0, 0, 0, 400);

                if (mushroomMode) {
                    // Psychedelic rainbow beam
                    const hue = (Date.now() / 30) % 360;
                    beamGradient.addColorStop(0, `hsla(${hue}, 100%, 60%, ${0.4 * ufo.beamProgress})`);
                    beamGradient.addColorStop(0.3, `hsla(${(hue + 120) % 360}, 100%, 50%, ${0.3 * ufo.beamProgress})`);
                    beamGradient.addColorStop(0.7, `hsla(${(hue + 240) % 360}, 100%, 50%, ${0.2 * ufo.beamProgress})`);
                    beamGradient.addColorStop(1, `hsla(${hue}, 100%, 60%, ${0.1 * ufo.beamProgress})`);
                } else {
                    beamGradient.addColorStop(0, `rgba(150, 255, 150, ${0.3 * ufo.beamProgress})`);
                    beamGradient.addColorStop(0.5, `rgba(100, 255, 100, ${0.2 * ufo.beamProgress})`);
                    beamGradient.addColorStop(1, `rgba(150, 255, 150, ${0.1 * ufo.beamProgress})`);
                }

                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.moveTo(-ufo.beamWidth / 2, 0);
                ctx.lineTo(-ufo.beamWidth * 1.5, 400);
                ctx.lineTo(ufo.beamWidth * 1.5, 400);
                ctx.lineTo(ufo.beamWidth / 2, 0);
                ctx.closePath();
                ctx.fill();

                // Beam particles
                for (let i = 0; i < 10; i++) {
                    const particleY = (Date.now() / 20 + i * 40) % 400;
                    const particleX = (Math.sin(Date.now() / 200 + i) * ufo.beamWidth);

                    if (mushroomMode) {
                        const particleHue = (Date.now() / 10 + i * 36) % 360;
                        ctx.fillStyle = `hsla(${particleHue}, 100%, 60%, ${0.7 * ufo.beamProgress})`;
                    } else {
                        ctx.fillStyle = `rgba(200, 255, 200, ${0.6 * ufo.beamProgress})`;
                    }

                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // UFO body - classic flying saucer
            const glowIntensity = (Math.sin(ufo.glowPhase) + 1) / 2;

            // Outer glow
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
            glowGradient.addColorStop(0, `rgba(100, 200, 255, ${0.3 * glowIntensity})`);
            glowGradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.fill();

            // Top dome
            ctx.fillStyle = 'rgba(150, 180, 200, 0.8)';
            ctx.beginPath();
            ctx.ellipse(0, -5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Dome highlight
            ctx.fillStyle = 'rgba(200, 220, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-3, -8, 5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main saucer body
            ctx.fillStyle = 'rgba(180, 180, 200, 0.9)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 35, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Saucer rim
            ctx.fillStyle = 'rgba(120, 120, 150, 0.9)';
            ctx.beginPath();
            ctx.ellipse(0, 3, 35, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lights around rim
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + ufo.glowPhase;
                const lightX = Math.cos(angle) * 30;
                const lightY = Math.sin(angle) * 8 + 3;

                const lightColor = (i + Math.floor(ufo.glowPhase * 2)) % 3;
                let color;
                if (lightColor === 0) color = 'rgba(255, 100, 100, 0.9)';
                else if (lightColor === 1) color = 'rgba(100, 255, 100, 0.9)';
                else color = 'rgba(100, 100, 255, 0.9)';

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(lightX, lightY, 3, 0, Math.PI * 2);
                ctx.fill();

                // Light glow
                const lightGlow = ctx.createRadialGradient(lightX, lightY, 0, lightX, lightY, 8);
                lightGlow.addColorStop(0, color.replace('0.9', '0.4'));
                lightGlow.addColorStop(1, color.replace('0.9', '0'));
                ctx.fillStyle = lightGlow;
                ctx.beginPath();
                ctx.arc(lightX, lightY, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Special Events System

        // Meteor Shower Event
        function attemptMeteorShower() {
            // Only spawn at night
            if (timeOfDay < 1) return;

            // Check if already active or on cooldown
            if (meteorShower || Date.now() < specialEventCooldown) return;

            // RARE spawn chance (0.001% = once every 30-40 mins at 60fps)
            if (Math.random() > 0.00001) return;

            // Start meteor shower
            meteorShower = {
                active: true,
                meteors: [],
                duration: 30000, // 30 seconds
                elapsed: 0,
                nextMeteorTime: 0
            };

            // Alarm reaction from all birds
            birds.forEach(bird => {
                if (bird.state !== 'fleeing' && bird.state !== 'hiding') {
                    bird.state = 'alarmed';
                    bird.stateTimer = 5000 + Math.random() * 5000;
                }
            });

            debugLog('Meteor shower begins! Birds alarmed.');
        }

        function updateMeteorShower(deltaTime) {
            if (!meteorShower) return;

            meteorShower.elapsed += deltaTime;

            // Spawn new meteors periodically
            meteorShower.nextMeteorTime -= deltaTime;
            if (meteorShower.nextMeteorTime <= 0) {
                // FIXED: Spawn 1-2 meteors (more like shooting stars)
                const count = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < count; i++) {
                    const startX = Math.random() * canvas.width * 1.5 - canvas.width * 0.25;
                    meteorShower.meteors.push({
                        x: startX,
                        y: -50,
                        vx: (Math.random() - 0.3) * 3,
                        vy: 5 + Math.random() * 3,
                        size: 2 + Math.random() * 3,
                        trail: [],
                        life: 1.0
                    });
                }
                meteorShower.nextMeteorTime = 500 + Math.random() * 1500;
            }

            // Update meteors
            for (let i = meteorShower.meteors.length - 1; i >= 0; i--) {
                const meteor = meteorShower.meteors[i];

                // Add trail point
                meteor.trail.push({x: meteor.x, y: meteor.y});
                if (meteor.trail.length > 10) meteor.trail.shift();

                // Move meteor
                meteor.x += meteor.vx * (deltaTime / 16);
                meteor.y += meteor.vy * (deltaTime / 16);
                meteor.life -= 0.01 * (deltaTime / 16);

                // Remove if off screen or faded
                if (meteor.y > canvas.height || meteor.life <= 0) {
                    meteorShower.meteors.splice(i, 1);
                }
            }

            // End event after duration
            if (meteorShower.elapsed >= meteorShower.duration) {
                meteorShower = null;
                specialEventCooldown = Date.now() + EVENT_COOLDOWN_DURATION;
                debugLog('Meteor shower ended');
            }
        }

        function drawMeteorShower() {
            if (!meteorShower) return;

            ctx.save();
            meteorShower.meteors.forEach((meteor, meteorIndex) => {
                // Draw trail
                for (let i = 0; i < meteor.trail.length; i++) {
                    const point = meteor.trail[i];
                    const trailAlpha = (i / meteor.trail.length) * meteor.life * 0.5;

                    const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, meteor.size * 2);

                    if (mushroomMode) {
                        // Psychedelic rainbow trail
                        const hue = (Date.now() / 10 + meteorIndex * 60 + i * 30) % 360;
                        gradient.addColorStop(0, `hsla(${hue}, 100%, 60%, ${trailAlpha})`);
                        gradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 100%, 50%, ${trailAlpha * 0.7})`);
                        gradient.addColorStop(1, `hsla(${(hue + 120) % 360}, 100%, 40%, 0)`);
                    } else {
                        gradient.addColorStop(0, `rgba(255, 200, 100, ${trailAlpha})`);
                        gradient.addColorStop(1, 'rgba(255, 150, 50, 0)');
                    }

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, meteor.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw meteor core
                const coreGradient = ctx.createRadialGradient(
                    meteor.x, meteor.y, 0,
                    meteor.x, meteor.y, meteor.size * 3
                );

                if (mushroomMode) {
                    // Psychedelic pulsing core
                    const hue = (Date.now() / 5 + meteorIndex * 90) % 360;
                    coreGradient.addColorStop(0, `hsla(${hue}, 100%, 80%, ${meteor.life})`);
                    coreGradient.addColorStop(0.4, `hsla(${(hue + 120) % 360}, 100%, 60%, ${meteor.life * 0.8})`);
                    coreGradient.addColorStop(1, `hsla(${(hue + 240) % 360}, 100%, 40%, 0)`);
                } else {
                    coreGradient.addColorStop(0, `rgba(255, 255, 255, ${meteor.life})`);
                    coreGradient.addColorStop(0.4, `rgba(255, 200, 100, ${meteor.life * 0.8})`);
                    coreGradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
                }

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(meteor.x, meteor.y, meteor.size * 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }

        // Eclipse Event
        function attemptEclipse() {
            // Only during day
            if (timeOfDay >= 1) return;

            // Check if already active or on cooldown
            if (eclipse || Date.now() < specialEventCooldown) return;

            // SUPER RARE spawn chance (0.0002% = once every 2-3 hours at 60fps)
            if (Math.random() > 0.000002) return;

            // Start eclipse
            eclipse = {
                active: true,
                phase: 0, // 0 = approaching, 1 = totality, 2 = ending
                elapsed: 0,
                totalDuration: 60000, // 1 minute total
                darkness: 0
            };

            debugLog('Eclipse begins! The sky darkens...');
        }

        function updateEclipse(deltaTime) {
            if (!eclipse) return;

            eclipse.elapsed += deltaTime;
            const progress = eclipse.elapsed / eclipse.totalDuration;

            // Update phase
            if (progress < 0.3) {
                eclipse.phase = 0; // Approaching
                eclipse.darkness = progress / 0.3; // Darken gradually
            } else if (progress < 0.7) {
                eclipse.phase = 1; // Totality
                eclipse.darkness = 1.0;

                // Confuse birds during totality
                if (Math.random() < 0.02) {
                    const randomBird = birds[Math.floor(Math.random() * birds.length)];
                    if (randomBird && randomBird.state !== 'confused') {
                        randomBird.state = 'confused';
                        randomBird.stateTimer = 3000;
                    }
                }
            } else {
                eclipse.phase = 2; // Ending
                eclipse.darkness = 1.0 - ((progress - 0.7) / 0.3); // Lighten gradually
            }

            // End event
            if (progress >= 1.0) {
                eclipse = null;
                specialEventCooldown = Date.now() + EVENT_COOLDOWN_DURATION;
                debugLog('Eclipse ended');
            }
        }

        function drawEclipse() {
            if (!eclipse) return;

            // Draw darkening overlay
            ctx.save();

            if (mushroomMode) {
                // Psychedelic darkening with color shifts
                const hue = (Date.now() / 50) % 360;
                ctx.fillStyle = `hsla(${hue}, 70%, 20%, ${eclipse.darkness * 0.5})`;
            } else {
                ctx.fillStyle = `rgba(0, 0, 20, ${eclipse.darkness * 0.6})`;
            }
            // FIXED: Extended darkness area to account for camera movement
            ctx.fillRect(-canvas.width, -canvas.height, canvas.width * 3, canvas.height * 3);

            // Draw eclipse if in totality
            if (eclipse.phase === 1) {
                const eclipseX = canvas.width / 2;
                const eclipseY = canvas.height * 0.3;

                if (mushroomMode) {
                    // Psychedelic multi-layered corona
                    for (let layer = 0; layer < 3; layer++) {
                        const coronaGradient = ctx.createRadialGradient(
                            eclipseX, eclipseY, 20 + layer * 15,
                            eclipseX, eclipseY, 60 + layer * 20
                        );
                        const hue = (Date.now() / 20 + layer * 120) % 360;
                        coronaGradient.addColorStop(0, `hsla(${hue}, 100%, 60%, 0)`);
                        coronaGradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 100%, 50%, 0.4)`);
                        coronaGradient.addColorStop(1, `hsla(${(hue + 120) % 360}, 100%, 40%, 0)`);
                        ctx.fillStyle = coronaGradient;
                        ctx.beginPath();
                        ctx.arc(eclipseX, eclipseY, 60 + layer * 20, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Pulsing dark moon with color edges
                    const pulse = Math.sin(Date.now() / 200) * 3;
                    const moonGradient = ctx.createRadialGradient(
                        eclipseX, eclipseY, 0,
                        eclipseX, eclipseY, 25 + pulse
                    );
                    const moonHue = (Date.now() / 30) % 360;
                    moonGradient.addColorStop(0, 'rgba(0, 0, 0, 0.95)');
                    moonGradient.addColorStop(0.85, 'rgba(0, 0, 0, 0.9)');
                    moonGradient.addColorStop(1, `hsla(${moonHue}, 100%, 50%, 0.5)`);
                    ctx.fillStyle = moonGradient;
                    ctx.beginPath();
                    ctx.arc(eclipseX, eclipseY, 25 + pulse, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Normal eclipse
                    const coronaGradient = ctx.createRadialGradient(
                        eclipseX, eclipseY, 20,
                        eclipseX, eclipseY, 60
                    );
                    coronaGradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
                    coronaGradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.3)');
                    coronaGradient.addColorStop(1, 'rgba(255, 200, 150, 0)');
                    ctx.fillStyle = coronaGradient;
                    ctx.beginPath();
                    ctx.arc(eclipseX, eclipseY, 60, 0, Math.PI * 2);
                    ctx.fill();

                    // Dark moon
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.beginPath();
                    ctx.arc(eclipseX, eclipseY, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // Migration Wave Event
        function attemptMigrationWave() {
            // Check if already active or on cooldown
            if (migrationWave || Date.now() < specialEventCooldown) return;

            // FIXED: Made MUCH rarer (0.01% = once every ~15-30 mins at 60fps)
            if (Math.random() > 0.0001) return;

            // Start migration wave
            const birdCount = 10 + Math.floor(Math.random() * 6); // 10-15 birds
            migrationWave = {
                active: true,
                birds: [],
                duration: 20000, // 20 seconds to pass through
                elapsed: 0,
                formation: Math.random() < 0.5 ? 'V' : 'line' // V formation or straight line
            };

            // Create migration birds
            const startY = canvas.height * 0.2 + Math.random() * (canvas.height * 0.3);
            const direction = Math.random() < 0.5 ? 1 : -1; // Left to right or right to left
            const startX = direction > 0 ? -50 : canvas.width + 50;

            for (let i = 0; i < birdCount; i++) {
                let offsetX = 0, offsetY = 0;

                if (migrationWave.formation === 'V') {
                    // V formation
                    const side = i % 2 === 0 ? 1 : -1;
                    const row = Math.floor(i / 2);
                    offsetX = row * 30 * direction;
                    offsetY = row * 20 * Math.abs(side);
                } else {
                    // Line formation
                    offsetX = i * 40 * direction;
                    offsetY = Math.sin(i * 0.5) * 15;
                }

                migrationWave.birds.push({
                    x: startX + offsetX,
                    y: startY + offsetY,
                    targetX: (direction > 0 ? canvas.width + 50 : -50) + offsetX,
                    targetY: startY + offsetY,
                    speed: 2 + Math.random() * 0.5,
                    wingFlap: 0, // FIXED: Start all birds with synchronized wing flaps
                    size: 0.8 + Math.random() * 0.4
                });
            }

            debugLog(`Migration wave! ${birdCount} birds in ${migrationWave.formation} formation`);
        }

        function updateMigrationWave(deltaTime) {
            if (!migrationWave) return;

            migrationWave.elapsed += deltaTime;
            const dt = deltaTime / 16;

            // Update migration birds
            for (let i = migrationWave.birds.length - 1; i >= 0; i--) {
                const bird = migrationWave.birds[i];

                // Move toward target
                const dx = bird.targetX - bird.x;
                const dy = bird.targetY - bird.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    bird.x += (dx / dist) * bird.speed * dt;
                    bird.y += (dy / dist) * bird.speed * dt;
                }

                // Update wing flap
                bird.wingFlap += 0.15 * dt;

                // Remove if reached target
                if (dist <= 5) {
                    migrationWave.birds.splice(i, 1);
                }
            }

            // End event when all birds have passed
            if (migrationWave.birds.length === 0 || migrationWave.elapsed >= migrationWave.duration + 10000) {
                migrationWave = null;
                specialEventCooldown = Date.now() + EVENT_COOLDOWN_DURATION;
                debugLog('Migration wave ended');
            }
        }

        function drawMigrationWave() {
            if (!migrationWave) return;

            ctx.save();
            migrationWave.birds.forEach((bird, index) => {
                ctx.save();
                ctx.translate(bird.x, bird.y);

                const direction = bird.targetX > bird.x ? 1 : -1;
                ctx.scale(direction, 1);
                ctx.scale(bird.size, bird.size);

                // FIXED: Depth perception - only front birds show both wings
                const isInFront = index < migrationWave.birds.length * 0.3; // Front 30% show both wings
                const wingAngle = Math.sin(bird.wingFlap) * 0.5;

                // Draw back wing first (only for front birds)
                if (isInFront) {
                    ctx.fillStyle = mushroomMode ? getMushroomColor('#A0826D') : '#A0826D';
                    ctx.save();
                    ctx.rotate(-wingAngle);
                    ctx.beginPath();
                    ctx.ellipse(-5, 3, 8, 3, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Bird body
                ctx.fillStyle = mushroomMode ? getMushroomColor('#8B7355') : '#8B7355';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // FIXED: Add eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(3, -1, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(3.3, -1, 0.7, 0, Math.PI * 2);
                ctx.fill();

                // FIXED: Add beak
                ctx.fillStyle = mushroomMode ? getMushroomColor('#FFA500') : '#FFA500';
                ctx.beginPath();
                ctx.moveTo(7, 0);
                ctx.lineTo(10, -1);
                ctx.lineTo(10, 1);
                ctx.closePath();
                ctx.fill();

                // Front wing (always visible)
                ctx.fillStyle = mushroomMode ? getMushroomColor('#A0826D') : '#A0826D';
                ctx.save();
                ctx.rotate(wingAngle);
                ctx.beginPath();
                ctx.ellipse(-5, -3, 8, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            });
            ctx.restore();
        }

        // Rain system
        let raindrops = [];

        function scheduleRain() {
          // Rain occurs more frequently for lively ecosystem
            const nextRainDelay = 300000 + Math.random() * 240000; // 5-9 minutes between rains

            // Store next rain time for accurate forecast
            window.nextScheduledRainTime = Date.now() + nextRainDelay;
            window.nextRainWillThunder = Math.random() < LIGHTNING_CHANCE;

            const rainTimer = setTimeout(() => {
                if (Math.random() < RAIN_PROBABILITY) {
                    // Add cloud buildup before rain starts
                    cloudCover = 0;
                    const cloudBuildupDuration = 15000; // 15 seconds
                    
                    const buildupInterval = setInterval(() => {
                        cloudCover += 0.1;
                        if (cloudCover >= 1) {
                            clearInterval(buildupInterval);
                            isRaining = true;
                            isThundering = Math.random() < LIGHTNING_CHANCE;
                            wasRaining = false; // Reset this flag
                            debugLog(`${isThundering ? "Thunderstorm" : "Rain"} started`);

                            // Add diary entry for weather
                            if (isThundering) {
                                addDiaryEntry("A thunderstorm rolls in! Lightning crackles across the sky.", 'weather');
                            }
                            
                            const rainDuration = 45000 + Math.random() * 30000; // 45-75 seconds
                            const rainStopTimer = setTimeout(() => {
                                isRaining = false;
isThundering = false;
wasRaining = true; // Set flag when rain just stopped

// Increment rain counter
rainsCompleted++;
debugLog(`Rain event completed. Total rains: ${rainsCompleted}`);

// FIX: VERY RARE pond generation when it rains too much
// Only 10% chance after 8+ rains, and only if no pond exists yet
if (rainsCompleted >= 8 && ponds.length === 0 && Math.random() < 0.10) {
    const pondX = 100 + Math.random() * (canvas.width - 200);
    const pondWidth = 100 + Math.random() * 60;
    const pondHeight = 50 + Math.random() * 30;
    const pondY = canvas.height * GROUND_HEIGHT_RATIO;

    ponds.push({
        x: pondX,
        y: pondY,
        width: pondWidth,
        height: pondHeight,
        rippleTimer: 0,
        ripples: []
    });

    debugLog(`RARE: Natural pond formed after ${rainsCompleted} rains from heavy rainfall at (${pondX}, ${pondY})`);

    // Add diary entry for pond milestone
    addDiaryEntry("The heavy rains have created a pond! Koi and frogs move in.", 'milestone');

    // Spawn a couple of koi in the pond
    // Traditional koi colors for variety
    const koiColors = [
        '#FF6B35', // Orange-red (Kohaku)
        '#FFD700', // Gold (Yamabuki Ogon)
        '#FF4500', // Deep orange
        '#FFA500', // Bright orange
        '#DC143C', // Crimson red
        '#FF8C00', // Dark orange
        '#8B4513', // Brown (Chagoi)
        '#708090'  // Slate grey (Asagi)
    ];

    koi.push({
        id: Math.random().toString(36).substring(2, 11), // Unique ID for naming
        x: pondX,
        y: pondY,
        pondIndex: 0,
        swimAngle: Math.random() * Math.PI * 2,
        color: koiColors[Math.floor(Math.random() * koiColors.length)]
    });
    koi.push({
        id: Math.random().toString(36).substring(2, 11), // Unique ID for naming
        x: pondX,
        y: pondY,
        pondIndex: 0,
        swimAngle: Math.random() * Math.PI * 2,
        color: koiColors[Math.floor(Math.random() * koiColors.length)]
    });

    // Spawn a frog near the pond
    frogs.push({
        id: Math.random().toString(36).substr(2, 9), // Unique ID for naming
        x: pondX + (Math.random() - 0.5) * 60,
        y: canvas.height * GROUND_HEIGHT_RATIO,
        jumpTimer: 0,
        tongueOut: false
    });

    debugLog(`Pond ecosystem spawned: 2 koi and 1 frog`);
}

// Only create puddles if tab is visible
if (isTabVisible) {
    createPuddles(); // Create puddles when rain stops
} else {
    debugLog("Tab not visible, skipping puddle creation");
}

// Spawn mushroom clusters near trees after rain (damp conditions)
// FIXED: Made much more rare (15% chance instead of 40%)
if (trees.length > 0 && Math.random() < 0.15) {
    const numClusters = 1 + Math.floor(Math.random() * 3); // 1-3 clusters
    for (let i = 0; i < numClusters; i++) {
        const tree = trees[Math.floor(Math.random() * trees.length)];
        spawnMushroomCluster(tree.x, tree.y);
    }
    debugLog(`Spawned ${numClusters} mushroom cluster(s) near trees`);
}



                                // Keep wasRaining true for longer (1 minute)
                                const rainMemoryTimer = setTimeout(() => {
                                    wasRaining = false;
                                    debugLog("Birds no longer remember it rained recently");
                                }, 60000);
                                addTimer(rainMemoryTimer);
                                
                                // Store interval ID in a variable first, then pass to clearInterval
                                const clearIntervalId = setInterval(() => {
                                    cloudCover -= 0.1;
                                    if (cloudCover <= 0) {
                                        cloudCover = 0;
                                        clearInterval(clearIntervalId); // Use the local reference
                                        scheduleRain();
                                    }
                                }, 5000);
                                addTimer(clearIntervalId, true); // Mark as interval
                            }, rainDuration);
                            addTimer(rainStopTimer);
                            
                            // If thundering, schedule lightning strikes
                            if (isThundering) {
                                scheduleLightning(rainDuration);
                            }
                        }
                    }, cloudBuildupDuration / 10);
                    addTimer(buildupInterval, true); // Mark as interval
                } else {
                    // Skip this rain event
                    scheduleRain();
                }
            }, nextRainDelay);
            addTimer(rainTimer);
        }
        
        // Lightning system
        function scheduleLightning(duration) {
            // Schedule 1-3 lightning strikes during thunderstorm
            const strikeCount = Math.floor(1 + Math.random() * 2);
            
            for (let i = 0; i < strikeCount; i++) {
                const strikeDelay = Math.random() * duration;
                const lightningTimer = setTimeout(() => {
                    createLightningStrike();
                }, strikeDelay);
                addTimer(lightningTimer);
            }
        }
        
        function createLightningStrike() {
            // Choose a random position for lightning
            const strikeX = Math.random() * canvas.width;
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            
            // Create lightning visual effect
            const newLightning = {
                x: strikeX,
                y: 0,  // Start from top of screen
                groundY: groundY,
                width: 2 + Math.random() * 2,
                segments: [],
                opacity: 1.0,
                timer: 0
            };
            
            // Generate lightning path segments
            let currentY = 0;
            const segmentCount = Math.floor(10 + Math.random() * 5);
            
            for (let i = 0; i < segmentCount; i++) {
                const segmentLength = groundY / segmentCount;
                const xOffset = (Math.random() - 0.5) * 30;
                
                newLightning.segments.push({
                    x1: strikeX + (i > 0 ? newLightning.segments[i-1].xOffset : 0),
                    y1: currentY,
                    x2: strikeX + (i > 0 ? newLightning.segments[i-1].xOffset : 0) + xOffset,
                    y2: currentY + segmentLength,
                    xOffset: xOffset
                });
                
                currentY += segmentLength;
            }
            
            lightningStrikes.push(newLightning);
            
            // Check if lightning hit a tree
            const hitTree = trees.find(tree => 
                Math.abs(tree.x - strikeX) < tree.trunkWidth * 2
            );
            
            if (hitTree) {
                // Damage tree
                hitTree.health -= LIGHTNING_TREE_DAMAGE;
                debugLog(`Lightning struck tree at ${hitTree.x}`);
                
                // Generate special twigs
                if (hitTree.health <= 0) {
                    createSpecialTwigsFromTree(hitTree);
                }
            }
            
            // Sound and screen flash effect
            const thunderSound = Math.random() < 0.5 ? 'üí•' : '‚ö°';
            debugLog(`${thunderSound} Lightning strike at ${strikeX}`);
        }
        
        function updateLightningStrikes(deltaTime) {
            for (let i = lightningStrikes.length - 1; i >= 0; i--) {
                const strike = lightningStrikes[i];
                strike.timer += deltaTime;
                
                // Fade out lightning
                strike.opacity = 1.0 - (strike.timer / 500);
                
                // Remove after it fades
                if (strike.opacity <= 0) {
                    lightningStrikes.splice(i, 1);
                }
            }
        }
        
        function drawLightningStrikes() {
            lightningStrikes.forEach(strike => {
                // Flash the screen with a subtle glow
                ctx.fillStyle = `rgba(200, 220, 255, ${strike.opacity * 0.15})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the lightning bolt
                ctx.strokeStyle = `rgba(220, 240, 255, ${strike.opacity})`;
                ctx.lineWidth = strike.width;
                
                strike.segments.forEach(segment => {
                    ctx.beginPath();
                    ctx.moveTo(segment.x1, segment.y1);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                    
                    // Add some glow to the lightning
                    ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
                    ctx.shadowBlur = 10;
                });
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            });
        }
        
        function createSpecialTwigsFromTree(tree) {
            // Create 4-8 special twigs from a lightning-struck tree
            const twigCount = 4 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < twigCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 60;
                
                const newTwig = {
                    x: tree.x + Math.cos(angle) * distance,
                    y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                    size: 15 + Math.random() * 10, // Larger special twigs
                    angle: Math.random() * Math.PI,
                    isSpecial: Math.random() < SPECIAL_TWIG_CHANCE,
                    offshoots: []
                };
                
                // Generate random offshoots
                for (let j = 0; j < 3; j++) {
                    newTwig.offshoots.push({
                        position: Math.random() * newTwig.size,
                        length: 2 + Math.random() * 5,
                        angle: (Math.random() - 0.5) * Math.PI
                    });
                }
                
                twigs.push(newTwig);
            }
            debugLog(`Created ${twigCount} twigs from lightning-struck tree`);
        }

        // Puddle system
        function createPuddles() {
            // Limit number of puddles for performance
            if (puddles.length >= MAX_PUDDLES) {
                // Sort puddles by size and remove the smallest ones
                puddles.sort((a, b) => a.size - b.size);
                puddles.splice(0, puddles.length - MAX_PUDDLES + 3); // Keep some room for new ones
            }
            
            // Create 3-7 puddles after rain
            const puddleCount = Math.floor(3 + Math.random() * 5);
            for (let i = 0; i < puddleCount; i++) {
                // Distribute across ground (positioned below ground line)
                const puddleX = Math.random() * canvas.width;
                const puddleY = canvas.height * GROUND_HEIGHT_RATIO + 15;
                
                puddles.push({
                    x: puddleX,
                    y: puddleY,
                    size: 20 + Math.random() * 40,
                    depth: 0.7 + Math.random() * 0.3, // Depth for reflection/color
                    evaporationRate: PUDDLE_EVAPORATION_RATE * (0.8 + Math.random() * 0.4), // Some variation
                    ripples: []
                });
            }
            debugLog(`Created ${puddleCount} puddles after rain`);
        }

        function updatePuddles(deltaTime) {
            // Skip if not visible
            if (puddles.length === 0) return;
            
            for (let i = puddles.length - 1; i >= 0; i--) {
                const puddle = puddles[i];
                
                // Add random ripples occasionally
                if (Math.random() < 0.02) {
                    puddle.ripples.push({
                        size: 5,
                        maxSize: 10 + Math.random() * 20,
                        speed: 0.05 + Math.random() * 0.1
                    });
                }
                
                // Update ripples
                for (let j = puddle.ripples.length - 1; j >= 0; j--) {
                    const ripple = puddle.ripples[j];
                    ripple.size += ripple.speed * deltaTime;
                    
                    if (ripple.size >= ripple.maxSize) {
                        puddle.ripples.splice(j, 1);
                    }
                }
                
                // Evaporate puddles very gradually
                puddle.size -= puddle.evaporationRate * deltaTime;
                
                // Remove puddle if too small
                if (puddle.size <= 5) {
                    puddles.splice(i, 1);
                    debugLog(`Puddle evaporated at (${puddle.x}, ${puddle.y})`);
                }
            }
        }

        function drawPuddles() {
            puddles.forEach(puddle => {
                // Main puddle shape - simplified for performance
                ctx.fillStyle = `rgba(110, 150, 230, ${puddle.depth * 0.7})`;
                ctx.beginPath();
                ctx.ellipse(
                    puddle.x, puddle.y,
                    puddle.size, puddle.size * 0.3,
                    0, 0, Math.PI * 2
                );
                ctx.fill();

                // Add center highlight for depth
                ctx.fillStyle = `rgba(150, 180, 255, ${puddle.depth * 0.4})`;
                ctx.beginPath();
                ctx.ellipse(
                    puddle.x, puddle.y,
                    puddle.size * 0.5, puddle.size * 0.15,
                    0, 0, Math.PI * 2
                );
                ctx.fill();

                // Draw ripples
                puddle.ripples.forEach(ripple => {
                    const opacity = 1 - ripple.size / ripple.maxSize;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(
                        puddle.x, puddle.y,
                        ripple.size, ripple.size * 0.3,
                        0, 0, Math.PI * 2
                    );
                    ctx.stroke();
                });
            });
        }

        // Draw ponds (permanent water features)
        function drawPonds() {
            ponds.forEach(pond => {
                // Draw pond with top edge at ground level (center below ground)
                const drawY = pond.y + pond.height;

                // Pond base - simplified solid colors for better performance
                ctx.fillStyle = mushroomMode ? getMushroomColor('rgba(50, 110, 190, 0.85)') : 'rgba(50, 110, 190, 0.85)';
                ctx.beginPath();
                ctx.ellipse(pond.x, drawY, pond.width, pond.height, 0, 0, Math.PI * 2);
                ctx.fill();

                // Reflections/highlights
                ctx.fillStyle = mushroomMode ? getMushroomColor('rgba(200, 220, 255, 0.3)') : 'rgba(200, 220, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(pond.x - pond.width * 0.2, drawY - pond.height * 0.3, pond.width * 0.3, pond.height * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw ripples - limit to visible ripples for performance
                // Apply clipping to keep ripples within pond boundaries
                ctx.save();
                ctx.beginPath();
                ctx.ellipse(pond.x, drawY, pond.width, pond.height, 0, 0, Math.PI * 2);
                ctx.clip();

                const visibleRipples = pond.ripples.slice(0, 5);
                visibleRipples.forEach(ripple => {
                    const opacity = 1 - ripple.age / ripple.maxAge;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(ripple.x, ripple.y, ripple.size, ripple.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                });

                ctx.restore();
            });
        }

        // Update ponds
        function updatePonds(deltaTime) {
            ponds.forEach(pond => {
                // Update ripples
                pond.ripples = pond.ripples.filter(ripple => {
                    ripple.age += deltaTime;
                    ripple.size += deltaTime * 0.05;
                    return ripple.age < ripple.maxAge;
                });

                // Occasionally add ripples - reduced frequency and limit count for performance
                if (Math.random() < 0.005 && pond.ripples.length < 8) {
                    pond.ripples.push({
                        x: pond.x + (Math.random() - 0.5) * pond.width,
                        y: pond.y + (Math.random() - 0.5) * pond.height,
                        size: 5,
                        age: 0,
                        maxAge: 2000
                    });
                }
            });
        }

        // Draw koi fish
        function drawKoi() {
            koi.forEach(fish => {
                const pond = ponds[fish.pondIndex];
                if (!pond) return;

                // Use displayY if available (for jumping), otherwise use y
                const drawY = fish.displayY !== undefined ? fish.displayY : fish.y;

                // Koi body - simplified for performance
                ctx.save();
                ctx.translate(fish.x, drawY);
                ctx.rotate(fish.swimAngle);

                // Body - solid color with white belly highlight
                ctx.fillStyle = mushroomMode ? getMushroomColor(fish.color) : fish.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // White belly highlight (simple oval)
                ctx.fillStyle = mushroomMode ? getMushroomColor('rgba(255, 255, 255, 0.6)') : 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.ellipse(0, 2, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Tail
                ctx.fillStyle = mushroomMode ? getMushroomColor(fish.color) : fish.color;
                ctx.beginPath();
                ctx.moveTo(-12, 0);
                ctx.lineTo(-18, -6);
                ctx.lineTo(-18, 6);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }

        // Update koi
        function updateKoi(deltaTime) {
            koi.forEach(fish => {
                const pond = ponds[fish.pondIndex];
                if (!pond) return;

                // Check for nearby birds - koi get excited and swim faster
                const pondCenterY = pond.y + pond.height; // Pond center is below ground level
                const nearbyBird = birds.find(bird =>
                    distance(bird.x, bird.y, pond.x, pondCenterY) < 100 &&
                    bird.y > pond.y - 50 // Bird is close to pond level
                );

                let speedMultiplier = 1;
                if (nearbyBird) {
                    speedMultiplier = 2; // Swim faster when birds are near
                    // Occasionally jump out of water
                    if (Math.random() < 0.005) {
                        fish.jumping = true;
                        fish.jumpTimer = 0;
                        fish.jumpHeight = 0;
                        debugLog(`Koi jumped out of water near bird!`);
                    }
                }

                // Handle jumping animation
                if (fish.jumping) {
                    fish.jumpTimer += deltaTime;
                    if (fish.jumpTimer < 400) {
                        // Arc up and down
                        const progress = fish.jumpTimer / 400;
                        fish.jumpHeight = Math.sin(progress * Math.PI) * 15;
                    } else {
                        fish.jumping = false;
                        fish.jumpHeight = 0;
                        // Create splash ripple
                        pond.ripples.push({
                            x: fish.x,
                            y: fish.y,
                            size: 5,
                            age: 0,
                            maxAge: 1500
                        });
                    }
                }

              // Swim in circular pattern within pond (slowed down from 0.001 to 0.0003)
fish.swimAngle += deltaTime * 0.0003 * speedMultiplier;
const radius = Math.min(pond.width, pond.height) * 0.6;
fish.x = pond.x + Math.cos(fish.swimAngle * 2) * radius * 0.7;
fish.y = pondCenterY + Math.sin(fish.swimAngle * 2) * radius * 0.4;

                // Adjust y for jump height
                if (fish.jumping) {
                    fish.displayY = fish.y - fish.jumpHeight;
                } else {
                    fish.displayY = fish.y;
                }

                // Occasionally create ripple
                if (Math.random() < 0.02 && !fish.jumping) {
                    pond.ripples.push({
                        x: fish.x,
                        y: fish.y,
                        size: 3,
                        age: 0,
                        maxAge: 1500
                    });
                }
            });
        }

        // Draw frogs
        function drawFrogs() {
            frogs.forEach(frog => {
                // Frog body (expand slightly when croaking)
                const bodySize = frog.croaking ? 1.2 : 1;
                ctx.fillStyle = mushroomMode ? getMushroomColor('#4CAF50') : '#4CAF50';
                ctx.beginPath();
                ctx.ellipse(frog.x, frog.y, 8 * bodySize, 6 * bodySize, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = mushroomMode ? getMushroomColor('#FFD700') : '#FFD700';
                ctx.beginPath();
                ctx.arc(frog.x - 3, frog.y - 4, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(frog.x + 3, frog.y - 4, 3, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(frog.x - 3, frog.y - 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(frog.x + 3, frog.y - 4, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Croaking indicator (sound waves)
                if (frog.croaking) {
                    const opacity = 1 - (frog.croakTimer / 500);
                    ctx.strokeStyle = `rgba(100, 200, 100, ${opacity})`;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.arc(frog.x, frog.y, 15 + i * 8 + (frog.croakTimer / 20), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Tongue if out
                if (frog.tongueOut && frog.tongueTarget) {
                    ctx.strokeStyle = mushroomMode ? getMushroomColor('#FF6B9D') : '#FF6B9D';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(frog.x, frog.y);
                    ctx.lineTo(frog.tongueTarget.x, frog.tongueTarget.y);
                    ctx.stroke();
                }
            });
        }

        // Update frogs
        function updateFrogs(deltaTime) {
            frogs.forEach(frog => {
                // Check for nearby birds - frogs get nervous
                const nearbyBird = birds.find(bird =>
                    distance(bird.x, bird.y, frog.x, frog.y) < 80 &&
                    bird.y > frog.y - 50
                );

                if (nearbyBird && !frog.jumping) {
                    // Jump away from bird
                    if (Math.random() < 0.05) {
                        const jumpAwayX = frog.x + (frog.x - nearbyBird.x > 0 ? 1 : -1) * (40 + Math.random() * 40);
                        frog.jumping = true;
                        frog.jumpTimer = 0;
                        frog.jumpStartX = frog.x;
                        frog.jumpStartY = frog.y;
                        frog.jumpTargetX = jumpAwayX;
                        frog.jumpTargetY = canvas.height * GROUND_HEIGHT_RATIO;
                        debugLog(`Frog jumping away from bird!`);
                    }

                    // Croak at bird (visual indicator)
                    if (Math.random() < 0.02) {
                        frog.croaking = true;
                        frog.croakTimer = 0;
                    }
                }

                // Update croaking animation
                if (frog.croaking) {
                    frog.croakTimer += deltaTime;
                    if (frog.croakTimer > 500) {
                        frog.croaking = false;
                    }
                }

                // Check for nearby ponds and jump toward them
                if (!frog.jumping && Math.random() < 0.003) {
                    let nearestPond = null;
                    let nearestDist = Infinity;

                    for (const pond of ponds) {
                        const dist = distance(frog.x, frog.y, pond.x, pond.y + pond.height);
                        if (dist < nearestDist && dist < 200) {
                            nearestDist = dist;
                            nearestPond = pond;
                        }
                    }

                    if (nearestPond && Math.random() < 0.4) {
                        // Jump toward pond
                        frog.jumping = true;
                        frog.jumpTimer = 0;
                        frog.jumpStartX = frog.x;
                        frog.jumpStartY = frog.y;
                        frog.jumpTargetX = nearestPond.x + (Math.random() - 0.5) * nearestPond.width * 0.5;
                        frog.jumpTargetY = nearestPond.y + nearestPond.height; // Jump into pond
                        debugLog(`Frog jumping into pond at (${frog.jumpTargetX.toFixed(0)}, ${frog.jumpTargetY.toFixed(0)})`);
                    } else {
                        // Jump randomly
                        frog.jumping = true;
                        frog.jumpTimer = 0;
                        frog.jumpStartX = frog.x;
                        frog.jumpStartY = frog.y;
                        frog.jumpTargetX = frog.x + (Math.random() - 0.5) * 100;
                        frog.jumpTargetY = canvas.height * GROUND_HEIGHT_RATIO;
                        debugLog(`Frog jumping from (${frog.x.toFixed(0)}, ${frog.y.toFixed(0)})`);
                    }
                }

                if (frog.jumping) {
                    frog.jumpTimer += deltaTime;
                    const progress = Math.min(1, frog.jumpTimer / 500);
                    frog.x = frog.jumpStartX + (frog.jumpTargetX - frog.jumpStartX) * progress;
                    frog.y = frog.jumpStartY + (frog.jumpTargetY - frog.jumpStartY) * progress - Math.sin(progress * Math.PI) * 20;

                    if (progress >= 1) {
                        frog.jumping = false;
                    }
                }

                // Try to catch nearby insects
                if (!frog.tongueOut && Math.random() < 0.005) {
                    const nearbyAnts = ants.filter(ant => distance(frog.x, frog.y, ant.x, ant.y) < 50);
                    if (nearbyAnts.length > 0) {
                        frog.tongueOut = true;
                        frog.tongueTarget = nearbyAnts[0];
                        frog.tongueTimer = 0;
                        frog.tongueTargetIndex = ants.indexOf(nearbyAnts[0]);
                    }
                }

                // Update tongue animation
                if (frog.tongueOut) {
                    frog.tongueTimer += deltaTime;
                    if (frog.tongueTimer >= 200) {
                        // Try to catch the ant
                        if (Math.random() < 0.3 && frog.tongueTargetIndex !== -1) {
                            if (ants[frog.tongueTargetIndex] === frog.tongueTarget) {
                                ants.splice(frog.tongueTargetIndex, 1);
                                debugLog(`Frog caught an ant!`);
                            }
                        }
                        frog.tongueOut = false;
                        frog.tongueTarget = null;
                        frog.tongueTargetIndex = -1;
                    }
                }
            });
        }

        // Canvas resize handler that preserves entities and their positions
        let resizeController = null;
        window.addEventListener('resize', () => {
            if (resizeController) clearTimeout(resizeController);
            resizeController = setTimeout(() => {
                // Just pause animation temporarily instead of stopping it
                const wasRunning = animationRunning;
                animationRunning = false;
                
                try {
                    debugLog("Adjusting canvas size");
                    resizeCanvas();
                } catch (e) {
                    console.error("Resize error:", e);
                } finally {
                    // Resume animation without recreating entities
                    animationRunning = wasRunning;
                }
                resizeController = null;
            }, 200);
        });

        // Add this visibility change event listener here
document.addEventListener('visibilitychange', function() {
    isTabVisible = !document.hidden;
    // Optional: pause rain if tab becomes hidden
    if (document.hidden && isRaining) {
        isRaining = false;
    }
});

        function resizeCanvas() {
            const prevWidth = canvas.width;
            const prevHeight = canvas.height;
            const prevGroundLevel = prevHeight * GROUND_HEIGHT_RATIO;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const newGroundLevel = canvas.height * GROUND_HEIGHT_RATIO;
            
            // Only regenerate stars, not other entities
            generateStars();
            
            // Only apply ground-based entity adjustments if this is not the first resize
            if (prevWidth > 0 && prevHeight > 0) {
                const scaleX = canvas.width / prevWidth;
                const scaleY = canvas.height / prevHeight;
                const groundDelta = newGroundLevel - prevGroundLevel;

                // ADD THE SCARECROW POSITIONING CODE RIGHT AFTER THIS COMMENT
        if (scarecrow) {
            // Preserve x-position relative to screen width
            const xRatio = scarecrow.x / prevWidth;
            scarecrow.x = canvas.width * xRatio;
            
            // Always place on new ground level
            scarecrow.y = canvas.height * GROUND_HEIGHT_RATIO;
        }
                
                // FIXED: Keep trees at absolute positions, only adjust Y for ground level
                if (trees.length > 0) {
                    trees.forEach((tree) => {
                        const oldTreeX = tree.x;
                        const oldTreeY = tree.y;

                        // Don't move tree X position - keep natural placement
                        // Only clamp to keep on screen if needed
                        if (tree.x < 50) tree.x = 50;
                        if (tree.x > canvas.width - 50) tree.x = canvas.width - 50;

                        // Keep trees properly grounded at the new ground level, preserving depth offset
                        tree.y = newGroundLevel + (tree.depthOffset || 0);

                        // FIXED: Update nests attached to this tree
                        nests.forEach(nest => {
                            if (nest.tree === tree || nest.treeId === tree.id) {
                                // Move nest with its parent tree
                                const offsetX = nest.x - oldTreeX;
                                const offsetY = nest.y - oldTreeY;
                                nest.x = tree.x + offsetX;
                                nest.y = tree.y + offsetY;
                                nest.tree = tree; // Ensure reference is maintained
                                nest.treeId = tree.id; // Update treeId to match
                            }
                        });

                        // FIXED: Update wind chimes attached to this tree
                        windChimes.forEach(chime => {
                            if (chime.treeId === tree.id) {
                                // Move wind chime with its parent tree
                                const offsetX = chime.x - oldTreeX;
                                chime.x = tree.x + offsetX;
                                chime.y = tree.y - tree.trunkHeight * 0.7; // Recalculate hanging position
                                debugLog(`Wind chime repositioned with tree at (${chime.x})`);
                            }
                        });
                    });
                }
                
                // Update other ground-based entities
                worms.forEach(worm => {
                    worm.x *= scaleX;
                    // If worm was on ground, keep it on ground
                    if (Math.abs(worm.y - prevGroundLevel) < 50) {
                        worm.y = newGroundLevel + (worm.y - prevGroundLevel);
                    } else {
                        worm.y *= scaleY;
                    }
                });
                
                twigs.forEach(twig => {
    twig.x *= scaleX;
    // If twig was on ground, keep it on ground
    if (Math.abs(twig.y - prevGroundLevel) < 50) {
        twig.y = newGroundLevel + (twig.y - prevGroundLevel);  // FIXED: twig.y instead of worm.y
    } else {
        twig.y *= scaleY;
    }
});
                
                // Update birds to maintain their height above ground if they were near it
                birds.forEach(bird => {
                    bird.x *= scaleX;
                    if (Math.abs(bird.y - prevGroundLevel) < 30) {
                        // Bird was near ground, keep it same distance from ground
                        bird.y = newGroundLevel - (prevGroundLevel - bird.y);
                    } else {
                        bird.y *= scaleY;
                    }
                });
                
                // Do the same for other entities
                birdPoops.forEach(poop => {
                    poop.x *= scaleX;
                    if (poop.grounded) {
                        poop.y = newGroundLevel;
                    } else {
                        poop.y *= scaleY;
                    }
                });
                
                foodItems.forEach(food => {
                    food.x *= scaleX;
                    if (Math.abs(food.y - prevGroundLevel) < 50) {
                        food.y = newGroundLevel + (food.y - prevGroundLevel);
                    } else {
                        food.y *= scaleY;
                    }
                });
                
                puddles.forEach(puddle => {
                    puddle.x *= scaleX;
                    puddle.y = newGroundLevel + 3; // Puddles always on ground
                });

                // Update ponds - keep them at ground level
                ponds.forEach(pond => {
                    pond.x *= scaleX;
                    pond.y = newGroundLevel; // Ponds stay at ground level
                });

                // Update frogs - keep them at ground level
                frogs.forEach(frog => {
                    frog.x *= scaleX;
                    frog.y = newGroundLevel; // Frogs stay at ground level
                    // Update jump targets if currently jumping
                    if (frog.jumping) {
                        frog.jumpTargetX *= scaleX;
                        frog.jumpTargetY = newGroundLevel;
                        frog.jumpStartX *= scaleX;
                        frog.jumpStartY = newGroundLevel;
                    }
                });

                // Koi positions are relative to pond center, will auto-update based on pond position

                nests.forEach(nest => {
            // FIX: Use stored offsets for proper nest positioning during resize
            if (nest.tree && trees.includes(nest.tree)) {
                const tree = nest.tree;

                // Recalculate position based on stored offset and height ratio
                nest.x = tree.x + nest.offsetX; // Apply stored horizontal offset
                nest.y = tree.y - tree.trunkHeight * nest.heightRatio * tree.scale; // Use stored height ratio
            } else {
                // No valid tree association, scale normally
                nest.x *= scaleX;
                nest.y *= scaleY;

                // Clear invalid tree reference
                if (nest.tree && !trees.includes(nest.tree)) {
                    nest.tree = null;
                    nest.offsetX = 0;
                }
            }
        });
                
                birdhouses.forEach(birdhouse => {
                    birdhouse.x *= scaleX;
                    birdhouse.y = newGroundLevel; // Birdhouses are on ground
                });
                
                rats.forEach(rat => {
                    rat.x *= scaleX;
                    rat.y = newGroundLevel - 5 + (Math.random() * 10); // Keep rats on ground with some variation
                });
                
                squirrels.forEach(squirrel => {
                    squirrel.x *= scaleX;
                    if (Math.abs(squirrel.y - prevGroundLevel) < 30) {
                        squirrel.y = newGroundLevel - (prevGroundLevel - squirrel.y);
                    } else {
                        squirrel.y *= scaleY;
                    }
                });
                
                // NEW: Handle eggs during resize
                eggs.forEach(egg => {
                    egg.x *= scaleX;

                    // If egg has an associated nest, keep it with the nest
                    if (egg.associatedNest && nests.includes(egg.associatedNest)) {
                        egg.x = egg.associatedNest.x;
                        egg.y = egg.associatedNest.y;
                    } else {
                        egg.y *= scaleY;
                    }
                });

                babyBirds.forEach(baby => {
    baby.x *= scaleX;

    // If baby has an associated nest, keep it with the nest
    if (baby.associatedNest && nests.includes(baby.associatedNest)) {
        baby.x = baby.associatedNest.x;
        baby.y = baby.associatedNest.y;
    } else if (Math.abs(baby.y - prevGroundLevel) < 30) {
        // If baby is near ground, keep it at same distance from ground
        baby.y = newGroundLevel - (prevGroundLevel - baby.y);
    } else {
        // Otherwise scale proportionally
        baby.y *= scaleY;
    }
});

                // Also update flowers
                flowers.forEach(flower => {
                    flower.x *= scaleX;
                    if (Math.abs(flower.y - prevGroundLevel) < 50) {
                        flower.y = newGroundLevel + (flower.y - prevGroundLevel);
                    } else {
                        flower.y *= scaleY;
                    }
                });

                // Update bushes - keep at ground level like trees with depth offset
                bushes.forEach(bush => {
                    // Don't scale X - keep natural placement like trees
                    // Only clamp to keep on screen if needed
                    if (bush.x < 50) bush.x = 50;
                    if (bush.x > canvas.width - 50) bush.x = canvas.width - 50;

                    // Keep bushes at ground level with stored depth offset
                    bush.y = newGroundLevel + (bush.depthOffset || 0);
                });

                // Update stones - keep at ground level with depth offset
                stones.forEach(stone => {
                    // Don't scale X - keep natural placement
                    // Only clamp to keep on screen if needed
                    if (stone.x < 20) stone.x = 20;
                    if (stone.x > canvas.width - 20) stone.x = canvas.width - 20;

                    // Keep stones at ground level with stored depth offset
                    stone.y = newGroundLevel + (stone.depthOffset || 0);
                });

                // Update tall grass patches - keep at ground level with depth offset
                tallGrassPatches.forEach(grass => {
                    // Don't scale X - keep natural placement
                    // Only clamp to keep on screen if needed
                    if (grass.x < 50) grass.x = 50;
                    if (grass.x > canvas.width - 50) grass.x = canvas.width - 50;

                    // Keep grass at ground level with stored depth offset
                    grass.y = newGroundLevel + (grass.depthOffset || 0);
                });
// Update ant hill if it exists
if (antHill) {
    antHill.x *= scaleX; // Scale X position based on canvas width change
    antHill.y = newGroundLevel + 5; // Position it at ground level with small offset
    antHill.entranceY = newGroundLevel + 2; // Update entrance position too
}
// Update ant hill position
if (antHill) {
    // Scale horizontally proportionally
    antHill.x = (antHill.x / prevWidth) * canvas.width;
    
    // Fix vertical position directly to ground level + small offset
    antHill.y = canvas.height * GROUND_HEIGHT_RATIO + 5;
    
    // Also update the entrance position
    antHill.entranceY = canvas.height * GROUND_HEIGHT_RATIO - 3;
    
    debugLog("Ant hill position fixed after resize");
}

            }
        }

   // Day/Night cycle
function updateDayNightCycle(deltaTime) {
    previousTimeOfDay = timeOfDay;
    timeOfDay = (timeOfDay + deltaTime / dayNightDuration) % 2;
    
   // Track hour of day (0-23) for morning food spawn
const oldHour = currentHour;
// Adjusted formula: Add 6 hours so noon is at timeOfDay 0.5, midnight at timeOfDay 1.5
currentHour = Math.floor(((timeOfDay < 1 ? timeOfDay * 12 : 12 + (timeOfDay - 1) * 12) + 6) % 24);
    
    // Start of new day
    if (timeOfDay < previousTimeOfDay) {
        dayNightCycleCount++;
        // No modulo operation here to ensure days keep counting past 99
        debugLog(`Day/night cycle count: ${dayNightCycleCount}`);

        // Add daily summary entry to diary
        const birdCount = birds.length;
        const nestCount = nests.filter(n => n.isComplete).length;
        const babyCount = babyBirds.length;
        let summaryText = `Day ${dayNightCycleCount} complete. `;

        if (birdCount > 0) {
            summaryText += `${birdCount} bird${birdCount !== 1 ? 's' : ''} in the garden. `;
        }
        if (nestCount > 0) {
            summaryText += `${nestCount} active nest${nestCount !== 1 ? 's' : ''}. `;
        }
        if (babyCount > 0) {
            summaryText += `${babyCount} baby bird${babyCount !== 1 ? 's' : ''} growing. `;
        }
        if (birdCount === 0 && nestCount === 0) {
            summaryText += `The garden awaits its first visitors.`;
        }

        addDiaryEntry(summaryText, 'normal');
    }

    // Start of night - randomly determine if fireflies should appear (35% chance)
    if (previousTimeOfDay < 1 && timeOfDay >= 1) {
        // FIXED: Made fireflies much more rare (10% chance instead of 35%)
        fireflyNightActive = Math.random() < 0.10;
        if (fireflyNightActive) {
            debugLog('Fireflies will appear tonight');
        }
    }
    
    // Morning food and worm spawn (around 6-7 AM)
    if ((oldHour !== currentHour) && (currentHour === 6 || currentHour === 7)) {
        if (Date.now() - lastHourlyUpdate > 30000) { // Prevent multiple updates in same hour
            spawnMorningFood();
            lastHourlyUpdate = Date.now();
        }
    }
}
        
        // Morning food and worm spawn
        function spawnMorningFood() {
            debugLog(`Morning food and worms spawning at hour ${currentHour}`);
            
            // Spawn extra worms in the morning
            for (let i = 0; i < MORNING_WORM_SPAWN_COUNT; i++) {
                if (worms.length < MAX_WORMS) {
                    const x = Math.random() * (canvas.width - 100) + 50;
                    const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 20;
                    
                    worms.push({
                        x: x,
                        y: y,
                        wiggle: Math.random() * Math.PI * 2,
                        size: 5 + Math.random() * 5
                    });
                }
            }
            
            // Spawn extra food in the morning
            for (let i = 0; i < MORNING_FOOD_SPAWN_COUNT; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 5;
                scatterFood(x, y, 1); // Scatter individual food items across the ground
            }
            
            debugLog(`Added ${MORNING_WORM_SPAWN_COUNT} worms and ${MORNING_FOOD_SPAWN_COUNT} food items`);
        }

        // Vector helper functions
        function distance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function normalize(x, y) {
            const len = Math.sqrt(x * x + y * y);
            if (len === 0) return { x: 0, y: 0 };
            return { x: x / len, y: y / len };
        }

        function getMushroomColor(baseColor, saturationRange = [70, 100], lightnessRange = [50, 70]) {
    if (!mushroomMode) return baseColor;
    
    // For hex colors, convert to HSL
    let h, s, l;
    
    if (typeof baseColor === 'string' && baseColor.startsWith('#')) {
        // Convert hex to RGB
        const r = parseInt(baseColor.slice(1, 3), 16) / 255;
        const g = parseInt(baseColor.slice(3, 5), 16) / 255;
        const b = parseInt(baseColor.slice(5, 7), 16) / 255;
        
        // Convert RGB to HSL
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d = max - min;
        
        // Calculate hue
        if (d === 0) h = 0;
        else if (max === r) h = ((g - b) / d) % 6;
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;
        
        h = Math.round(h * 60);
        if (h < 0) h += 360;
        
        // Calculate lightness and saturation
        l = (max + min) / 2;
        s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
        
        s = Math.round(s * 100);
        l = Math.round(l * 100);
    } else {
        // For simplicity, use a random hue if not a hex color
        h = Math.random() * 360;
        s = 80;
        l = 60;
    }
    
    // Cycle the hue based on time
    h = (h + colorCycleTimer / 50) % 360;
    
    // Randomize saturation and lightness within ranges
    s = saturationRange[0] + Math.random() * (saturationRange[1] - saturationRange[0]);
    l = lightnessRange[0] + Math.random() * (lightnessRange[1] - lightnessRange[0]);
    
    return `hsl(${h}, ${s}%, ${l}%)`;
}


        // Improved proximity check function
        function isEntityOnScreen(entity, buffer = 100) {
            return entity.x >= -buffer && 
                   entity.x <= canvas.width + buffer && 
                   entity.y >= -buffer && 
                   entity.y <= canvas.height + buffer;
        }

        // V26: Enhanced validatePosition function with even gentler boundary management
        function validatePosition(obj) {
            // Constants for boundary behavior - even gentler push now
            const visibleBuffer = 25;   // Increased from 20
            const hardBuffer = 120;     // Reduced for more aggressive recovery
            const centerPush = 0.08;    // Decreased from 0.1 for even gentler push


            function checkBirdsStuckBetweenTrees() {
    try {
        // Only run every few frames to reduce performance impact
        if (Math.random() > 0.1) return; // Only run 10% of the time
        
        for (const bird of birds) {
            // Skip birds that are intentionally perched or building
            if (bird.state === BIRD_STATES.PERCHED || 
                bird.state === BIRD_STATES.BUILDING ||
                bird.state === BIRD_STATES.RESTING) {
                continue;
            }
            
            // Check if bird is near at least two trees
            const nearbyTrees = [];
            for (const tree of trees) {
                if (tree && typeof tree.x === 'number' && typeof tree.trunkWidth === 'number') {
                    if (Math.abs(bird.x - tree.x) < tree.trunkWidth * 1.5) {
                        nearbyTrees.push(tree);
                    }
                }
            }
            
            if (nearbyTrees.length >= 2) {
                // Bird is potentially trapped between trees
                // Calculate if bird is truly trapped (trees on both sides)
                const leftTrees = [];
                const rightTrees = [];
                
                for (const tree of nearbyTrees) {
                    if (tree.x < bird.x) {
                        leftTrees.push(tree);
                    } else if (tree.x > bird.x) {
                        rightTrees.push(tree);
                    }
                }
                
                if (leftTrees.length > 0 && rightTrees.length > 0) {
                    // Bird is truly stuck between trees on both sides
                    debugLog(`Bird detected stuck between trees at (${bird.x}, ${bird.y})`);
                    
                    // Determine escape direction (simpler approach)
                    const goLeft = Math.random() < 0.5;
                    
                    if (goLeft) {
                        // Escape to the left
                        bird.velocity.x = -1;
                        bird.direction = -1;
                    } else {
                        // Escape to the right
                        bird.velocity.x = 1;
                        bird.direction = 1;
                    }
                    
                    // Also add upward velocity for better escape
                    bird.velocity.y = -1;
                    
                    // Set bird to flying state
                    bird.state = BIRD_STATES.FLYING;
                    bird.stateTimer = 0;
                }
            }
        }
    } catch (error) {
        // If any error occurs, log it but don't break the game
        console.error("Error in checkBirdsStuckBetweenTrees:", error);
    }
}
            
            // For birds specifically, use enhanced logic
            const isBird = obj.hasOwnProperty('state') && Object.values(BIRD_STATES).includes(obj.state);
            const isRat = obj.hasOwnProperty('isRatKing') !== undefined;
            const isSquirrel = obj.hasOwnProperty('tailWobble') !== undefined;
            
            // Check if entity is marked to leave screen
            const isLeavingIntentionally = 
                (isRat && obj.state === 'wandering' && obj.direction * obj.x > 0) ||
                (isSquirrel && obj.state === 'leaving') ||
                (isBird && obj.isWild && obj.stateTimer > 15000);
            
            // If entity is intentionally leaving, allow it to go off-screen
            if (isLeavingIntentionally) {
                return;
            }

            // Hard limits - still keep objects on-screen (+buffer) but with larger buffer
            if (isBird) {
                // Birds shouldn't go far off-screen - gentler limits
                obj.x = Math.max(-hardBuffer/2, Math.min(obj.x, canvas.width + hardBuffer/2));
                obj.y = Math.max(-hardBuffer/2, Math.min(obj.y, canvas.height + hardBuffer/2));
                
                // If bird is off-screen, use gentle recovery
                if (obj.x < 0 || obj.x > canvas.width || 
                    obj.y < 0 || obj.y > canvas.height) {
                    obj.isOffscreen = true;
                    
                    // Only clear path and force return if bird has been off-screen for a while
                    if (!obj.offscreenTime) {
                        obj.offscreenTime = 0;
                    }
                    obj.offscreenTime += 16; // Add time
                    
                    if (obj.offscreenTime > 5000) { // 5 seconds off-screen
                        // Clear any existing path and gently return to screen
                        obj.path = [];
                        obj.pathIndex = 0;
                        
                        // Generate new path to return to visible area
                        if (obj.generatePath) {
                            const targetX = 100 + Math.random() * (canvas.width - 200);
                            const targetY = 100 + Math.random() * (canvas.height * 0.5 - 100);
                            obj.generatePath(targetX, targetY);
                            
                            // Reset velocity gently to break any loops
                            obj.velocity = { 
                                x: obj.velocity.x * 0.5, 
                                y: obj.velocity.y * 0.5 
                            };
                            obj.state = BIRD_STATES.FLYING;
                            obj.stateTimer = 0;
                            debugLog(`Gently guiding off-screen bird back to (${targetX}, ${targetY})`);
                            obj.offscreenTime = 0;
                        }
                    }
                } else {
                    obj.isOffscreen = false;
                    obj.offscreenTime = 0;
                }
            } else {
                // Non-bird entities can have larger buffer
                obj.x = Math.max(-hardBuffer, Math.min(obj.x, canvas.width + hardBuffer));
                obj.y = Math.max(-hardBuffer, Math.min(obj.y, canvas.height + hardBuffer));
            }
        }

        // Background drawing
        // Split into two functions: drawSky (fixed) and drawGround (moves with camera)
        function drawSky() {
            let skyColor;

            // Expanded sunset variations - space them out over longer periods
            const sunsetType = Math.floor(simulationTime / dayNightDuration * 5) % 20;

            if (timeOfDay < 1) {
                // Day colors with sunset variations
                const sunsetTime = timeOfDay > 0.6 && timeOfDay < 0.98;

                if (sunsetTime) {
                    const sunsetIntensity = Math.min(1, (timeOfDay - 0.6) * 3);

                    switch(sunsetType) {
                        case 0: // Warm golden hour
                            skyColor = `hsl(${40 + timeOfDay * 5}, ${85 * sunsetIntensity}%, ${75 - timeOfDay * 15}%)`;
                            break;
                        case 1: // Classic orange sunset
                            skyColor = `hsl(${25 + timeOfDay * 10}, ${95 * sunsetIntensity}%, ${65 - timeOfDay * 20}%)`;
                            break;
                        case 2: // Soft pink sunset
                            skyColor = `hsl(${320 + timeOfDay * 10}, ${80 * sunsetIntensity}%, ${70 - timeOfDay * 25}%)`;
                            break;
                        case 3: // Vibrant coral
                            skyColor = `hsl(${5 + timeOfDay * 5}, ${90 * sunsetIntensity}%, ${60 - timeOfDay * 30}%)`;
                            break;
                        case 4: // Calming turquoise
                            skyColor = `hsl(${180 + timeOfDay * 8}, ${70 * sunsetIntensity}%, ${65 - timeOfDay * 20}%)`;
                            break;
                        case 5: // Serene lavender
                            skyColor = `hsl(${240 + timeOfDay * 15}, ${80 * sunsetIntensity}%, ${65 - timeOfDay * 25}%)`;
                            break;
                        case 6: // Peachy apricot
                            skyColor = `hsl(${30 + timeOfDay * 8}, ${92 * sunsetIntensity}%, ${72 - timeOfDay * 22}%)`;
                            break;
                        case 7: // Rose quartz
                            skyColor = `hsl(${340 + timeOfDay * 12}, ${75 * sunsetIntensity}%, ${68 - timeOfDay * 23}%)`;
                            break;
                        case 8: // Gentle amber
                            skyColor = `hsl(${45 + timeOfDay * 6}, ${88 * sunsetIntensity}%, ${73 - timeOfDay * 18}%)`;
                            break;
                        case 9: // Soft periwinkle
                            skyColor = `hsl(${220 + timeOfDay * 10}, ${65 * sunsetIntensity}%, ${70 - timeOfDay * 20}%)`;
                            break;
                        case 10: // Warm salmon
                            skyColor = `hsl(${15 + timeOfDay * 7}, ${85 * sunsetIntensity}%, ${67 - timeOfDay * 24}%)`;
                            break;
                        case 11: // Tranquil mint
                            skyColor = `hsl(${165 + timeOfDay * 9}, ${68 * sunsetIntensity}%, ${69 - timeOfDay * 19}%)`;
                            break;
                        case 12: // Soft mauve
                            skyColor = `hsl(${280 + timeOfDay * 14}, ${73 * sunsetIntensity}%, ${66 - timeOfDay * 21}%)`;
                            break;
                        case 13: // Golden peach
                            skyColor = `hsl(${35 + timeOfDay * 9}, ${90 * sunsetIntensity}%, ${71 - timeOfDay * 20}%)`;
                            break;
                        case 14: // Dusty rose
                            skyColor = `hsl(${350 + timeOfDay * 8}, ${78 * sunsetIntensity}%, ${69 - timeOfDay * 26}%)`;
                            break;
                        case 15: // Aqua breeze
                            skyColor = `hsl(${190 + timeOfDay * 11}, ${72 * sunsetIntensity}%, ${68 - timeOfDay * 18}%)`;
                            break;
                        case 16: // Lilac dream
                            skyColor = `hsl(${270 + timeOfDay * 13}, ${76 * sunsetIntensity}%, ${67 - timeOfDay * 22}%)`;
                            break;
                        case 17: // Honey glow
                            skyColor = `hsl(${48 + timeOfDay * 7}, ${87 * sunsetIntensity}%, ${74 - timeOfDay * 19}%)`;
                            break;
                        case 18: // Blush pink
                            skyColor = `hsl(${330 + timeOfDay * 10}, ${82 * sunsetIntensity}%, ${70 - timeOfDay * 24}%)`;
                            break;
                        case 19: // Soft cerulean
                            skyColor = `hsl(${200 + timeOfDay * 12}, ${70 * sunsetIntensity}%, ${66 - timeOfDay * 21}%)`;
                            break;
                    }
                } else {
                    // Day sky variations based on sunsetType for more variety
                    const dayType = sunsetType % 8;
                    switch(dayType) {
                        case 0: // Classic blue
                            skyColor = `hsl(${200 + timeOfDay * 60}, 70%, ${70 - timeOfDay * 30}%)`;
                            break;
                        case 1: // Bright azure
                            skyColor = `hsl(${205 + timeOfDay * 55}, 75%, ${72 - timeOfDay * 28}%)`;
                            break;
                        case 2: // Soft sky blue
                            skyColor = `hsl(${195 + timeOfDay * 65}, 68%, ${73 - timeOfDay * 32}%)`;
                            break;
                        case 3: // Clear cerulean
                            skyColor = `hsl(${210 + timeOfDay * 50}, 72%, ${71 - timeOfDay * 29}%)`;
                            break;
                        case 4: // Gentle cyan
                            skyColor = `hsl(${190 + timeOfDay * 58}, 66%, ${74 - timeOfDay * 31}%)`;
                            break;
                        case 5: // Crisp blue
                            skyColor = `hsl(${208 + timeOfDay * 52}, 74%, ${69 - timeOfDay * 27}%)`;
                            break;
                        case 6: // Serene sky
                            skyColor = `hsl(${198 + timeOfDay * 62}, 69%, ${72 - timeOfDay * 30}%)`;
                            break;
                        case 7: // Pure blue
                            skyColor = `hsl(${202 + timeOfDay * 56}, 71%, ${70 - timeOfDay * 28}%)`;
                            break;
                    }
                }
            } else {
                skyColor = `hsl(${260 - (timeOfDay - 1) * 60}, 70%, ${40 - (timeOfDay - 1) * 20}%)`;
            }

            // Create smooth gradient instead of solid color for more natural sky
            const skyGradient = ctx.createLinearGradient(0, -canvas.height, 0, canvas.height * GROUND_HEIGHT_RATIO);

            // Top of sky (darker/more saturated)
            skyGradient.addColorStop(0, skyColor);

            // Middle transition (slightly lighter)
            const middleColor = skyColor.replace(/(\d+)%\)$/, (match, p1) => {
                return `${Math.min(100, parseInt(p1) + 10)}%)`;
            });
            skyGradient.addColorStop(0.5, middleColor);

            // Bottom of sky near horizon (lighter/less saturated for atmospheric perspective)
            const horizonColor = skyColor.replace(/(\d+)%, (\d+)%\)$/, (match, p1, p2) => {
                return `${Math.max(0, parseInt(p1) - 15)}%, ${Math.min(100, parseInt(p2) + 15)}%)`;
            });
            skyGradient.addColorStop(1, horizonColor);

            ctx.fillStyle = skyGradient;
            // FIXED: Extend sky to cover entire canvas even when camera is zoomed/panned
            // Draw a much larger rectangle to prevent whitespace when locked on
            ctx.fillRect(-canvas.width, -canvas.height, canvas.width * 3, canvas.height * GROUND_HEIGHT_RATIO * 3);

            // Mushroom mode sky effects
            if (mushroomMode) {
                const currentTime = Date.now();
                if (currentTime - lastColorCycleUpdate > 100) {
                    lastColorCycleUpdate = currentTime;

                    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    const time = currentTime / 1000;
                    for (let i = 0; i < 6; i++) {
                        const hue = (time * 20 + i * 60) % 360;
                        gradient.addColorStop(i / 5, `hsla(${hue}, 100%, 70%, 0.1)`);
                    }

                    ctx.fillStyle = gradient;
                    // FIXED: Extend for camera zoom
                    ctx.fillRect(-canvas.width, -canvas.height, canvas.width * 3, canvas.height * GROUND_HEIGHT_RATIO * 3);

                    for (let i = 0; i < 3; i++) {
                        const circleX = (canvas.width / 3) * (i + 1) + Math.sin(time + i) * 100;
                        const circleY = canvas.height * 0.3 + Math.cos(time * 0.7 + i) * 50;
                        const radius = 30 + Math.sin(time * 0.5 + i * 2) * 15;

                        const circleGradient = ctx.createRadialGradient(
                            circleX, circleY, 0,
                            circleX, circleY, radius
                        );

                        circleGradient.addColorStop(0, `hsla(${(time * 30 + i * 120) % 360}, 100%, 70%, 0.2)`);
                        circleGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = circleGradient;
                        ctx.beginPath();
                        ctx.arc(circleX, circleY, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            
            // Draw stars at night
            if (timeOfDay >= 1 && !isRaining && cloudCover < 0.5) {
                ctx.fillStyle = 'white';
                stars.forEach(star => {
                    // Adjust opacity based on cloud cover
                    const opacity = 1 - (cloudCover * 2);
                    if (opacity > 0) {
                        ctx.globalAlpha = opacity;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
            }

            // FIXED: Hide sun/moon during eclipse
            if (!eclipse) {
                // Draw sun or moon
                if (timeOfDay < 1 && cloudCover < 0.7) {
                    // Sun
                    const sunX = canvas.width * 0.8;
                    const sunY = canvas.height * 0.2;
                    const sunRadius = 30;

                    // Adjust sun glow based on cloud cover
                    const sunOpacity = 1 - cloudCover;

                    // Sun glow
                    const gradient = ctx.createRadialGradient(
                        sunX, sunY, sunRadius * 0.5,
                        sunX, sunY, sunRadius * 2
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 0, ${sunOpacity})`);
                    gradient.addColorStop(1, `rgba(255, 255, 0, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, sunRadius * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Sun core
                    ctx.fillStyle = `rgba(255, 255, 0, ${sunOpacity})`;
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (timeOfDay >= 1 && cloudCover < 0.7) {
                    // Moon
                    ctx.fillStyle = `rgba(220, 220, 220, ${0.8 - cloudCover})`;
                    ctx.beginPath();
                    ctx.arc(canvas.width * 0.2, canvas.height * 0.2, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw cloud cover if present
            if (cloudCover > 0) {
                // Draw varying cloud layers
                for (let i = 0; i < 3; i++) {
                    const cloudY = canvas.height * GROUND_HEIGHT_RATIO * 0.2 * (i * 0.4 + 0.5);
                    const cloudOpacity = cloudCover * (0.4 - i * 0.1);
                    
                    ctx.fillStyle = isThundering ? 
                        `rgba(60, 60, 80, ${cloudOpacity})` : 
                        `rgba(90, 90, 100, ${cloudOpacity})`;
                    
                    for (let j = 0; j < 4; j++) {
                        const cloudWidth = canvas.width * 0.4;
                        const cloudX = ((j * canvas.width / 3) + i * 50) % canvas.width;
                        
                        ctx.beginPath();
                        ctx.ellipse(
                            cloudX, cloudY, 
                            cloudWidth / 2, 
                            canvas.height * 0.05, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }

        // Draw ground layer - called AFTER camera transform so it moves with everything else
        function drawGround() {
            // Calculate ground position in world coordinates
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            const groundColor = isRaining ? '#7AC552' : (puddles.length > 0 ? '#88DD77' : '#90EE90');

            // Calculate the visible world bounds accounting for camera zoom and offset
            // We need to draw ground that covers the entire visible canvas after transformation
            const worldVisibleWidth = canvas.width / cameraZoom;
            const worldVisibleHeight = canvas.height / cameraZoom;

            // Calculate world position of top-left corner of visible area
            const worldLeft = -cameraOffsetX / cameraZoom;
            const worldTop = -cameraOffsetY / cameraZoom;

            // Draw ground with generous margins to prevent any gaps
            const marginX = worldVisibleWidth * 2; // Extra margin on sides
            const marginY = worldVisibleHeight * 2; // Extra margin below

            ctx.fillStyle = groundColor;
            ctx.fillRect(
                worldLeft - marginX,
                groundY,
                worldVisibleWidth + marginX * 2,
                worldVisibleHeight + marginY
            );
        }


        // Modified drawCurtains to do nothing
        function drawCurtains() {
            return; // Skip drawing curtains
        }

        // Draw debug visuals
        function drawDebugVisuals() {
            if (!debugVisuals) return;
            
            // Draw bird paths
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.lineWidth = 1;
            
            birds.forEach(bird => {
                if (bird.path && bird.path.length > 0) {
                    // Draw path from current position to next waypoint
                    if (bird.pathIndex < bird.path.length) {
                        ctx.beginPath();
                        ctx.moveTo(bird.x, bird.y);
                        ctx.lineTo(bird.path[bird.pathIndex].x, bird.path[bird.pathIndex].y);
                        ctx.stroke();
                        
                        // Draw the rest of the path
                        ctx.beginPath();
                        for (let i = bird.pathIndex; i < bird.path.length - 1; i++) {
                            ctx.moveTo(bird.path[i].x, bird.path[i].y);
                            ctx.lineTo(bird.path[i+1].x, bird.path[i+1].y);
                        }
                        ctx.stroke();
                        
                        // Draw waypoints
                        ctx.fillStyle = 'yellow';
                        for (let i = bird.pathIndex; i < bird.path.length; i++) {
                            ctx.beginPath();
                            ctx.arc(bird.path[i].x, bird.path[i].y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Highlight current waypoint
                        ctx.fillStyle = 'orange';
                        ctx.beginPath();
                        ctx.arc(bird.path[bird.pathIndex].x, bird.path[bird.pathIndex].y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });

            // Draw FPS counter in top-left corner
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform to draw in screen space
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            // Color code based on FPS
            let fpsColor = '#00FF00'; // Green for good
            if (currentFPS < 30) fpsColor = '#FFFF00'; // Yellow for warning
            if (currentFPS < 20) fpsColor = '#FF0000'; // Red for critical

            // Draw background
            const fpsText = `FPS: ${currentFPS}`;
            const textWidth = ctx.measureText(fpsText).width;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 50, textWidth + 10, 25);

            // Draw FPS text
            ctx.fillStyle = fpsColor;
            ctx.fillText(fpsText, 15, 55);

            // Draw entity count
            const entityCount = birds.length + babyBirds.length + squirrels.length +
                                rats.length + owls.length + crows.length + butterflies.length +
                                worms.length + foodItems.length + trees.length;
            const entityText = `Entities: ${entityCount}`;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 80, ctx.measureText(entityText).width + 10, 25);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(entityText, 15, 85);

            ctx.restore();
        }

        // Enhanced: Draw bird interaction UI (hover labels and lock-on effects)
        function drawBirdInteractionUI() {
            // Draw hover label for adult birds
            if (hoveredBird) {
                const birdName = getBirdName(hoveredBird);
                const birdType = hoveredBird.birdType.name;
                const labelText = `${birdName} (${birdType})`;

                // Position label above bird
                const labelX = hoveredBird.x;
                const labelY = hoveredBird.y - 40;

                // Measure text for background sizing
                ctx.font = 'bold 14px Arial';
                const textMetrics = ctx.measureText(labelText);
                const padding = 8;
                const bgWidth = textMetrics.width + padding * 2;
                const bgHeight = 20;

                // Draw background with high contrast
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                // Draw border for visibility
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                // Draw text in high-contrast color
                ctx.fillStyle = '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, labelX, labelY);

                // Draw slight highlight circle around hovered bird
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(hoveredBird.x, hoveredBird.y, 25, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw hover label for baby birds
            if (hoveredBabyBird) {
                const hungerLevel = Math.max(0, 100 - (hoveredBabyBird.timeSinceLastMeal / 4.2));
                const labelText = `Baby ${hoveredBabyBird.birdType.name} (Hunger: ${Math.round(hungerLevel)}%, Age: ${Math.round(hoveredBabyBird.age)}s, Fed: ${hoveredBabyBird.feedCount}x)`;

                // Position label above baby bird
                const labelX = hoveredBabyBird.x;
                const labelY = hoveredBabyBird.y - 30;

                // Measure text for background sizing
                ctx.font = 'bold 13px Arial';
                const textMetrics = ctx.measureText(labelText);
                const padding = 8;
                const bgWidth = textMetrics.width + padding * 2;
                const bgHeight = 20;

                // Draw background with high contrast
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                // Draw border for visibility
                ctx.strokeStyle = 'rgba(255, 200, 200, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                // Draw text in high-contrast color
                ctx.fillStyle = '#FFE0E0'; // Slight pink for baby birds
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, labelX, labelY);

                // Draw slight highlight circle around hovered baby bird
                ctx.strokeStyle = 'rgba(255, 200, 200, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(hoveredBabyBird.x, hoveredBabyBird.y, 15, 0, Math.PI * 2);
                ctx.stroke();
            }

            // FIXED: Draw hover info for trees with 10-second timeout
            if (hoveredTree && hoveredTreeStartTime > 0) {
                // Check if timeout has elapsed (10 seconds)
                const elapsed = Date.now() - hoveredTreeStartTime;
                if (elapsed < TREE_HOVER_TIMEOUT) {
                    const treeName = getTreeName(hoveredTree);
                    const healthPercent = Math.round(hoveredTree.health);
                    const ageDays = Math.round(hoveredTree.age / dayNightDuration);
                    const labelText = `${treeName} (HP: ${healthPercent}%, Age: ${ageDays} days)`;

                    // Position label above tree crown
                    const labelX = hoveredTree.x;
                    const labelY = hoveredTree.y - hoveredTree.trunkHeight - hoveredTree.leafRadius - 20;

                // Measure text for background sizing
                ctx.font = 'bold 14px Arial';
                const textMetrics = ctx.measureText(labelText);
                const padding = 8;
                const bgWidth = textMetrics.width + padding * 2;
                const bgHeight = 20;

                // Draw background with high contrast
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                // Draw border for visibility
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                // Draw text in high-contrast color
                ctx.fillStyle = '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, labelX, labelY);

                    // Draw slight highlight circle around hovered tree crown
                    ctx.strokeStyle = 'rgba(100, 255, 100, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(hoveredTree.x, hoveredTree.y - hoveredTree.trunkHeight, hoveredTree.leafRadius * hoveredTree.scale + 10, 0, Math.PI * 2);
                    ctx.stroke();
                } // End timeout check
            } // End hoveredTree check

            // Draw locked animal indicator and follow camera
            if (lockedAnimal && lockedAnimalType) {
                // Check if animal still exists
                let animalExists = false;
                if (lockedAnimalType === 'bird') {
                    animalExists = birds.includes(lockedAnimal);
                } else if (lockedAnimalType === 'squirrel') {
                    animalExists = squirrels.includes(lockedAnimal);
                } else if (lockedAnimalType === 'rat') {
                    animalExists = rats.includes(lockedAnimal);
                } else if (lockedAnimalType === 'crow') {
                    animalExists = crows.includes(lockedAnimal);
                } else if (lockedAnimalType === 'owl') {
                    animalExists = owls.includes(lockedAnimal);
                } else if (lockedAnimalType === 'tree') {
                    animalExists = trees.includes(lockedAnimal);
                } else if (lockedAnimalType === 'frog') {
                    animalExists = frogs.includes(lockedAnimal);
                } else if (lockedAnimalType === 'koi') {
                    animalExists = koi.includes(lockedAnimal);
                } else if (lockedAnimalType === 'ant') {
                    animalExists = ants.includes(lockedAnimal);
                }

                if (animalExists) {
                    // Calculate fade opacity based on time locked
                    const timeLocked = Date.now() - lockedAnimalTime;
                    let fadeOpacity = 1.0;
                    if (timeLocked > LOCKED_UI_FADE_TIME) {
                        const fadeTime = 2000; // 2 seconds to fade out
                        const fadeProgress = Math.min((timeLocked - LOCKED_UI_FADE_TIME) / fadeTime, 1);
                        fadeOpacity = 1.0 - fadeProgress;
                    }

                    // Only draw UI if not fully faded
                    if (fadeOpacity > 0) {
                        // Get current action for display
                        const entityAction = getReadableAction(lockedAnimal.state, lockedAnimalType);

                        // Draw name label with action (e.g., "Alex the Sparrow is Collecting")
                        const baseName = getAnimalName(lockedAnimal, lockedAnimalType);
                        const labelText = `${baseName} is ${entityAction}`;
                        const labelX = lockedAnimal.x;

                        // Position label BELOW creature to avoid overlapping with bars
                        let labelY;
                        if (lockedAnimalType === 'tree') {
                            // Position below tree base (at ground level)
                            labelY = lockedAnimal.y + 30;
                        } else {
                            // For animals, position below them
                            labelY = lockedAnimal.y + 50;
                        }

                        ctx.font = 'bold 16px Arial';
                        const textMetrics = ctx.measureText(labelText);
                        const padding = 10;
                        const bgWidth = textMetrics.width + padding * 2;
                        const bgHeight = 24;

                        // Draw locked background (blue tint) with fade
                        ctx.fillStyle = `rgba(50, 100, 200, ${0.9 * fadeOpacity})`;
                        ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                        ctx.strokeStyle = `rgba(100, 150, 255, ${0.8 * fadeOpacity})`;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(labelX - bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);

                        ctx.fillStyle = `rgba(255, 255, 255, ${fadeOpacity})`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(labelText, labelX, labelY);

                        // Draw bright highlight around locked animal (centered on entity)
                        let highlightY, highlightRadius;
                        if (lockedAnimalType === 'tree') {
                            // Center highlight on tree's crown
                            highlightY = lockedAnimal.y - lockedAnimal.trunkHeight;
                            highlightRadius = lockedAnimal.leafRadius + 10;
                        } else {
                            highlightY = lockedAnimal.y;
                            highlightRadius = 30;
                        }

                        ctx.strokeStyle = `rgba(100, 150, 255, ${0.8 * fadeOpacity})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(lockedAnimal.x, highlightY, highlightRadius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Pulsing effect
                        const pulseSize = highlightRadius + Math.sin(Date.now() / 200) * 5;
                        ctx.strokeStyle = `rgba(100, 150, 255, ${0.3 * fadeOpacity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(lockedAnimal.x, highlightY, pulseSize, 0, Math.PI * 2);
                        ctx.stroke();

                    // Draw health/hunger bars and current action
                    const barWidth = 100;
                    const barHeight = 8;
                    const barX = lockedAnimal.x - barWidth / 2;
                    // Position bars above the entity (independent of label position)
                    let barY;
                    if (lockedAnimalType === 'tree') {
                        barY = lockedAnimal.y - lockedAnimal.trunkHeight - lockedAnimal.leafRadius - 40;
                    } else {
                        barY = lockedAnimal.y - 65;
                    }

                    // Get entity stats
                    let health = 100;
                    let hunger = 0;
                    let currentAction = "Unknown";

                    if (lockedAnimalType === 'bird') {
                        // Calculate health based on hunger (max hunger is 800, so divide by 8)
                        health = Math.max(0, 100 - (lockedAnimal.hunger / 8));
                        hunger = lockedAnimal.hunger || 0;
                        currentAction = getReadableAction(lockedAnimal.state, lockedAnimalType);
                    } else if (lockedAnimalType === 'squirrel') {
                        health = lockedAnimal.health || 100;
                        hunger = lockedAnimal.hunger || 0;
                        currentAction = getReadableAction(lockedAnimal.state, lockedAnimalType);
                    } else if (lockedAnimalType === 'rat') {
                        health = lockedAnimal.health || 100;
                        hunger = lockedAnimal.hunger || 0;
                        currentAction = getReadableAction(lockedAnimal.state, lockedAnimalType);
                    } else if (lockedAnimalType === 'tree') {
                        health = lockedAnimal.health || 100;
                        hunger = -1; // Trees don't have hunger
                        const ageInDays = (lockedAnimal.age / 1000 / 60 / 60 / 24).toFixed(1); // Convert ms to days
                        currentAction = `Growing (${ageInDays} days)`;
                    } else if (lockedAnimalType === 'crow') {
                        health = 100;
                        hunger = 0;
                        currentAction = getReadableAction(lockedAnimal.state, lockedAnimalType);
                    } else if (lockedAnimalType === 'owl') {
                        health = 100;
                        hunger = 0;
                        currentAction = getReadableAction(lockedAnimal.state, lockedAnimalType);
                    } else if (lockedAnimalType === 'frog') {
                        health = 100;
                        hunger = -1; // Frogs don't have hunger display
                        currentAction = lockedAnimal.jumping ? "Jumping" : (lockedAnimal.tongueOut ? "Catching" : "Resting");
                    } else if (lockedAnimalType === 'koi') {
                        health = 100;
                        hunger = -1; // Koi don't have hunger display
                        currentAction = "Swimming";
                    } else if (lockedAnimalType === 'ant') {
                        health = 100;
                        hunger = -1; // Ants don't have hunger display
                        currentAction = lockedAnimal.state === 'returningWithFood' ? "Carrying Food" : "Exploring";
                    }

                        // Action is already shown in name label above, no need to show it here

                        // Draw health bar
                        ctx.fillStyle = `rgba(0, 0, 0, ${0.6 * fadeOpacity})`;
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        const healthPercent = Math.max(0, Math.min(100, health)) / 100;
                        const healthColor = healthPercent > 0.5 ? `rgba(76, 175, 80, ${fadeOpacity})` : (healthPercent > 0.25 ? `rgba(255, 193, 7, ${fadeOpacity})` : `rgba(244, 67, 54, ${fadeOpacity})`);
                        ctx.fillStyle = healthColor;
                        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * fadeOpacity})`;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(barX, barY, barWidth, barHeight);

                        // Health label
                        ctx.font = '10px Arial';
                        ctx.fillStyle = `rgba(255, 255, 255, ${fadeOpacity})`;
                        ctx.textAlign = 'left';
                        ctx.fillText('HP', barX - 20, barY + 6);

                        // Draw hunger bar (if applicable)
                        if (hunger >= 0) {
                            barY += barHeight + 4;

                            ctx.fillStyle = `rgba(0, 0, 0, ${0.6 * fadeOpacity})`;
                            ctx.fillRect(barX, barY, barWidth, barHeight);

                            // Max hunger is 800 for birds, scale to percentage
                            const hungerPercent = Math.max(0, Math.min(100, (hunger / 800) * 100)) / 100;
                            const hungerColor = hungerPercent < 0.5 ? `rgba(76, 175, 80, ${fadeOpacity})` : (hungerPercent < 0.75 ? `rgba(255, 193, 7, ${fadeOpacity})` : `rgba(244, 67, 54, ${fadeOpacity})`);
                            ctx.fillStyle = hungerColor;
                            ctx.fillRect(barX, barY, barWidth * hungerPercent, barHeight);

                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * fadeOpacity})`;
                            ctx.lineWidth = 1;
                            ctx.strokeRect(barX, barY, barWidth, barHeight);

                            // Hunger label
                            ctx.fillStyle = `rgba(255, 255, 255, ${fadeOpacity})`;
                            ctx.textAlign = 'left';
                            ctx.fillText('üçΩÔ∏è', barX - 20, barY + 6);
                        }
                    }
                } else {
                    // Animal was removed, clear lock
                    lockedAnimal = null;
                    lockedAnimalType = null;
                }
            }
        }

        // V26: Enhanced Nest class with deterioration system
        class Nest {
            constructor(tree, x, y) {
                this.tree = tree;
                this.treeId = tree ? tree.id : null; // Store tree ID for resize tracking
                this.x = x;
                this.y = y;

                // FIX: Store offset from tree for proper resizing
                if (tree) {
                    this.offsetX = x - tree.x; // Store horizontal offset from tree center
                    this.heightRatio = 0.8; // Store as ratio instead of absolute (80% up the trunk)
                } else {
                    this.offsetX = 0;
                    this.heightRatio = 0.8;
                }

                this.materialsCollected = 0;
                this.isComplete = false;
                this.occupiedBy = null;
                this.health = 100;
                this.condition = 100;  // Tracks physical condition of nest (100 = perfect)
                this.deteriorationRate = 0.005;  // Base rate of deterioration per second
                this.lastMaintenanceTime = Date.now(); // Track last time maintenance was performed
                this.needsMaintenance = false; // Flag for when nest needs attention
                this.maintenanceThreshold = 60; // Below this condition, nest needs repair
                this.failureThreshold = 20; // Below this condition, nest becomes incomplete
                this.ratOccupied = false; // Track if a rat has taken over
                this.readyForBabies = false; // Explicit flag for baby creation
                this.lastBabyTime = 0; // Track when the last baby was born
                this.lastOccupiedTime = Date.now(); // Track when nest was last occupied
                this.abandonedDegradationMultiplier = 1.0; // Multiplier for abandoned nests




                // Generate fixed angles for twigs for consistency
                this.twigAngles = [];
                for (let i = 0; i < NEST_MATERIALS_NEEDED; i++) {
                    this.twigAngles.push({
                        angle: (i / NEST_MATERIALS_NEEDED) * Math.PI + Math.PI / 8 * Math.sin(i * 2),
                        length: 5 + Math.random() * 10,
                        offset: Math.random() * 0.2
                    });
                }
            }

            addMaterial() {
                this.materialsCollected++;
                
                if (this.materialsCollected >= NEST_MATERIALS_NEEDED && !this.isComplete) {
                    this.isComplete = true;
                    this.readyForBabies = true;
                    this.condition = 100; // Reset condition when newly completed
                    debugLog(`Nest at (${this.x}, ${this.y}) is complete! Ready for babies!`);

                    // Add diary entry for first few nests
                    if (nests.filter(n => n.isComplete).length <= 3) {
                        if (nests.filter(n => n.isComplete).length === 1) {
                            addDiaryEntry("The first nest is complete! New life awaits.", 'nest');
                        } else {
                            addDiaryEntry("Another nest completed. The garden family grows.", 'nest');
                        }
                    }
                }
                
                // Repair functionality - improve condition when maintained
                if (this.isComplete && this.condition < 100) {
                    this.condition = Math.min(100, this.condition + 25); // Significant repair
                    this.lastMaintenanceTime = Date.now();
                    this.needsMaintenance = false;
                    debugLog(`Nest at (${this.x}, ${this.y}) maintained. New condition: ${this.condition.toFixed(1)}%`);
                }
                
                return this.isComplete;
            }

            damage(amount) {
                // Birds defend their nests
                if (this.occupiedBy && Math.random() < 0.7) {
                    // 70% chance a bird defends its nest
                    amount *= 0.3; // Reduce damage by 70%
                    debugLog("Bird defended nest from attack!");
                }

                this.health -= amount;

                // Also affect condition
                this.condition = Math.max(0, this.condition - amount);
                this.checkCondition();



                if (this.health <= 0) {
                    this.isComplete = false;
                    this.materialsCollected = Math.floor(this.materialsCollected / 2);
                    this.health = 50;

                    // FIXED: Make ALL baby birds fall when nest is destroyed
                    const babiesInNest = babyBirds.filter(baby =>
                        baby.associatedNest === this || distance(baby.x, baby.y, this.x, this.y) < 20
                    );

                    for (const baby of babiesInNest) {
                        baby.startFalling();
                        debugLog(`Baby bird falling from destroyed nest!`);
                    }

                    // FIXED: Make ALL eggs fall when nest is destroyed
                    const eggsInNest = eggs.filter(egg =>
                        egg.associatedNest === this || distance(egg.x, egg.y, this.x, this.y) < 20
                    );

                    for (const egg of eggsInNest) {
                        egg.startFalling();
                        debugLog(`Egg falling from destroyed nest!`);
                    }

                    if (this.occupiedBy) {
                        this.occupiedBy.myNest = null;
                        this.occupiedBy = null;
                    }
                    return true; // Nest was damaged significantly
                }
                return false;}


                
            
            update(deltaTime) {
                if (!this.isComplete) return;
                
                // Calculate deterioration based on various factors
                let deteriorationAmount = this.deteriorationRate * (deltaTime / 1000);
                
                // Weather accelerates deterioration
                if (isRaining) {
                    deteriorationAmount *= 2.5; // Rain accelerates deterioration
                }
                
                // Seasonal factors
                const season = Math.floor((dayNightCycleCount % 80) / 20); // 0=spring, 1=summer, 2=fall, 3=winter
                if (season === 3) { // Winter
                    deteriorationAmount *= 1.5; // Harsh winter weather
                }
                
                // Track occupancy and adjust degradation for abandoned nests
                if (this.occupiedBy) {
                    deteriorationAmount *= 0.5; // Halve deterioration if occupied
                    this.lastOccupiedTime = Date.now(); // Update last occupied time
                    this.abandonedDegradationMultiplier = 1.0; // Reset multiplier

                    // Occasional minor repairs when occupied
                    if (Math.random() < 0.01 * (deltaTime / 1000)) {
                        this.condition = Math.min(100, this.condition + 1);
                        debugLog(`Bird made minor repairs to nest at (${this.x}, ${this.y})`);
                    }
                } else {
                    // Check how long nest has been abandoned
                    const timeSinceOccupied = Date.now() - this.lastOccupiedTime;
                    const daysAbandoned = timeSinceOccupied / (dayNightDuration * 0.5); // Game days

                    // Increase degradation multiplier for long-abandoned nests
                    if (daysAbandoned > 1) {
                        // After 1 day: 2x degradation
                        // After 2 days: 3x degradation
                        // After 3+ days: 4x degradation
                        this.abandonedDegradationMultiplier = Math.min(4, 1 + daysAbandoned);
                        deteriorationAmount *= this.abandonedDegradationMultiplier;
                    }
                }

                // Reduce condition
                this.condition = Math.max(0, this.condition - deteriorationAmount);
                
                // Check if condition crossed any thresholds
                this.checkCondition();
            }
            
            checkCondition() {
                // Check if condition dropped below maintenance threshold
                if (this.condition < this.maintenanceThreshold && !this.needsMaintenance) {
                    this.needsMaintenance = true;
                    if (this.occupiedBy) {
                        debugLog(`Nest at (${this.x}, ${this.y}) needs maintenance (${this.condition.toFixed(1)}%)`);
                    }
                }
                
                // Check if condition dropped below failure threshold
                if (this.condition < this.failureThreshold && this.isComplete) {
                    this.isComplete = false;
                    this.materialsCollected = Math.floor(NEST_MATERIALS_NEEDED / 2); // Nest partially collapses
                    this.readyForBabies = false;
                    debugLog(`Nest at (${this.x}, ${this.y}) has collapsed due to poor condition!`);

                    // FIXED: ALL baby birds fall from collapsed nest (was 25% chance, now 100%)
                    const babiesInNest = babyBirds.filter(baby =>
                        baby.associatedNest === this || distance(baby.x, baby.y, this.x, this.y) < 20
                    );

                    for (const baby of babiesInNest) {
                        // Baby falls from collapsed nest
                        baby.startFalling();
                        debugLog(`Baby bird falling from collapsed nest!`);
                    }

                    // FIXED: ALL eggs fall from collapsed nest
                    const eggsInNest = eggs.filter(egg =>
                        egg.associatedNest === this || distance(egg.x, egg.y, this.x, this.y) < 20
                    );

                    for (const egg of eggsInNest) {
                        egg.startFalling();
                        debugLog(`Egg falling from collapsed nest!`);
                    }

                    // Alert occupying bird
                    if (this.occupiedBy) {
                        this.occupiedBy.myNest = null; // Bird loses connection to nest
                        this.occupiedBy = null;
                    }
                }
            }
            
            checkReadyForNewBabies(currentTime) {
                // If the nest has already had a baby and enough time has passed
                if (!this.readyForBabies && this.lastBabyTime > 0 && 
                    this.isComplete && this.condition > 70 &&
                    currentTime - this.lastBabyTime > 120000) { // 2 minutes
                    
                    this.readyForBabies = true;
                    this.lastBabyTime = 0;
                    debugLog(`Nest at (${this.x}, ${this.y}) ready for new babies!`);
                }
            }

            draw() {
                const completionRatio = this.materialsCollected / NEST_MATERIALS_NEEDED;
                const nestSize = 15 + completionRatio * 15;

                // FIXED: Removed parallax offset - nests stay fixed with trees in world space
                // Trees no longer use parallax, so nests shouldn't either

                // Base of the nest - color varies with condition
                const conditionRatio = Math.max(0, this.condition / 100);
                const baseColor = this.ratOccupied ? '#966F33' : '#8B4513'; // Base color when good condition
                
                // Mix with gray as condition worsens
                const r1 = parseInt(baseColor.slice(1, 3), 16);
                const g1 = parseInt(baseColor.slice(3, 5), 16);
                const b1 = parseInt(baseColor.slice(5, 7), 16);
                
                const r2 = 100; // Gray color
                const g2 = 100;
                const b2 = 100;
                
                // Interpolate between base color and gray based on condition
                const r = Math.round(r1 * conditionRatio + r2 * (1 - conditionRatio));
                const g = Math.round(g1 * conditionRatio + g2 * (1 - conditionRatio));
                const b = Math.round(b1 * conditionRatio + b2 * (1 - conditionRatio));
                
                const nestColor = `rgb(${r}, ${g}, ${b})`;

                ctx.fillStyle = nestColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, nestSize, 0, Math.PI);
                ctx.fill();
                
                // Add detail to the nest based on completion and condition
                if (completionRatio > 0.2) {
                    // Twigs look more chaotic as condition worsens
                    const disarray = (1 - conditionRatio) * 0.5;
                    
                    ctx.strokeStyle = '#6B3E10';
                    ctx.lineWidth = 2;
                    
                    // Draw twigs sticking out with fixed angles
                    const twigCount = Math.min(
                        Math.floor(completionRatio * this.twigAngles.length),
                        this.twigAngles.length
                    );
                    
                    // Ensure twigAngles exists and has elements
                    if (Array.isArray(this.twigAngles) && this.twigAngles.length > 0) {
                        for (let i = 0; i < twigCount; i++) {
                            // Skip if index out of bounds
                            if (i >= this.twigAngles.length) continue;
                            
                            const twigInfo = this.twigAngles[i];
                            // Skip if twigInfo is undefined or missing required properties
                            if (!twigInfo || typeof twigInfo.angle !== 'number' || 
                                typeof twigInfo.length !== 'number') continue;
                            
                            // Add more random deviation to angle if nest is in disrepair
                            const disorderFactor = Math.random() * disarray * 0.4;
                            const angle = twigInfo.angle + disorderFactor + 
                                (twigInfo.offset || 0) * Math.sin(Date.now() / 8000);
                            
                            ctx.beginPath();
                            ctx.moveTo(
                                this.x + nestSize * Math.cos(angle),
                                this.y + nestSize * Math.sin(angle) * 0.5
                            );
                            ctx.lineTo(
                                this.x + (nestSize + twigInfo.length) * Math.cos(angle),
                                this.y + (nestSize + twigInfo.length) * Math.sin(angle) * 0.5
                            );
                            ctx.stroke();

                            // Some twigs appear loose in poor condition nests
                            if (this.condition < 50 && Math.random() < 0.3) {
                                ctx.beginPath();
                                const looseX = this.x + (nestSize + twigInfo.length * 0.6) * Math.cos(angle);
                                const looseY = this.y + (nestSize + twigInfo.length * 0.6) * Math.sin(angle) * 0.5;
                                const fallAngle = angle + (Math.random() - 0.5) * 0.5;

                                ctx.moveTo(looseX, looseY);
                                ctx.lineTo(
                                    looseX + twigInfo.length * 0.4 * Math.cos(fallAngle),
                                    looseY + twigInfo.length * 0.4 * Math.sin(fallAngle)
                                );
                                ctx.stroke();
                            }
                        }
                    }
                }
                
                // Draw the inner part of the nest
                if (this.isComplete) {
                    // Inner nest color also affected by condition
                    const innerColor = this.ratOccupied ? 
                        `rgba(${Math.round(184*conditionRatio + 120*(1-conditionRatio))}, ${Math.round(134*conditionRatio + 120*(1-conditionRatio))}, ${Math.round(11*conditionRatio + 120*(1-conditionRatio))}, 1)` : 
                        `rgba(${Math.round(205*conditionRatio + 150*(1-conditionRatio))}, ${Math.round(167*conditionRatio + 150*(1-conditionRatio))}, ${Math.round(125*conditionRatio + 150*(1-conditionRatio))}, 1)`;
                    
                    ctx.fillStyle = innerColor;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, nestSize * 0.7, 0, Math.PI);
                    ctx.fill();
                    
                    // Draw rat in nest if occupied by one
                    if (this.ratOccupied) {
                        // Rat's eyes peeking out
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(this.x - 5, this.y - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(this.x + 5, this.y - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Add visual cues for nest condition
                    if (this.condition < this.maintenanceThreshold) {
                        // Add loose threads/materials for nests needing repair
                        ctx.strokeStyle = '#6B3E10';
                        ctx.lineWidth = 1;
                        
                        const looseCount = Math.floor((this.maintenanceThreshold - this.condition) / 10) + 1;
                        for (let i = 0; i < looseCount; i++) {
                            const angle = Math.random() * Math.PI;
                            const radius = nestSize * (0.2 + Math.random() * 0.5);
                            
                            ctx.beginPath();
                            ctx.moveTo(this.x + Math.cos(angle) * radius, this.y + Math.sin(angle) * radius * 0.5);
                            ctx.lineTo(
                                this.x + Math.cos(angle) * (radius + 5 + Math.random() * 5),
                                this.y + Math.sin(angle) * (radius + 5 + Math.random() * 5) * 0.5
                            );
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw debug health if enabled
                if (debugVisuals) {
                    // Health bar
                    ctx.fillStyle = this.health > 70 ? 'green' : (this.health > 30 ? 'orange' : 'red');
                    ctx.fillRect(this.x - 15, this.y - 25, 30 * (this.health / 100), 3);
                    
                    // Condition bar
                    ctx.fillStyle = this.condition > 70 ? 'blue' : (this.condition > 30 ? 'yellow' : 'red');
                    ctx.fillRect(this.x - 15, this.y - 30, 30 * (this.condition / 100), 3);
                    
                    if (this.ratOccupied) {
                        ctx.fillStyle = 'white';
                        ctx.font = '8px Arial';
                        ctx.fillText('Rat!', this.x - 10, this.y - 15);
                    }
                    
                    // Show ready for babies status
                    if (this.readyForBabies) {
                        ctx.fillStyle = 'yellow';
                        ctx.font = '8px Arial';
                        ctx.fillText('Ready!', this.x - 15, this.y - 35);
                    }
                    
                    // Show needs maintenance
                    if (this.needsMaintenance) {
                        ctx.fillStyle = 'orange';
                        ctx.font = '8px Arial';
                        ctx.fillText('Repair!', this.x - 15, this.y - 40);
                    }
                }
            }
        }
        
        // V26: Fixed Birdhouse class with properly shown top half
        class Birdhouse {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.materialsCollected = 0;
                this.isComplete = false;
                this.health = 100;
                this.occupants = [];
                this.maxOccupants = 2;
                
                // House properties
                this.width = 35;
                this.height = 40;
                this.roofHeight = 15;
                this.entranceSize = 10;
                this.poleHeight = 50; // Increased from 30 to ensure visibility
                
                // Randomly determine color scheme
                const colorSchemes = [
                    { body: '#D35400', roof: '#6C3483', trim: '#F1C40F' },  // Orange/Purple
                    { body: '#2980B9', roof: '#C0392B', trim: '#ECF0F1' },  // Blue/Red
                    { body: '#1E8449', roof: '#7D3C98', trim: '#F39C12' },  // Green/Purple
                    { body: '#A04000', roof: '#1B4F72', trim: '#D4AC0D' },  // Brown/Blue
                    { body: '#7D6608', roof: '#186A3B', trim: '#E74C3C' }   // Mustard/Green
                ];
                this.colors = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];
                
                // Generate slight variation in dimensions
                this.width *= 0.9 + Math.random() * 0.2;
                this.height *= 0.9 + Math.random() * 0.2;
                this.entranceSize *= 0.9 + Math.random() * 0.2;
            }
            
            addMaterial() {
                this.materialsCollected++;
                if (this.materialsCollected >= BIRDHOUSE_MATERIALS_NEEDED && !this.isComplete) {
                    this.isComplete = true;
                    debugLog(`Birdhouse at (${this.x}, ${this.y}) is complete!`);
                }
                return this.isComplete;
            }
            
            damage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    return true; // Birdhouse was destroyed
                }
                return false;
            }
            
            canAcceptOccupant() {
                return this.isComplete && this.occupants.length < this.maxOccupants;
            }
            
            addOccupant(bird) {
                if (this.canAcceptOccupant()) {
                    this.occupants.push(bird);
                    return true;
                }
                return false;
            }
            
            removeOccupant(bird) {
                const index = this.occupants.indexOf(bird);
                if (index !== -1) {
                    this.occupants.splice(index, 1);
                    return true;
                }
                return false;
            }
            
            draw() {
                // Don't draw if beamed up by UFO
                if (this.beamedUp) return;

                // Fixed drawing order to ensure all parts are visible

                // Draw glow effect if glowing (returned by UFO)
                if (this.glowing) {
                    if (!this.glowPhase) this.glowPhase = 0;
                    this.glowPhase += 0.02;
                    const glowIntensity = (Math.sin(this.glowPhase) + 1) / 2;

                    ctx.save();
                    const glowGradient = ctx.createRadialGradient(
                        this.x, this.y - this.poleHeight / 2, 0,
                        this.x, this.y - this.poleHeight / 2, 60
                    );
                    glowGradient.addColorStop(0, `rgba(100, 255, 100, ${0.4 * glowIntensity})`);
                    glowGradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - this.poleHeight / 2, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Draw support pole - proper connection fixed
                ctx.fillStyle = '#8B4513';
                const poleWidth = 6;
                const poleX = this.x - poleWidth/2;
                const poleBottom = this.y;
                const poleTop = this.y - this.poleHeight;
                
                // Draw the pole connected to both ground and birdhouse
                ctx.fillRect(
                    poleX, 
                    poleTop, // Top of pole connects to birdhouse
                    poleWidth, 
                    this.poleHeight // Full height to ground
                );
                
                // Position for the house components
                const houseBottom = poleTop;
                
                if (!this.isComplete) {
                    // Draw partially built birdhouse
                    const completionRatio = this.materialsCollected / BIRDHOUSE_MATERIALS_NEEDED;
                    
                    if (completionRatio > 0.3) {
                        // Draw partial house body
                        const partialHeight = this.height * Math.min(1, completionRatio * 1.5);
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(
                            this.x - this.width/2, 
                            houseBottom - partialHeight,
                            this.width * completionRatio,
                            partialHeight
                        );
                    }
                    
                    if (completionRatio > 0.7) {
                        // Draw partial roof
                        const roofCompletionRatio = (completionRatio - 0.7) * 3.33; // Scale to 0-1
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.moveTo(this.x - this.width/2 - 5, houseBottom - this.height);
                        ctx.lineTo(this.x + this.width/2 * roofCompletionRatio, houseBottom - this.height);
                        ctx.lineTo(this.x, houseBottom - this.height - this.roofHeight * roofCompletionRatio);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else {
                    // Draw completed birdhouse
                    
                    // House body
                    ctx.fillStyle = this.colors.body;
                    ctx.fillRect(
                        this.x - this.width/2, 
                        houseBottom - this.height,
                        this.width,
                        this.height
                    );
                    
                    // Roof - draw this after body to ensure it's visible
                    ctx.fillStyle = this.colors.roof;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width/2 - 5, houseBottom - this.height);
                    ctx.lineTo(this.x + this.width/2 + 5, houseBottom - this.height);
                    ctx.lineTo(this.x, houseBottom - this.height - this.roofHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Entrance hole
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(
                        this.x, 
                        houseBottom - this.height + this.height * 0.3,
                        this.entranceSize/2,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Perch stick
                    ctx.fillStyle = this.colors.trim;
                    ctx.fillRect(
                        this.x - this.entranceSize/2,
                        houseBottom - this.height + this.height * 0.3 + this.entranceSize/2,
                        this.entranceSize,
                        2
                    );
                    
                    // Decorative trimming
                    ctx.fillStyle = this.colors.trim;
                    ctx.fillRect(
                        this.x - this.width/2,
                        houseBottom - this.height * 0.2,
                        this.width,
                        3
                    );
                }
                
                // Draw debug health if enabled
                if (debugVisuals) {
                    // Health bar
                    ctx.fillStyle = this.health > 70 ? 'green' : (this.health > 30 ? 'orange' : 'red');
                    ctx.fillRect(
                        this.x - 15, 
                        houseBottom - this.height - this.roofHeight - 10, 
                        30 * (this.health / 100), 
                        3
                    );
                    
                    // Show occupancy
                    if (this.isComplete) {
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.font = '10px Arial';
                        ctx.fillText(
                            `${this.occupants.length}/${this.maxOccupants}`,
                            this.x - 8,
                            houseBottom - this.height - this.roofHeight - 15
                        );
                    }
                }
            }
        }

        // NEW: Egg class for incubation stage before baby birds
        class Egg {
            constructor(x, y, birdType, nestObj = null) {
                this.x = x;
                this.y = y;
                this.birdType = birdType || BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];
                this.nestObj = nestObj;
                this.createdOnDay = dayNightCycleCount; // Track which in-game day the egg was laid
                this.cyclesToHatch = 1 + Math.random(); // 1-2 in-game day cycles (4-8 minutes real-time)
                this.size = 8; // Egg size
                this.wobbleTimer = Math.random() * Math.PI * 2; // For subtle animation
                this.color = '#F5F5DC'; // Beige/cream color

                // Track if this egg has a parent sitting on it
                this.beingIncubated = false;
                this.associatedNest = nestObj;

                // Falling state for when nest/tree is destroyed
                this.isFalling = false;
                this.fallVelocity = 0;
                this.fallStartY = 0; // Track where fall started for break calculation
                this.broken = false;
            }

            update(deltaTime) {
                this.wobbleTimer += deltaTime * 0.001;

                // Handle falling eggs
                if (this.isFalling) {
                    // Apply gravity
                    this.fallVelocity += GRAVITY * (deltaTime / 16);
                    this.y += this.fallVelocity * (deltaTime / 16);

                    // Check for ground collision
                    const groundLevel = canvas.height * GROUND_HEIGHT_RATIO;
                    if (this.y >= groundLevel - 10) {
                        this.y = groundLevel - 10;
                        this.isFalling = false;
                        this.associatedNest = null; // No longer in a nest

                        // Calculate fall distance to determine if egg breaks
                        const fallDistance = this.y - this.fallStartY;

                        // Eggs have a chance to break based on fall height
                        // 0-50px: 0% break chance (very low fall)
                        // 50-100px: 30% break chance (medium fall)
                        // 100-200px: 60% break chance (high fall)
                        // 200+px: 90% break chance (very high fall)
                        let breakChance = 0;
                        if (fallDistance < 50) {
                            breakChance = 0;
                        } else if (fallDistance < 100) {
                            breakChance = 0.3;
                        } else if (fallDistance < 200) {
                            breakChance = 0.6;
                        } else {
                            breakChance = 0.9;
                        }

                        if (Math.random() < breakChance) {
                            this.broken = true;
                            debugLog(`Egg broke from ${fallDistance.toFixed(0)}px fall! (${(breakChance*100).toFixed(0)}% chance)`);
                            return true; // Should be removed
                        } else {
                            debugLog(`Egg survived ${fallDistance.toFixed(0)}px fall! Now on ground.`);
                        }
                    }
                }
                // Update position to match nest if it has one and not falling
                else if (this.associatedNest && this.associatedNest.tree) {
                    this.x = this.associatedNest.x;
                    this.y = this.associatedNest.y;
                }

                // Check if ready to hatch (don't hatch if broken)
                // Use in-game day cycles for hatching
                const cyclesElapsed = dayNightCycleCount - this.createdOnDay;
                if (!this.broken && cyclesElapsed >= this.cyclesToHatch) {
                    return true;
                }

                return false;
            }

            draw() {
                // Draw egg with subtle speckles
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size * 0.7, this.size, 0, 0, Math.PI * 2);
                ctx.fill();

                // Add speckles
                ctx.fillStyle = 'rgba(139, 90, 43, 0.3)';
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const speckleX = this.x + Math.cos(angle) * this.size * 0.3;
                    const speckleY = this.y + Math.sin(angle) * this.size * 0.4;
                    ctx.beginPath();
                    ctx.arc(speckleX, speckleY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Subtle wobble near hatching time (when 80% through incubation)
                const cyclesElapsed = dayNightCycleCount - this.createdOnDay;
                if (cyclesElapsed > this.cyclesToHatch * 0.8) {
                    const wobble = Math.sin(this.wobbleTimer * 4) * 1;
                    ctx.save();
                    ctx.translate(wobble, 0);
                    ctx.restore();
                }
            }

            startFalling() {
                this.isFalling = true;
                this.fallVelocity = 0.5; // Initial fall velocity
                this.fallStartY = this.y; // Record starting height for break calculation
                this.associatedNest = null; // Detach from nest
                debugLog(`Egg falling from height ${this.y.toFixed(0)}`);
            }
        }

        // V26: Enhanced BabyBird class with gentler bobbing
        class BabyBird {
    constructor(x, y, birdType, nestObj = null) {
        this.x = x;
        this.y = y;
        this.age = 0;
        this.timeSinceLastMeal = 0;
        this.feedCount = 0;
        this.birdType = birdType || BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];
        this.size = 6;
        this.bobTimer = 0;
        this.bobSpeed = 0.05 + Math.random() * 0.02; // Reduced from 0.1 + Math.random() * 0.05
        this.associatedNest = nestObj; // Store reference to associated nest
        this.isFalling = false; // New falling state flag
        this.fallVelocity = 0; // New velocity for falling
    }

    update(deltaTime) {
    // Slower, gentler bobbing
    this.bobTimer += this.bobSpeed * deltaTime;
    
    this.age += deltaTime / 1000;
    this.timeSinceLastMeal += deltaTime / 1000;
    
    // Baby birds grow if fed regularly - fewer feedings required
    if (this.feedCount >= 6 && this.age > 45) { // Reduced from 8 feeds and 60 seconds
        debugLog(`Baby bird at (${this.x}, ${this.y}) matured into an adult.`);
        birds.push(new Bird(false, this.birdType, this.x, this.y));
        
        // Increment the babies born counter
        totalBabiesBorn++;

        // FIXED: Create a flower NEAR the tree (not directly under) where the baby matured
        const flowerOffsetX = (Math.random() - 0.5) * 100; // Random offset ¬±50px horizontally
        createFlower(this.x + flowerOffsetX, this.y);

            // Reset the nest to be ready for new babies after a delay
            if (this.associatedNest) {
                this.associatedNest.lastBabyTime = Date.now();
                setTimeout(() => {
                    this.associatedNest.readyForBabies = true;
                    debugLog(`Nest at (${this.associatedNest.x}, ${this.associatedNest.y}) ready for new babies!`);
                }, 60000); // One minute cooldown before new babies
            }
                        
            return true; // Should be removed
        }
        
        // Baby birds die if not fed for longer
        if (this.timeSinceLastMeal > 420) { // Increased from 120
            debugLog(`Baby bird at (${this.x}, ${this.y}) died from lack of food after ${this.timeSinceLastMeal.toFixed(0)} seconds.`);
            return true; // Should be removed
        }
        
        // Handle falling baby birds
        if (this.isFalling) {
            // Apply gravity
            this.fallVelocity += GRAVITY * (deltaTime / 16);
            this.y += this.fallVelocity * (deltaTime / 16);
            
            // Check for ground collision
            if (this.y >= canvas.height * GROUND_HEIGHT_RATIO - 10) {
                this.y = canvas.height * GROUND_HEIGHT_RATIO - 10;
                this.isFalling = false;
                this.associatedNest = null; // No longer in a nest
                debugLog(`Baby bird landed on ground`);
            }
        }
        
        return false;
    }
    
    feed() {
        this.feedCount += 1; // Increased from 0.5 - faster growth
        this.timeSinceLastMeal = 0;
        this.size = Math.min(11, 6 + this.feedCount * 0.5);
        debugLog(`Baby bird fed! Feed count: ${this.feedCount}`);
    }

    startFalling() {
        this.isFalling = true;
        this.fallVelocity = 0.5; // Initial fall velocity
        this.y += 20; // Move down initially
        this.timeSinceLastMeal += 20; // Stress makes them hungrier
        debugLog(`Baby bird falling because tree was removed`);
    }

    draw() {
        // More gentle bobbing with reduced amplitude
        const bobAmount = Math.sin(this.bobTimer) * 1.5; // Reduced from 3
        // Get colors based on bird type
        let bodyColor = this.birdType.bodyColor + '88'; // Lighter version with transparency
        let bellyColor = this.birdType.bellyColor + '88';
        
        // Extra fluffy body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        
        // Draw a fluffier, rounder body
        const baseSize = this.size * 1.2;
        ctx.arc(this.x, this.y + bobAmount, baseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Add some fuzzy edges to simulate baby feathers
        ctx.fillStyle = bodyColor;
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const fuzzX = this.x + Math.cos(angle) * baseSize * 0.9;
            const fuzzY = this.y + bobAmount + Math.sin(angle) * baseSize * 0.9;
            const fuzzSize = baseSize * 0.4;
            
            ctx.beginPath();
            ctx.arc(fuzzX, fuzzY, fuzzSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Belly
        ctx.fillStyle = bellyColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y + baseSize * 0.3 + bobAmount, baseSize * 0.7, 0, Math.PI);
        ctx.fill();
        
        // Extra large beak that opens and closes
        ctx.fillStyle = '#FFAA55';
        ctx.beginPath();
        
        const beakOpenAmount = (Math.sin(this.bobTimer / 300) + 1) * 2.5;
        const beakWidth = baseSize * 0.7;
        
        // Triangular beak that opens and closes
        ctx.moveTo(this.x, this.y + bobAmount);
        ctx.lineTo(this.x + beakWidth, this.y - beakOpenAmount + bobAmount);
        ctx.lineTo(this.x + beakWidth, this.y + beakOpenAmount + bobAmount);
        ctx.fill();
        
        // Inside of mouth
        ctx.fillStyle = '#FF9999';
        ctx.beginPath();
        ctx.moveTo(this.x + beakWidth * 0.3, this.y + bobAmount);
        ctx.lineTo(this.x + beakWidth * 0.8, this.y - beakOpenAmount * 0.7 + bobAmount);
        ctx.lineTo(this.x + beakWidth * 0.8, this.y + beakOpenAmount * 0.7 + bobAmount);
        ctx.fill();
        
        // Big, cute eyes with highlights
        ctx.fillStyle = 'black';
        const eyeSize = baseSize * 0.3;
        ctx.beginPath();
        ctx.arc(this.x - baseSize * 0.3, this.y - baseSize * 0.2 + bobAmount, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlights
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - baseSize * 0.25, this.y - baseSize * 0.25 + bobAmount, eyeSize * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Show feeding info if debugging
        if (debugVisuals) {
            ctx.fillStyle = this.timeSinceLastMeal > 60 ? 'red' : 'green';
            ctx.fillRect(this.x - baseSize, this.y - baseSize - 8 + bobAmount, 
                       baseSize * 2 * (this.feedCount / 6), 3); // Changed from 8 to 6
                       
            // Show feedCount
            ctx.fillStyle = 'white';
            ctx.font = '8px Arial';
            ctx.fillText(`F:${this.feedCount.toFixed(1)}`, this.x - baseSize, this.y - baseSize - 15 + bobAmount);
            
            // Show falling status if applicable
            if (this.isFalling) {
                ctx.fillStyle = 'red';
                ctx.fillText('Falling!', this.x - baseSize, this.y - baseSize - 25 + bobAmount);
            }
        }
    }
}




        // Spawn birds - Birds spawn off-screen now and limited by MAX_BIRDS
        // Modify the spawnBird function
function spawnBird() {
    if (birds.length < MAX_BIRDS) {
        const newBird = new Bird();
        
        // Choose a random edge to fly in from
        const edges = [
            { side: 'top', x: Math.random() * canvas.width, y: -30 },
            { side: 'right', x: canvas.width + 30, y: Math.random() * canvas.height * 0.7 },
            { side: 'bottom', x: Math.random() * canvas.width, y: canvas.height + 30 },
            { side: 'left', x: -30, y: Math.random() * canvas.height * 0.7 }
        ];
        
        const edge = edges[Math.floor(Math.random() * edges.length)];
        newBird.x = edge.x;
        newBird.y = edge.y;
        
        // Set initial state to flying and generate path to center
        newBird.state = BIRD_STATES.FLYING;
        const targetX = canvas.width / 2;
        const targetY = canvas.height / 2;
        newBird.generatePath(targetX, targetY);
        
        birds.push(newBird);
        debugLog(`Bird spawned from ${edge.side} edge at (${newBird.x}, ${newBird.y})`);
    }
}
        
        // Wild bird spawn
        function spawnWildBird() {
            // Spawn wild birds with smoother entry
            if (Math.random() < WILD_BIRD_SPAWN_CHANCE) {
                const wildBird = new Bird(true); // true = wild bird
                
                // More varied entry points
                const entryOptions = [
                    { side: 'left', x: -30, y: Math.random() * canvas.height * 0.6, dir: 1 },
                    { side: 'right', x: canvas.width + 30, y: Math.random() * canvas.height * 0.6, dir: -1 },
                    { side: 'top', x: Math.random() * canvas.width, y: -30, dir: Math.random() < 0.5 ? -1 : 1 }
                ];
                
                // Choose a random entry point
                const entry = entryOptions[Math.floor(Math.random() * entryOptions.length)];
                
                wildBird.x = entry.x;
                wildBird.y = entry.y;
                wildBird.direction = entry.dir;
                
                // Better initial velocity
                wildBird.velocity.x = wildBird.direction * wildBird.baseSpeed * 1.5;
                wildBird.velocity.y = entry.side === 'top' ? wildBird.baseSpeed * 0.5 : (Math.random() - 0.5) * wildBird.baseSpeed;
                
                // First visible point inside screen
                const firstVisibleX = entry.side === 'left' ? 50 : (entry.side === 'right' ? canvas.width - 50 : entry.x);
                const firstVisibleY = entry.side === 'top' ? 50 : entry.y;
                
                // Mid-garden point with some randomness
                const midX = canvas.width/2 + (Math.random() - 0.5) * canvas.width/3;
                const midY = canvas.height * 0.3 + Math.random() * canvas.height * 0.2;
                
                // Exit point
                const exitSide = entry.side === 'left' ? 'right' : (entry.side === 'right' ? 'left' : (Math.random() < 0.5 ? 'left' : 'right'));
                const exitX = exitSide === 'left' ? -30 : canvas.width + 30;
                const exitY = Math.random() * canvas.height * 0.6;
                
                // Create path with additional control points for arcing
                wildBird.path = [
                    { x: entry.x, y: entry.y },                // Starting off-screen
                    { x: firstVisibleX, y: firstVisibleY },    // First visible point
                    { x: (firstVisibleX + midX) / 2,           // Control point 1
                      y: Math.min(firstVisibleY, midY) - 20 },
                    { x: midX, y: midY },                      // Mid-garden point
                    { x: (midX + exitX) / 2,                   // Control point 2
                      y: Math.min(midY, exitY) - 20 },
                    { x: exitX, y: exitY }                     // Exit point
                ];
                
                wildBird.pathIndex = 0;
                wildBird.state = BIRD_STATES.FLYING;
                
                birds.push(wildBird);
                debugLog(`Wild bird visiting from ${entry.side} with natural path`);
            }
            
            // Add rare flock behavior
            if (dayNightCycleCount > 0 && dayNightCycleCount % 3 === 0 && 
                timeOfDay < 0.3 && Math.random() < 0.1) {
                // Spawn a flock of 3-5 birds
                const flockSize = 3 + Math.floor(Math.random() * 3);
                const flockType = BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];
                const startSide = Math.random() < 0.5 ? "left" : "right";
                const direction = startSide === "left" ? 1 : -1;
                const startX = startSide === "left" ? -30 : canvas.width + 30;
                const startY = canvas.height * 0.3 + Math.random() * canvas.height * 0.2;
                
                for (let i = 0; i < flockSize; i++) {
                    // Create birds of the same type with similar paths
                    const wildBird = new Bird(true, flockType);
                    
                    // Set formation position with slight variation
                    wildBird.x = startX;
                    wildBird.y = startY + (i - flockSize/2) * 15; 
                    wildBird.direction = direction;
                    
                    // Set initial velocity
                    wildBird.velocity.x = direction * wildBird.baseSpeed * 2;
                    wildBird.velocity.y = (Math.random() - 0.5) * wildBird.baseSpeed * 0.5;
                    
                    // Generate path with slight variations
                    const midX = canvas.width/2 + (Math.random() - 0.5) * 50;
                    const midY = canvas.height * 0.3 + (i - flockSize/2) * 20;
                    
                    const exitX = direction === 1 ? canvas.width + 30 : -30;
                    const exitY = startY + (i - flockSize/2) * 15;
                    
                    // Use improved path with more control points for natural flight
                    wildBird.path = [
                        { x: wildBird.x, y: wildBird.y },    // Starting position
                        { x: startX + direction * 100, y: wildBird.y }, // Entry point
                        { x: midX, y: midY },                // Mid point
                        { x: (midX + exitX)/2, y: (midY + exitY)/2 - 20 }, // Control point
                        { x: exitX, y: exitY }               // Exit point
                    ];
                    
                    wildBird.pathIndex = 0;
                    wildBird.state = BIRD_STATES.FLYING;
                    
                    birds.push(wildBird);
                }
                
                debugLog(`A flock of ${flockSize} ${flockType.name}s is visiting!`);
            }
        }

        function checkAndAlertForHungryBabies() {
            // Find hungry babies that haven't been fed for a while
            const hungryBabies = babyBirds.filter(baby => baby.timeSinceLastMeal > 30); // Reduced from 60
            
            // Alert birds for each hungry baby
            for (const baby of hungryBabies) {
                alertBirdsToFeedBaby(baby);
                debugLog(`Alerting birds about hungry baby at (${baby.x}, ${baby.y})`);
            }
        }

        // Helper function to alert birds to feed babies
        function alertBirdsToFeedBaby(babyBird) {
            // Find birds that aren't currently busy with critical tasks
            const availableBirds = birds.filter(bird => 
                !bird.isWild && 
                bird.state !== BIRD_STATES.BUILDING && 
                bird.state !== BIRD_STATES.COLLECTING &&
                bird.state !== BIRD_STATES.FLEEING
            );
            
            // If there are available birds, direct one to feed the baby
            if (availableBirds.length > 0) {
                // Choose closest bird
                availableBirds.sort((a, b) => {
                    const distA = distance(a.x, a.y, babyBird.x, babyBird.y);
                    const distB = distance(b.x, b.y, babyBird.x, babyBird.y);
                    return distA - distB;
                });
                
                // Try to assign parent bird if baby is in a nest
                let assignedBird = null;
                if (babyBird.associatedNest && babyBird.associatedNest.occupiedBy) {
                    assignedBird = babyBird.associatedNest.occupiedBy;
                } else {
                    // Otherwise assign closest bird
                    assignedBird = availableBirds[0];
                }
                
                // Set bird to hunting state targeting the baby bird
                assignedBird.target = {
                    type: 'baby',
                    x: babyBird.x,
                    y: babyBird.y,
                    baby: babyBird
                };
                assignedBird.state = BIRD_STATES.HUNTING;
                assignedBird.stateTimer = 0;
                
                // Have bird find food first if it doesn't have any
                if (assignedBird.hunger > 200) {
                    assignedBird.findFoodSource();
                }
                
                debugLog(`Bird directed to feed baby bird`);
            }
        }

       // Find your existing resetStuckBirds function and ADD the tree-stuck detection inside of it:

// V26: Less frequent stuck bird detection with gentler handling 
function resetStuckBirds() {
    const groundY = canvas.height * GROUND_HEIGHT_RATIO;
    let stuckBirdsFixed = 0;
    const maxFixesPerFrame = 3; // Reduced from 5 to be more gentle
    
    for (let i = 0; i < birds.length && stuckBirdsFixed < maxFixesPerFrame; i++) {
        const bird = birds[i];

        // V40 CRITICAL FIX: Define stationary state check at loop level for reuse
        const isStationaryState = bird.state === BIRD_STATES.PERCHED ||
                                 bird.state === BIRD_STATES.RESTING ||
                                 bird.state === BIRD_STATES.HOPPING ||
                                 bird.state === BIRD_STATES.FEEDING ||
                                 bird.state === BIRD_STATES.PECKING ||
                                 bird.state === BIRD_STATES.SLEEPING;

        // Initialize or update last position tracking
        if (!bird.lastPosition) {
            bird.lastPosition = { x: bird.x, y: bird.y };
            bird.stuckTime = 0;
        } else {
            const dist = distance(bird.x, bird.y, bird.lastPosition.x, bird.lastPosition.y);

            // Check if bird is stuck (not moving)
            if (dist < 1 && !isStationaryState) {
                bird.stuckTime = (bird.stuckTime || 0) + 16;
                
                // Special treatment for off-screen birds
                const isOffScreen = bird.x < -20 || bird.x > canvas.width + 20 || 
                                    bird.y < -20 || bird.y > canvas.height + 20;
                
                // More aggressive unsticking for birds in known problem areas
                const inProblemArea = problemAreas.some(area => 
                    Math.abs(bird.x - area.x) < area.radius
                );
                
                // Increase stuck time thresholds - birds get more time before being unstuck
                const stuckThreshold = inProblemArea ? 300 : (isOffScreen ? 600 : 1000); // Increased thresholds
                
                if (bird.stuckTime > stuckThreshold) {
                    // Gentler unsticking action
                    // 1. Reset bird state but maintain direction
                    bird.state = BIRD_STATES.FLYING;
                    bird.target = null;
                    bird.stateTimer = 0;
                    bird.stuckTime = 0;
                    
                    // 2. Gently modify velocity to break patterns without jarring changes
                    bird.velocity = { 
                        x: bird.velocity.x * 0.3 + (Math.random() - 0.5) * 0.2,
                        y: bird.velocity.y * 0.3 - 0.05  // Slight upward bias
                    };
                    
                    // 3. Generate path to safe area (away from problem areas)
                    const safeX = findSafeX(problemAreas);
                    const safeY = 100 + Math.random() * (canvas.height * 0.3);
                    
                    bird.generatePath(safeX, safeY);
                    
                    // 4. Drop any held materials
                    if (bird.materialsHeld > 0) {
                        twigs.push({
                            x: bird.x,
                            y: groundY + Math.random() * 10,
                            size: 10 + Math.random() * 8,
                            angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                            isSpecial: bird.hasSpecialTwig,
                            offshoots: []
                        });
                        bird.materialsHeld = 0;
                        bird.hasSpecialTwig = false;
                    }
                    
                    stuckBirdsFixed++;
                    debugLog(`Gentle unstick for bird at (${bird.x}, ${bird.y})`);
                }
            } else {
                // Bird is moving, update last position
                bird.lastPosition = { x: bird.x, y: bird.y };
                // Reduce stuck time more rapidly when moving
                bird.stuckTime = Math.max(0, bird.stuckTime - 64); // Doubled reduction rate
            }
        }
        
        // TREE STUCK DETECTION - ADD THIS SECTION
        // Only check some birds each frame for performance (10% chance)
        if (Math.random() < 0.1) {
            // V40 CRITICAL FIX: Skip ALL stationary states (not just perched/building/resting)
            if (!isStationaryState && bird.state !== BIRD_STATES.BUILDING) {
                
                try {
                    // Check if the bird is between two tree trunks
                    let treesToLeft = 0;
                    let treesToRight = 0;
                    
                    // Count trees on left and right with simple approach
                    for (const tree of trees) {
                        if (Math.abs(bird.x - tree.x) < tree.trunkWidth * 2) {
                            if (tree.x < bird.x) treesToLeft++;
                            if (tree.x > bird.x) treesToRight++;
                        }
                    }
                    
                    // If trees on both sides and bird is already showing stuck behavior
                    if (treesToLeft > 0 && treesToRight > 0 && bird.stuckTime > 300) {
                        // Apply gentle escape velocity
                        bird.velocity.y = -0.5; // Up
                        
                        // Choose escape direction
                        if (treesToLeft > treesToRight) {
                            bird.velocity.x = 0.5; // Right
                            bird.direction = 1;
                        } else {
                            bird.velocity.x = -0.5; // Left
                            bird.direction = -1;
                        }
                        
                        bird.state = BIRD_STATES.FLYING;
                        bird.stateTimer = 0;
                        
                        stuckBirdsFixed++;
                        debugLog(`Bird freed from between trees at (${bird.x}, ${bird.y})`);
                    }
                } catch (e) {
                    // Safely ignore any errors without breaking main loop
                    console.error("Error in tree stuck detection:", e);
                }
            }
        }
        // END OF TREE STUCK DETECTION ADDITION
        
        // Check if bird is stuck near a tree - much gentler approach
        const nearbyTree = trees.find(tree => 
            distance(bird.x, bird.y, tree.x, tree.y - tree.trunkHeight/2) < 70
        );

        if (nearbyTree && bird.stuckTime > 500) { // Increased threshold for tree-related stuckness
            // V40 FIX: Stronger push away from tree to prevent repeated sticking
            const dirX = bird.x < nearbyTree.x ? -1 : 1;
            bird.applyForce({
                x: dirX * 0.15, // Increased from 0.08 for stronger push
                y: -0.08 // Increased from -0.04 for more upward movement
            });

            // Only reset state if clearly stuck
            if (bird.stuckTime > 800) {
                bird.state = BIRD_STATES.FLYING;
                bird.stateTimer = 0;

                // V40 FIX: Generate path MUCH farther away to prevent immediate return
                const targetX = bird.x + dirX * 200; // Increased from 80
                const targetY = bird.y - 80; // Increased from 30
                bird.generatePath(targetX, targetY);

                bird.stuckTime = 0;
                stuckBirdsFixed++;
                debugLog(`Gentle push for bird stuck near tree at (${bird.x}, ${bird.y}) - sending to (${targetX}, ${targetY})`);
            }
        }
        
        // Enhanced stasis detection with more patience and zoom-aware thresholds
        if (bird.path && bird.path.length > 0 && bird.pathIndex < bird.path.length) {
            const waypoint = bird.path[bird.pathIndex];
            const waypointDist = distance(bird.x, bird.y, waypoint.x, waypoint.y);

            // ENHANCED: Zoom-aware "stuck" detection threshold
            const responsiveScale = getResponsiveScale();
            const stuckThreshold = 2 * responsiveScale; // Scale with zoom level

            if (bird.lastWaypointDist && Math.abs(bird.lastWaypointDist - waypointDist) < stuckThreshold && bird.stateTimer > 2000) {
                bird.waypointStuckTime = (bird.waypointStuckTime || 0) + 16;

                // Make waypoint skipping more patient and zoom-aware
                if (bird.waypointStuckTime > 600) { // Increased from 400 for more patience
                    // Skip to next waypoint
                    bird.pathIndex++;
                    bird.waypointStuckTime = 0;
                    
                    // Apply small push in the direction of movement
                    if (bird.pathIndex < bird.path.length) {
                        const nextWaypoint = bird.path[bird.pathIndex];
                        const dx = nextWaypoint.x - bird.x;
                        const dy = nextWaypoint.y - bird.y;
                        const dir = normalize(dx, dy);
                        
                        bird.applyForce({ 
                            x: dir.x * 0.05, // Reduced from 0.1
                            y: dir.y * 0.05  // Reduced from 0.1
                        });
                    }
                    // If no more waypoints, find new state
                    else {
                        bird.state = BIRD_STATES.FLYING;
                        bird.stateTimer = 0;
                        
                        // Choose a new target
                        const targetX = 100 + Math.random() * (canvas.width - 200);
                        const targetY = 100 + Math.random() * (canvas.height * 0.5 - 100);
                        bird.generatePath(targetX, targetY);
                    }
                    
                    stuckBirdsFixed++;
                    debugLog(`Bird gently led past stuck waypoint`);
                }
            } else {
                bird.lastWaypointDist = waypointDist;
                bird.waypointStuckTime = 0;
            }
        }
    }
}

  // Draw worms with wiggle
function drawWorms() {
    worms.forEach(worm => {
        worm.wiggle += WORM_WIGGLE_SPEED * 0.1;
        
        // Base worm body - night worms can be a slightly different color
        ctx.fillStyle = worm.isNightWorm ? '#BC8866' : '#AA7755'; // Night worms are slightly lighter
        
        // Draw segmented worm body
        const segments = 5;
        const segmentLength = worm.size / segments;
        
        for (let i = 0; i < segments; i++) {
            const wiggleOffset = Math.sin(worm.wiggle + i * 0.5) * 3;
            
            ctx.beginPath();
            ctx.arc(
                worm.x + wiggleOffset, 
                worm.y + i * segmentLength * 0.5, 
                segmentLength * (1 - i * 0.1), 
                0, Math.PI * 2
            );
            ctx.fill();
        }
    });
}

        // Draw twigs on ground
        function drawTwigs() {
            twigs.forEach((twig) => {
                // Check if twig is in a pond - if so, flatten it for frogs to use
                let isInPond = false;
                let adjustedAngle = twig.angle;

                // Initialize float phase if not present
                if (!twig.floatPhase) {
                    twig.floatPhase = Math.random() * Math.PI * 2;
                }

                for (const pond of ponds) {
                    const distToPond = Math.sqrt(
                        Math.pow(twig.x - pond.x, 2) +
                        Math.pow(twig.y - (pond.y + pond.height), 2)
                    );
                    if (distToPond < pond.width) {
                        isInPond = true;
                        // FIXED: Save pond angle only once to prevent shaking
                        if (!twig.pondAngle) {
                            twig.pondAngle = (Math.random() - 0.5) * Math.PI * 0.2; // Nearly horizontal
                        }
                        adjustedAngle = twig.pondAngle;
                        break;
                    }
                }

                // FIXED: Gentle floating animation for branches on pond
                let floatOffsetY = 0;
                if (isInPond) {
                    twig.floatPhase += 0.002; // MUCH slower phase increment
                    floatOffsetY = Math.sin(twig.floatPhase) * 1.5; // Gentle 1.5px bobbing
                }

                ctx.save();
                ctx.translate(twig.x, twig.y + floatOffsetY);
                ctx.rotate(adjustedAngle);

                // Draw branch - color differently if it's a special twig
                if (twig.isSpecial) {
                    // Special twigs have a slight glow and lighter color
                    ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#D2B48C'; // Lighter wood color
                } else {
                    ctx.fillStyle = '#8B4513';
                }
                
                ctx.fillRect(-2, -2, twig.size, 4);
                
                // Draw fixed offshoots
                if (!twig.offshoots) {
                    twig.offshoots = [];
                    for (let i = 0; i < 3; i++) {
                        twig.offshoots.push({
                            position: Math.random() * twig.size,
                            length: 2 + Math.random() * 4,
                            angle: (Math.random() - 0.5) * Math.PI / 2
                        });
                    }
                }
                
                // Draw the pre-calculated offshoots
                twig.offshoots.forEach(offshoot => {
                    ctx.save();
                    ctx.translate(offshoot.position, 0);
                    ctx.rotate(offshoot.angle);
                    ctx.fillRect(0, 0, offshoot.length, 1);
                    ctx.restore();
                });
                
                ctx.restore();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Add special indicator for special twigs
                if (twig.isSpecial && debugVisuals) {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.arc(twig.x, twig.y - 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Draw bird poops with falling animation (smaller sizes)
        function drawBirdPoops(deltaTime) {
            // Limit bird poops for performance
            if (birdPoops.length > MAX_BIRD_POOPS) {
                // Remove oldest poops (sorted by timer)
                birdPoops.sort((a, b) => b.timer - a.timer);
                birdPoops.splice(MAX_BIRD_POOPS);
            }
            
            for (let i = birdPoops.length - 1; i >= 0; i--) {
                const poop = birdPoops[i];
                poop.timer += deltaTime;
                
                // Handle falling animation until ground is reached
                if (!poop.grounded) {
                    poop.y += poop.yVelocity * (deltaTime / 16);
                    poop.yVelocity += 0.05 * (deltaTime / 16);

                    // FIX: Check if poop hit another bird before landing on ground
                    for (const bird of birds) {
                        const birdDist = distance(poop.x, poop.y, bird.x, bird.y);
                        if (birdDist < 20 && !poop.hitBird) { // Within 20px of bird
                            poop.hitBird = true;
                            // DON'T stop falling - keep going until ground!

                            // Create emoji conversation between pooper and victim
                            const poopEmojis = ['üí©', 'üò¨', 'üôä', 'üòÖ', 'üò≥'];
                            const victimEmojis = ['üò°', 'üò§', 'ü§¨', 'üò†', 'üí¢'];

                            // Victim reacts angrily
                            startEmojiConversation(bird, [
                                { emoji: victimEmojis[Math.floor(Math.random() * victimEmojis.length)], duration: 2000 }
                            ]);

                            debugLog(`Poop hit bird ${getBirdName(bird)} at (${poop.x}, ${poop.y})!`);

                            // Find who pooped (if still exists and nearby-ish)
                            const nearbyPooper = birds.find(b =>
                                b !== bird &&
                                distance(b.x, b.y, bird.x, bird.y) < 200 &&
                                b.y < bird.y // Above the victim
                            );

                            if (nearbyPooper) {
                                // Pooper reacts embarrassed/apologetic
                                setTimeout(() => {
                                    startEmojiConversation(nearbyPooper, [
                                        { emoji: poopEmojis[Math.floor(Math.random() * poopEmojis.length)], duration: 2000 }
                                    ]);
                                }, 500); // Slight delay for natural back-and-forth
                            }
                            break;
                        }
                    }

                    // Check if poop has hit the ground
                    // Enhanced: allow deeper landing in foreground (below ground surface)
                    const groundLevel = canvas.height * GROUND_HEIGHT_RATIO;
                    const landingDepth = poop.foregroundDepth ? (15 + Math.random() * 25) : 0; // 15-40px deeper
                    if (poop.y >= groundLevel + landingDepth) {
                        poop.y = groundLevel + landingDepth;
                        poop.grounded = true;
                        if (!poop.hitBird) { // Only log if didn't hit a bird
                            debugLog(`Poop landed at (${poop.x}, ${poop.y})`);
                        }
                    }
                }
                
                // Rain washes away poop gradually once on ground
                if (poop.grounded && isRaining) {
                    poop.size -= POOP_WASH_RATE * (deltaTime / 1000);
                }
                
                if (poop.size > 0) {
                    if (poop.grounded) {
                        // Ground poop with splatter - Grey/white tone
                        // Use white with slight grey/green tint for main poop
                        ctx.fillStyle = '#E6E8E6'; // Light grey-white color
                        ctx.beginPath();
                        ctx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add darker center
                        ctx.fillStyle = '#C0C2C0'; // Slightly darker grey
                        ctx.beginPath();
                        ctx.arc(poop.x, poop.y, poop.size * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add splatter effect for grounded poop
                        if (poop.size > 1.5) { // Reduced threshold
                            ctx.fillStyle = 'rgba(200, 205, 200, 0.6)'; // Transparent grey-white
                            
                            // Use consistent splatter pattern
                            const splatSeed = Math.floor(poop.x);
                            for (let i = 0; i < 2; i++) { // Reduced from 3 splats
                                const angle = ((splatSeed * (i + 1)) % 100) / 100 * Math.PI * 2;
                                const distance = poop.size + ((splatSeed * (i + 2)) % 10) / 4;
                                const splatterSize = poop.size * 0.2; // Reduced from 0.3
                                
                                ctx.beginPath();
                                ctx.arc(
                                    poop.x + Math.cos(angle) * distance,
                                    poop.y + Math.sin(angle) * distance,
                                    splatterSize,
                                    0, Math.PI * 2
                                );
                                ctx.fill();
                            }
                        }
                    } else {
                        // Falling poop - white with grey tint
                        // For falling poop, add slight gradient effect
                        const gradient = ctx.createRadialGradient(
                            poop.x, poop.y, 0,
                            poop.x, poop.y, poop.size
                        );
                        gradient.addColorStop(0, '#FFFFFF');
                        gradient.addColorStop(0.5, '#E6E8E6');
                        gradient.addColorStop(1, '#C0C2C0');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Remove poop if too small
                    birdPoops.splice(i, 1);
                }
            }
        }

        // Helper to add branches to trees
        function addBranchToTree(tree) {
            if (!tree.hasBranches) {
                tree.hasBranches = true;
                tree.branches = [];
            }
            
            // Create a new branch with proper upward angle
            const isRightSide = Math.random() > 0.5;
            let branchAngle;
            
            if (isRightSide) {
                // Right side branches point up and right (-œÄ/4 to -œÄ/2)
                branchAngle = -Math.PI/4 - Math.random() * (Math.PI/4);
            } else {
                // Left side branches point up and left (5œÄ/4 to 3œÄ/2)
                branchAngle = (5 * Math.PI)/4 + Math.random() * (Math.PI/4);
            }
            
            const heightPosition = 0.3 + Math.random() * 0.6; // 30% to 90% up the trunk
            
            tree.branches.push({
                height: tree.trunkHeight * heightPosition,
                length: 30 + Math.random() * 40,
                angle: branchAngle,
                thickness: tree.trunkWidth * (0.3 + Math.random() * 0.3)
            });
            debugLog(`New branch added to tree at (${tree.x})`);
        }

        // Tree class
        class Tree {
            constructor(x, trunkWidth, trunkHeight, leafRadius, hasBranches = false) {
                this.id = Math.random().toString(36).substr(2, 9); // Unique ID for naming
                this.x = x;

                // V39: Rare tall tree variant (2% chance - 33% taller!)
                this.isTallVariant = Math.random() < 0.02;
                if (this.isTallVariant) {
                    trunkHeight *= 1.33; // 33% taller
                    trunkWidth *= 1.15; // Slightly thicker trunk
                    leafRadius *= 1.2; // Larger canopy
                    hasBranches = true; // Always has branches
                    debugLog(`üå≤ Rare TALL tree spawned at (${x})! Height: ${trunkHeight.toFixed(0)}`);
                }

                this.trunkWidth = trunkWidth;
                this.trunkHeight = trunkHeight;
                this.leafRadius = leafRadius;
                this.health = 100;
                this.hasBranches = hasBranches;
                this.branches = [];
                this.nest = null;
                this.depth = Math.random(); // 0 = foreground, 1 = background
                this.scale = 1 - this.depth * 0.3; // Scale based on depth (0.7x to 1.0x)
                this.age = Math.random() * (TREE_LIFESPAN * 0.5); // Stagger initial ages

                // Trees should have trunk touching ground, but can vary in depth for foreground effect
                // Foreground trees (depth < 0.3) go deeper into grass for depth perception
                // Background trees stay at or just below the ground line
                const depthOffset = this.depth < 0.3 ? (20 + Math.random() * 40) : (Math.random() * 20);
                this.depthOffset = depthOffset; // Store for resize preservation
                // Position at ground line - trunk will extend upward from here
                this.y = canvas.height * GROUND_HEIGHT_RATIO + depthOffset;

                // Make foreground trees slightly thicker for more depth perception
                if (this.depth < 0.3) {
                    this.trunkWidth *= 1.1;
                    this.leafRadius *= 1.05;
                }
                
                if (hasBranches) {
                    // Tall trees get more branches
                    const baseBranchCount = this.isTallVariant ? 3 : 1;
                    const branchCount = Math.floor(baseBranchCount + Math.random() * 3);
                    for (let i = 0; i < branchCount; i++) {
                        // Determine which side the branch comes out on
                        const isRightSide = Math.random() > 0.5;

                        // FIXED: Avoid vertical/near-vertical branches for more natural look
                        let branchAngle;

                        if (isRightSide) {
                            // Right side branches - avoid vertical (range: -20¬∞ to -70¬∞, avoiding -90¬∞)
                            // -20¬∞ = -œÄ/9, -70¬∞ = -7œÄ/18, range = 50¬∞ = 5œÄ/18
                            branchAngle = -Math.PI/9 - Math.random() * (5 * Math.PI / 18);
                        } else {
                            // Left side branches - avoid vertical (range: 200¬∞ to 250¬∞, avoiding 270¬∞)
                            // 200¬∞ = 10œÄ/9, 250¬∞ = 25œÄ/18, range = 50¬∞ = 5œÄ/18
                            branchAngle = (10 * Math.PI) / 9 + Math.random() * (5 * Math.PI / 18);
                        }

                        // Vary height more naturally along the trunk
                        const heightPosition = 0.3 + Math.random() * 0.6; // 30% to 90% up the trunk

                        this.branches.push({
                            height: this.trunkHeight * heightPosition,
                            // FIXED: More length variation (20-80 instead of 30-70)
                            length: 20 + Math.random() * 60,
                            angle: branchAngle,
                            // FIXED: More thickness variation (0.2-0.7x instead of 0.3-0.6x)
                            thickness: this.trunkWidth * (0.2 + Math.random() * 0.5)
                        });
                    }
                }
            }

            draw() {
                // Apply depth scale
                ctx.save();

                // FIXED: Removed parallax offset - trees should stay fixed in world space
                // The camera transform already handles movement, parallax was causing trees to appear to float

                // Center on tree position (no parallax adjustment needed)
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                // Trunk (drawing relative to 0,0)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.moveTo(-this.trunkWidth / 2, 0);
                ctx.quadraticCurveTo(
                    0, 
                    -this.trunkHeight / 2,
                    0, 
                    -this.trunkHeight
                );
                ctx.quadraticCurveTo(
                    0, 
                    -this.trunkHeight - 10,
                    this.trunkWidth / 2, 
                    -this.trunkHeight
                );
                ctx.lineTo(this.trunkWidth / 2, 0);
                ctx.fill();

                // Branches
                if (this.hasBranches) {
                    this.branches.forEach(branch => {
                        const branchY = -branch.height;
                        
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = branch.thickness;
                        ctx.beginPath();
                        ctx.moveTo(0, branchY);
                        
                        // Calculate endpoint with correct angle
                        const endX = Math.cos(branch.angle) * branch.length;
                        const endY = branchY + Math.sin(branch.angle) * branch.length;
                        
                        // Draw with slight curve for more natural look
                        ctx.bezierCurveTo(
                            endX * 0.3, branchY + (endY - branchY) * 0.2,
                            endX * 0.7, branchY + (endY - branchY) * 0.7,
                            endX, endY
                        );
                        ctx.stroke();
                        
                        // Small leaf clusters on branch tips
                        ctx.fillStyle = '#2E8B57';
                        ctx.beginPath();
                        ctx.arc(endX, endY, this.leafRadius * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Leaves - keep original colors but ensure proper rgb format
                const leafX = 0;
                const leafY = -this.trunkHeight - this.leafRadius;
                
                // Draw main leaf cluster
                ctx.fillStyle = timeOfDay < 1 ? 'rgb(34, 139, 34)' : 'rgb(26, 107, 26)';
                ctx.beginPath();
                ctx.arc(leafX, leafY, this.leafRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw additional leaf clusters for volume
                const clusters = 5;
                for (let i = 0; i < clusters; i++) {
                    const angle = (i / clusters) * Math.PI * 2;
                    const offsetDistance = this.leafRadius * 0.6;
                    const offsetX = Math.cos(angle) * offsetDistance;
                    const offsetY = Math.sin(angle) * offsetDistance;
                    
                    ctx.fillStyle = timeOfDay < 1 ? 
                        'rgba(34, 139, 34, 0.8)' : 
                        'rgba(26, 107, 26, 0.8)';
                    
                    ctx.beginPath();
                    ctx.arc(
                        leafX + offsetX, 
                        leafY + offsetY, 
                        this.leafRadius * 0.7, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Reset any lingering alpha values
                ctx.globalAlpha = 1.0;

                // Draw debug health bar if enabled
                if (debugVisuals) {
                    const healthBarWidth = 30;
                    const x = this.x - healthBarWidth / 2;
                    const y = this.y + 5;
                    
                    // Health background
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(x, y, healthBarWidth, 3);
                    
                    // Health bar
                    const healthColor = this.health > 70 ? 'green' : (this.health > 30 ? 'orange' : 'red');
                    ctx.fillStyle = healthColor;
                    ctx.fillRect(x, y, healthBarWidth * (this.health / 100), 3);
                    
                    // Age indicator
                    const ageRatio = this.age / TREE_LIFESPAN;
                    ctx.fillStyle = ageRatio < 0.3 ? 'green' : (ageRatio < 0.7 ? 'yellow' : 'red');
                    ctx.fillRect(x, y + 5, healthBarWidth * ageRatio, 2);
                }
            }

            degrade(deltaTime) {
                // Increment age with slight randomness
                this.age += deltaTime * (0.4 + Math.random() * 0.1);

                // Trees with nests, eggs, or baby birds are much more resistant
                const hasNest = this.nest !== null;
                let hasEggsOrBabies = false;

                if (hasNest) {
                    // Check for eggs associated with this nest
                    hasEggsOrBabies = eggs.some(egg => egg.associatedNest === this.nest) ||
                                      babyBirds.some(baby => baby.associatedNest === this.nest);
                }

                // Strong protection for trees with active nests/eggs/babies
                const degradationMultiplier = hasEggsOrBabies ? 0.25 : (hasNest ? 0.5 : 1.2);

                // Soften the sudden death at TREE_LIFESPAN
                const lifespanFactor = 1 + Math.min(1.2, Math.max(0, (this.age - TREE_LIFESPAN * 0.9) / (TREE_LIFESPAN * 0.1)));

                // Trees degrade with age and can recover with rain
                if (timeOfDay >= 1 && !isRaining) {
                    // Faster degradation at night without rain
                    this.health -= TREE_DEGRADATION_RATE * degradationMultiplier * lifespanFactor * (deltaTime / 1000);
                } else if (isRaining && timeOfDay < 1) {



                } else if (isRaining && timeOfDay < 1) {
    // Trees recover during rain in daytime - extra recovery for trees with eggs/babies
    const recoveryRate = hasEggsOrBabies ? 0.04 : (hasNest ? 0.025 : 0.0125);
    this.health = Math.min(100, this.health + recoveryRate * (deltaTime / 1000));
} else if (timeOfDay < 1) {




} else if (timeOfDay < 1) {
    // Trees gain a small health boost during the day, more if they have nests/eggs/babies
    const sunRecoveryRate = hasEggsOrBabies ? 0.0125 : (hasNest ? 0.00625 : 0.003);
    this.health = Math.min(100, this.health + sunRecoveryRate * (deltaTime / 1000));
}







// Natural tree recovery during the day
if (timeOfDay < 1 && Math.random() < 0.001) {
    // Random health boost (1-5 points)
    this.health = Math.min(100, this.health + (1 + Math.random() * 4));
    
    // Only show healing sparkle effect when debug visuals are enabled
    if (debugVisuals) {
        addSpecialEffect({
            type: 'sparkle',
            x: this.x,
            y: this.y - this.trunkHeight * 0.5 * this.scale,
            duration: 1000,
            intensity: 0.3
        });
    }
}




                // Check if tree should be removed - but NEVER remove trees with eggs or baby birds
                const hasActiveLife = hasEggsOrBabies;

                // If tree has eggs or babies, boost health to keep it alive
                if (hasActiveLife && this.health < 30) {
                    this.health = 30; // Minimum health for trees with active nests
                    debugLog(`Tree at (${this.x}, ${this.y}) health boosted to protect eggs/babies`);
                }

                // Only allow removal if no eggs/babies present
                if ((this.health <= TREE_HEALTH_THRESHOLD || this.age > TREE_LIFESPAN) && !hasActiveLife) {
                    debugLog(`Tree at (${this.x}, ${this.y}) has ${this.health <= TREE_HEALTH_THRESHOLD ? 'degraded completely' : 'reached end of lifespan'}.`);

                    // If the tree has a nest, handle the nest and any baby birds
                    if (this.nest) {
                        const nestIndex = nests.indexOf(this.nest);
                        if (nestIndex !== -1) {
                            // Check for baby birds in this nest
                            const babiesInNest = babyBirds.filter(baby =>
                                baby.associatedNest === this.nest
                            );

                            // Make babies fall if tree is removed
                            for (const baby of babiesInNest) {
                                baby.startFalling();
                            }

                            // Check for eggs in this nest
                            const eggsInNest = eggs.filter(egg =>
                                egg.associatedNest === this.nest
                            );

                            // Make eggs fall if tree is removed
                            for (const egg of eggsInNest) {
                                egg.startFalling();
                            }
                            
                            if (this.nest.occupiedBy) {
                                this.nest.occupiedBy.myNest = null;
                                this.nest.occupiedBy = null;
                            }
                            
                            nests.splice(nestIndex, 1);
                        }
                    }
                    return true; // Tree should be removed
                }
                return false;
            }
            
            // Method to create perch positions
            getPerchPositions() {
                const positions = [];
                
                // Add positions on branches
                if (this.hasBranches && this.branches.length > 0) {
                    this.branches.forEach(branch => {
                        const branchY = this.y - branch.height;
                        
                        // Multiple positions along each branch
                        for (let i = 0.3; i <= 0.9; i += 0.2) {
                            const perchX = this.x + Math.cos(branch.angle) * branch.length * i * this.scale;
                            const perchY = branchY + Math.sin(branch.angle) * branch.length * i * this.scale;
                            
                            positions.push({
                                x: perchX,
                                y: perchY,
                                tree: this
                            });
                        }
                    });
                }
                
                // Add MANY positions in the leafy area (entire canopy coverage)
                const leafY = this.y - this.trunkHeight * this.scale - this.leafRadius * 0.5 * this.scale;

                // Create multiple rings of perch spots in the leafy canopy
                // Inner ring (near trunk)
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const distance = this.leafRadius * 0.3 * this.scale;

                    positions.push({
                        x: this.x + Math.cos(angle) * distance,
                        y: leafY + Math.sin(angle) * distance * 0.4,
                        tree: this,
                        inLeaves: true
                    });
                }

                // Middle ring
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = this.leafRadius * 0.55 * this.scale;

                    positions.push({
                        x: this.x + Math.cos(angle) * distance,
                        y: leafY + Math.sin(angle) * distance * 0.45,
                        tree: this,
                        inLeaves: true
                    });
                }

                // Outer ring (edge of canopy)
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = this.leafRadius * 0.75 * this.scale;

                    positions.push({
                        x: this.x + Math.cos(angle) * distance,
                        y: leafY + Math.sin(angle) * distance * 0.5,
                        tree: this,
                        inLeaves: true
                    });
                }

                // Top center (classic tree-top perch)
                positions.push({
                    x: this.x,
                    y: leafY,
                    tree: this,
                    inLeaves: true
                });
                
                // Add position at the very top
                positions.push({
                    x: this.x,
                    y: this.y - this.trunkHeight * this.scale - this.leafRadius * this.scale,
                    tree: this,
                    inLeaves: true
                });
                
                return positions;
            }
        }

        function drawTrees(deltaTime) {
            // Sort trees by depth for proper rendering
            const sortedTrees = [...trees].sort((a, b) => b.depth - a.depth);
            
            for (let i = sortedTrees.length - 1; i >= 0; i--) {
                const tree = sortedTrees[i];
                const treeIndex = trees.indexOf(tree);
                const shouldRemove = tree.degrade(deltaTime);
                if (shouldRemove) {
                    // Remove nests associated with this tree (fix floating nest bug)
                    nests = nests.filter(nest => nest.tree !== tree);

                    // FIXED: Make birds fly away when their tree disappears
                    birds.forEach(bird => {
                        if (bird.perchTarget && bird.perchTarget.tree === tree) {
                            // Bird was perched/sleeping on this tree - make them fly away
                            bird.perchTarget = null;
                            bird.state = BIRD_STATES.FLYING;
                            bird.stateTimer = 0;
                            // Generate path to fly to a safe location
                            const targetX = 100 + Math.random() * (canvas.width - 200);
                            const targetY = 100 + Math.random() * (canvas.height * 0.3);
                            bird.generatePath(targetX, targetY);
                            debugLog(`Bird flying away - tree disappeared!`);
                        }
                    });

                    trees.splice(treeIndex, 1);
                } else {
                    tree.draw();
                }
            }
        }

        // More dynamic tree regrowth
        function regrowTrees() {
            // Allow more trees, remove unhealthy ones if above max limit
            if (trees.length > MAX_TREES) {
                // Find the least healthy tree to remove
                let leastHealthyIndex = -1;
                let lowestHealth = 101; // Higher than maximum health
                
                for (let i = 0; i < trees.length; i++) {
                    if (trees[i].health < lowestHealth) {
                        lowestHealth = trees[i].health;
                        leastHealthyIndex = i;
                    }
                }
                
                // Remove it if health is below threshold
                if (leastHealthyIndex !== -1 && lowestHealth < 40) {
                    const removedTree = trees[leastHealthyIndex];
                    // Remove nests associated with this tree (fix floating nest bug)
                    nests = nests.filter(nest => nest.tree !== removedTree);

                    // FIXED: Make birds fly away when their tree is removed
                    birds.forEach(bird => {
                        if (bird.perchTarget && bird.perchTarget.tree === removedTree) {
                            // Bird was perched/sleeping on this tree - make them fly away
                            bird.perchTarget = null;
                            bird.state = BIRD_STATES.FLYING;
                            bird.stateTimer = 0;
                            // Generate path to fly to a safe location
                            const targetX = 100 + Math.random() * (canvas.width - 200);
                            const targetY = 100 + Math.random() * (canvas.height * 0.3);
                            bird.generatePath(targetX, targetY);
                            debugLog(`Bird flying away - tree removed!`);
                        }
                    });

                    debugLog(`Removing unhealthy tree at index ${leastHealthyIndex} with health ${lowestHealth}`);
                    trees.splice(leastHealthyIndex, 1);
                }
            }
            
            // Stagger new tree growth
            if (trees.length < MAX_TREES && Math.random() < 0.7) { // 70% chance to actually grow a tree
                let validPosition = false;
                let attempts = 0;

                while (!validPosition && attempts < 50) {
                    attempts++;
                    const trunkHeight = Math.random() < 0.1 && tallTreeCount < 3 ?
                        150 + Math.random() * 50 :
                        80 + Math.random() * 70;

                    // Better positioning to avoid edges and spread trees more naturally
                    const margin = 100; 
                    const x = margin + Math.random() * (canvas.width - margin * 2);
                    const hasBranches = Math.random() < 0.8; // More trees have branches

                    // Check if position is valid (not too close to other trees)
                    validPosition = trees.every(tree =>
                        Math.abs(tree.x - x) > 100
                    );

                    if (validPosition) {
                        // Occasionally grow much taller trees
                        const extraTall = Math.random() < 0.25; // 25% chance for extra tall tree
                        
                        if (trunkHeight > 150 || extraTall) tallTreeCount++;
                        
                        // Allow for taller trees overall
                        const finalTrunkHeight = extraTall ? 
                        200 + Math.random() * 100 : // Even taller trees: 200-300px
                        trunkHeight;                // Normal trees
                        
                        // Thicker trunks for taller trees
                        const trunkWidth = extraTall ?
                            20 + Math.random() * 15 :  // Thicker trunks for tall trees
                            15 + Math.random() * 10;   // Normal trunks

                        // Larger leaf radius for taller trees
                        const leafRadius = extraTall ?
                            60 + Math.random() * 30 :  // Larger leaf clusters for tall trees
                            40 + Math.random() * 20;   // Normal leaf clusters
                        
                        const newTree = new Tree(
                            x, 
                            trunkWidth, 
                            finalTrunkHeight, 
                            leafRadius, 
                            hasBranches
                        );
                        // Stagger tree ages
                        newTree.age = Math.random() * (TREE_LIFESPAN * 0.5);
                        trees.push(newTree);
                        debugLog(`New tree grown at (${x}). Height: ${finalTrunkHeight}`);
                    }
                }
            }
        }

        // Ensure we always have at least a minimum number of trees
        function ensureMinimumTrees() {
            if (trees.length < MIN_TREES) {
                debugLog("Emergency tree regrowth - ensuring minimum trees exist");
                
                // Determine how many trees to add
                const treesToAdd = MIN_TREES - trees.length;
                
                // Create trees spaced evenly across the screen
                for (let i = 0; i < treesToAdd; i++) {
                    const segment = canvas.width / (treesToAdd + 1);
                    const x = segment * (i + 1) + (Math.random() - 0.5) * segment * 0.5;
                    
                    const newTree = new Tree(
                        x,
                        20,
                        120 + Math.random() * 40,
                        50,
                        true // Always include branches on emergency trees
                    );
                    trees.push(newTree);
                }
            }
        }

        function checkEcosystemHealth() {
            ensureMinimumTrees();
            
            // Check for bird population - more aggressive spawning
            if (birds.length + babyBirds.length < 3) {
                spawnBird();
            }
            
            // Add branches to existing trees periodically
            if (dayNightCycleCount % 3 === 0 && trees.length > 0) {
                // Pick a random tree to add a branch to
                const randomTree = trees[Math.floor(Math.random() * trees.length)];
                if (randomTree.branches.length < 6) { // Limit maximum branches per tree
                    addBranchToTree(randomTree);
                }
            }
        }

        // V26: Enhanced food placement with no glow effect
        function drawFood(deltaTime) {
            // Track how long food has been at max to attract rats
            if (foodItems.length >= MAX_FOOD) {
                foodMaxedOutTimer += deltaTime;
            } else {
                foodMaxedOutTimer = 0; // Reset if not at max
            }

            // Enforce maximum food limit
            if (foodItems.length > MAX_FOOD) {
                // Sort by timer (oldest first)
                foodItems.sort((a, b) => b.timer - a.timer);
                // Keep the newest ones
                foodItems.splice(MAX_FOOD);
            }
            
            for (let i = foodItems.length - 1; i >= 0; i--) {
                const food = foodItems[i];
                food.timer += deltaTime;
                
                // Add decay to food items over time
                if (isRaining) {
                    food.timer += deltaTime; // Food degrades faster in rain
                }
                
                // Food disappears after a long time
                if (food.timer > 270000) { // Adjusted
                    foodItems.splice(i, 1);
                    continue;
                }
                
                // Ensure food freshness never goes below 0
                const freshness = Math.max(0, 1 - (food.timer / 90000));
                // Ensure baseSize never goes below 2
                const baseSize = Math.max(2, 3 + freshness * 2);
                
                if (food.type === 'seed') {
                    ctx.fillStyle = '#F5DEB3';
                    ctx.beginPath();
                    ctx.ellipse(food.x, food.y, baseSize, baseSize * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Darker center to the seeds
                    ctx.fillStyle = '#E6C78F';
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, baseSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (food.type === 'berry') {
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, baseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Highlight on berries
                    ctx.fillStyle = 'rgba(255, 200, 200, 0.6)';
                    ctx.beginPath();
                    ctx.arc(food.x - baseSize * 0.3, food.y - baseSize * 0.3, baseSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (food.type === 'crumb') {
                    ctx.fillStyle = '#D2B48C';
                    
                    // Draw irregular crumb shape
                    ctx.beginPath();
                    ctx.moveTo(food.x, food.y - baseSize * 0.8);
                    ctx.lineTo(food.x + baseSize * 0.7, food.y - baseSize * 0.2);
                    ctx.lineTo(food.x + baseSize * 0.5, food.y + baseSize * 0.5);
                    ctx.lineTo(food.x - baseSize * 0.4, food.y + baseSize * 0.7);
                    ctx.lineTo(food.x - baseSize * 0.7, food.y);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Spawn food more naturally
        function scatterFood(x, y, count = 5, playerAdded = false) {
            const types = ['seed', 'berry', 'crumb'];
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;

            // FIXED: Auto-cleanup oldest food when at capacity
            if (foodItems.length >= MAX_FOOD) {
                const removeCount = Math.floor(MAX_FOOD * 0.2);
                foodItems.splice(0, removeCount);
                debugLog(`Auto-removed ${removeCount} oldest food items (at capacity)`);
            }

            // If no coordinates specified, scatter in a random area
            if (x === undefined || y === undefined) {
                x = Math.random() * canvas.width;
                y = groundY;
            }

            // Ensure y is at or below ground level
            y = Math.max(y, groundY);

            // More natural distribution - cluster with some spread
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50 + 10; // 10-60px from center

                const foodX = x + Math.cos(angle) * distance;
                const foodY = y + Math.sin(angle) * Math.min(distance * 0.3, 20); // Flatter distribution

                // Make sure food stays on screen
                if (foodX > 0 && foodX < canvas.width && foodItems.length < MAX_FOOD) {
                    foodItems.push({
                        x: foodX,
                        y: foodY,
                        type: types[Math.floor(Math.random() * types.length)],
                        timer: 0,
                        spawnTime: Date.now(), // Track age for cleanup
                        playerAdded: playerAdded // Track if player added this food (higher bird priority)
                    });
                }
            }
        }

        // V26: Bird class with updated wing outlines and more perching behavior
        class Bird {
            constructor(isWild = false, birdTypeOverride = null, startX = null, startY = null) {
        this.birdType = birdTypeOverride || BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];

        // Rare color variant system (1.5% chance - MUCH RARER for special colors)
        this.isRareVariant = Math.random() < 0.015;
        if (this.isRareVariant) {
            const rareVariants = [
                { name: 'Albino', bodyColor: '#FFFFFF', wingColor: '#F5F5F5' },
                { name: 'Melanistic', bodyColor: '#1a1a1a', wingColor: '#0a0a0a' },
                { name: 'Golden', bodyColor: '#FFD700', wingColor: '#FFA500' },
                { name: 'Azure', bodyColor: '#007FFF', wingColor: '#0066CC' },
                { name: 'Rose', bodyColor: '#FF69B4', wingColor: '#FF1493' },
                { name: 'Emerald', bodyColor: '#50C878', wingColor: '#2E8B57' }
            ];

            // FIXED: Super rare combo birds (20% of rare birds = 0.3% overall)
            const isCombo = Math.random() < 0.2;
            if (isCombo) {
                // Mix body from one variant, wings/head from another
                const bodyVariant = rareVariants[Math.floor(Math.random() * rareVariants.length)];
                let wingVariant = rareVariants[Math.floor(Math.random() * rareVariants.length)];
                // Ensure different variants
                while (wingVariant.name === bodyVariant.name) {
                    wingVariant = rareVariants[Math.floor(Math.random() * rareVariants.length)];
                }
                this.rareVariant = {
                    name: `Rare ${bodyVariant.name}-${wingVariant.name}`,
                    bodyColor: bodyVariant.bodyColor,
                    wingColor: wingVariant.wingColor
                };
                debugLog(`‚ú® SUPER RARE ${this.rareVariant.name} ${this.birdType.name} spawned!`);
                // Add diary entry for super rare bird
                addDiaryEntry(`A stunning ${this.rareVariant.name} ${this.birdType.name} has joined the garden! This unique bird is truly one of a kind.`, 'rare');
            } else {
                // Standard rare variant
                this.rareVariant = rareVariants[Math.floor(Math.random() * rareVariants.length)];
                debugLog(`Rare ${this.rareVariant.name} ${this.birdType.name} spawned!`);
                // Add diary entry for rare bird
                addDiaryEntry(`A rare ${this.rareVariant.name} ${this.birdType.name} has joined the garden!`, 'rare');
            }
        }

        this.x = startX !== null ? startX : Math.random() * canvas.width;
        this.y = startY !== null ? startY : canvas.height * 0.4;
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.baseSpeed = 0.8 * this.birdType.speedMultiplier;
        this.isWild = isWild; // Wild birds come and go, don't build nests
                this.hunger = Math.random() * 200;
                this.state = BIRD_STATES.FLYING;
                this.stateTimer = 0;
                this.path = [];
                this.pathIndex = 0;
                this.target = null;
                this.pecking = false;
                this.peckTimer = 0;

                // Add depth for ground variance (0-50px deeper in grass for foreground birds)
                this.groundDepth = Math.random() * 50; // 0-50px variance
                this.wingFlap = 0;
                this.isFlying = false;
                this.perchTarget = null;
                this.lastPoopTime = Date.now() - (Math.random() * BIRD_POOP_DELAY);
                this.materialsHeld = 0;
                this.hasSpecialTwig = false;
                this.myNest = null;
                this.lastNestFindAttempt = 0;
                this.nestFindAttempts = 0;
                this.buildingBirdhouse = null;
                this.lastNestCheckTime = 0; // For nest maintenance system
                
                // Add directionChangeCooldown property
                this.directionChangeCooldown = 0;

                // === NEW BEHAVIOR PROPERTIES ===
                // Unique ID for tracking
                this.id = Math.random().toString(36).substring(2, 11);

                // Flocking and social behavior
                this.flockId = null; // Assigned when bird joins a flock
                this.isSentinel = false;
                this.lastSentinelTime = 0;

                // Territorial and aggression
                this.aggression = 0.3 + Math.random() * 0.7; // 0.3-1.0 aggression level
                this.territorialRange = 80 + this.aggression * 70; // 80-150px territory
                this.lastTerritorialDisplay = 0;
                this.defeatedRecently = false;
                this.defeatTimer = 0;

                // Food memory (individual)
                this.foodMemory = []; // {x, y, timestamp}
                this.lastFoodCall = 0;

                // Chirping behavior
                this.lastChirp = 0;
                this.chirpCooldown = 0;
                this.lastContactCall = 0;

                // Ground pecking
                this.isOnGround = false;
                this.peckingInterval = PECKING_INTERVAL_SOLO;
                this.lastPeckTime = 0;
                this.peckAnimationPhase = 0;

                // Mobbing behavior
                this.isMobbing = false;
                this.mobbingTarget = null;
                this.lastMobbingDive = 0;

                // Danger awareness
                this.lastDangerEncounter = 0;
                this.fearLevel = 0; // Increases with danger, decreases over time

                // In the Bird class update method
                if (this.y > canvas.height * GROUND_HEIGHT_RATIO) {
                    this.y = canvas.height * GROUND_HEIGHT_RATIO;
                    this.velocity.y = 0; // Stop when hitting the ground
                }
            }

            applyForce(force) {
                // V26: Add force limiting to prevent extreme accelerations
                const maxForce = 0.03;
                this.acceleration.x += Math.min(maxForce, Math.max(-maxForce, force.x));
                this.acceleration.y += Math.min(maxForce, Math.max(-maxForce, force.y));
            }

            // V26: Improved path generation for smoother, more natural movement
            generatePath(targetX, targetY) {
                // Clear existing path
                this.path = [];
                this.pathIndex = 0;

                // FIXED: Use responsive scaling for bounds to work on high-res monitors
                const responsiveScale = getResponsiveScale();
                const marginX = 100 * responsiveScale;
                const marginY = 80 * responsiveScale;

                // Keep target coordinates within visible bounds with more margin
                targetX = Math.max(marginX, Math.min(canvas.width - marginX, targetX));
                // CRITICAL FIX: Allow birds to reach ground level (remove the -50 offset that was preventing ground landing)
                targetY = Math.max(marginY, Math.min(canvas.height * GROUND_HEIGHT_RATIO + 60, targetY));
                
                // Check for problematic target locations with larger buffer
                const isTargetInProblemArea = problemAreas.some(area => 
                    Math.abs(targetX - area.x) < (area.radius + 20) // Added 20px buffer
                );
                
                // If target is in problem area, adjust it more aggressively
                if (isTargetInProblemArea) {
                    debugLog(`Adjusting target away from problem area`);
                    targetX = findSafeX(problemAreas);
                }
                
                // Special handling for birds starting off-screen
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    // Bird is off-screen, create a natural entry path
                    this.path.push({ x: this.x, y: this.y }); // Start at current position
                    
                    // Add entry point at screen edge with smoother entry
                    let entryX = this.x < 0 ? 80 : (this.x > canvas.width ? canvas.width - 80 : this.x); // Deeper entry
                    let entryY = this.y < 0 ? 80 : (this.y > canvas.height ? canvas.height * 0.5 : this.y); // Deeper entry
                    this.path.push({ x: entryX, y: entryY });
                    
                    // Add multiple waypoints for a smooth arc
                    const controlPoints = Math.min(3, 1 + Math.floor(distance(entryX, entryY, targetX, targetY) / 200));
                    
                    for (let i = 0; i < controlPoints; i++) {
                        const progress = (i + 1) / (controlPoints + 1);
                        const arcHeight = Math.sin(progress * Math.PI) * 60; // Higher arc for smoother flight
                        
                        const wayX = entryX + (targetX - entryX) * progress;
                        const wayY = entryY + (targetY - entryY) * progress - arcHeight;
                        
                        this.path.push({ x: wayX, y: wayY });
                    }
                    
                    // Add final destination
                    this.path.push({ x: targetX, y: targetY });
                } else {
                    // Bird is on-screen - use more natural flight paths with curves
                    // Start path at current position
                    this.path.push({ x: this.x, y: this.y });
                    
                    // For longer paths, add intermediate points for more natural movement
                    const dist = distance(this.x, this.y, targetX, targetY);

                    if (dist > 100) { // Lower threshold for more frequent waypoints
                        // Add proportional waypoints based on distance
                        const controlPoints = Math.min(4, 1 + Math.floor(dist / 150)); // More waypoints

                        for (let i = 0; i < controlPoints; i++) {
                            const progress = (i + 1) / (controlPoints + 1);

                            // Distance-based arc height for natural flight
                            const arcHeight = Math.sin(progress * Math.PI) * Math.min(60, dist * 0.2);

                            // ENHANCED: Avoid creating waypoints near trees and problem areas
                            let wayX;
                            let wayY;
                            let attempts = 0;
                            const treeAvoidanceRadius = 80 * responsiveScale; // Wider avoidance for tree clusters

                            do {
                                // Small random offset for more natural path
                                const randomOffset = (Math.random() - 0.5) * (dist * 0.1);
                                wayX = this.x + (targetX - this.x) * progress + randomOffset;

                                // Calculate y position with arc and random variation
                                const baseY = this.y + (targetY - this.y) * progress;
                                wayY = Math.max(50, Math.min(baseY - arcHeight, canvas.height * 0.7));

                                attempts++;

                                // Check if waypoint is too close to any tree trunk
                                const nearTree = trees.some(tree => {
                                    const treeDist = distance(wayX, wayY, tree.x, tree.y - tree.trunkHeight * 0.5 * tree.scale);
                                    return treeDist < treeAvoidanceRadius;
                                });

                                const nearProblem = problemAreas.some(area => Math.abs(wayX - area.x) < area.radius);

                                // Break if we found a good spot or tried too many times
                                if ((!nearTree && !nearProblem) || attempts >= 8) {
                                    break;
                                }
                            } while (attempts < 8);

                            // If still near trees after all attempts, fly higher to avoid them
                            if (trees.some(tree => distance(wayX, wayY, tree.x, tree.y - tree.trunkHeight * 0.5 * tree.scale) < treeAvoidanceRadius)) {
                                wayY = Math.max(50, wayY - 80); // Fly higher
                            }

                            this.path.push({ x: wayX, y: wayY });
                        }
                    }
                    
                    // Add target as final waypoint
                    this.path.push({ x: targetX, y: targetY });
                }
                
                // Set bird to face in the correct direction
                this.direction = targetX > this.x ? 1 : -1;
            }

            // V26: Improved perch finding with more frequent perching
            findPerch(prioritizeShelter = false) {
                if (trees.length === 0) {
                    // No trees to perch on
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    return;
                }
                
                // V40: MINIMAL chance to skip perching - birds should perch!
                if (Math.random() < 0.005) { // 0.5% chance to skip perching - almost never!
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    
                    // Fly around the sky instead
                    const targetX = 100 + Math.random() * (canvas.width - 200);
                    const targetY = 50 + Math.random() * (canvas.height * 0.3);
                    this.generatePath(targetX, targetY);
                    return;
                }
                
                // Collect all possible perch positions
                let allPerchPositions = [];

                trees.forEach(tree => {
                    const positions = tree.getPerchPositions();
                    allPerchPositions = allPerchPositions.concat(positions);
                });

                // Add bush perching positions (birds prefer trees but can perch on bushes)
                bushes.forEach(bush => {
                    const perchPos = bush.getPerchPosition();
                    allPerchPositions.push({
                        x: perchPos.x,
                        y: perchPos.y,
                        inLeaves: false, // Bushes don't provide as much shelter as tree leaves
                        tree: null, // Not a tree
                        bush: bush, // Reference to the bush
                        isBush: true
                    });
                });

                // Add clock number positions as perch spots when clock is enabled
                if (clockEnabled && window.clockNumberPositions && window.clockNumberPositions.length > 0) {
                    window.clockNumberPositions.forEach(clockSpot => {
                        // Add each clock number as a perch position
                        allPerchPositions.push({
                            x: clockSpot.x + (clockSpot.width / 2), // center of number
                            y: clockSpot.y,
                            inLeaves: false,
                            tree: null, // no tree, it's a clock number
                            isClock: true // mark as clock perch
                        });
                    });
                }

                // Safety check - if no perch positions, fly
                if (allPerchPositions.length === 0) {
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    this.generatePath(
                        Math.random() * canvas.width, 
                        100 + Math.random() * (canvas.height * 0.3)
                    );
                    return;
                }
                
                // Filter and sort perches by preference
                const responsiveScale = getResponsiveScale();
                const groundY = canvas.height * GROUND_HEIGHT_RATIO;

                let validPerches = allPerchPositions.filter(perch => {
                    // VALIDATION: Ensure perch is above ground and within reasonable bounds
                    if (perch.y >= groundY - 10) return false; // Perch must be above ground
                    if (perch.y < 50 && !perch.isClock) return false; // Not too high in sky (except clock perches)
                    if (perch.x < 20 || perch.x > canvas.width - 20) return false; // Within horizontal bounds

                    // Check if there's a bird already perched here (RESPONSIVE)
                    const occupiedRadius = 20 * responsiveScale;
                    return !birds.some(bird =>
                        bird !== this &&
                        bird.state === BIRD_STATES.PERCHED &&
                        distance(bird.x, bird.y, perch.x, perch.y) < occupiedRadius
                    );
                });

                // Filter out perches in problem areas (RESPONSIVE)
                const problemXCoordinates = [100, 928, 888, 904, 0, canvas.width, 882, 877, 864, 873, 900, 866, 887, 859];
                const safeMargin = 60 * responsiveScale;
                
                validPerches = validPerches.filter(perch =>
                    !problemXCoordinates.some(x => Math.abs(perch.x - x) < safeMargin)
                );

                // V40: REMOVED random rejection filter - birds should use ALL valid perches for maximum calm behavior
                
                // Safety check - if no valid perches after filtering, fly
                if (validPerches.length === 0) {
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    this.generatePath(
                        100 + Math.random() * (canvas.width - 200), 
                        100 + Math.random() * (canvas.height * 0.3)
                    );
                    return;
                }
                
                // Sort perches with more balanced preferences (less tree dominance)
                validPerches.sort((a, b) => {
                    let scoreA = 0;
                    let scoreB = 0;
                    
                    // Prefer perches in leaves during rain if seeking shelter
                    if (prioritizeShelter && isRaining) {
                        if (a.inLeaves) scoreA += 100;
                        if (b.inLeaves) scoreB += 100;
                    }
                    
                    // Reduce the weight of proximity to balance attraction
                    const distA = distance(this.x, this.y, a.x, a.y);
                    const distB = distance(this.x, this.y, b.x, b.y);
                    
                    scoreA += (1000 - distA) * 0.05; // Reduced from 0.1
                    scoreB += (1000 - distB) * 0.05; // Reduced from 0.1
                    
                    // Strongly discourage perching on trees that have many birds already
                    const birdsInTreeA = birds.filter(bird => 
                        bird !== this && bird.perchTarget && bird.perchTarget.tree === a.tree
                    ).length;
                    
                    const birdsInTreeB = birds.filter(bird => 
                        bird !== this && bird.perchTarget && bird.perchTarget.tree === b.tree
                    ).length;
                    
                    scoreA -= birdsInTreeA * 30; // Stronger penalty for crowded trees
                    scoreB -= birdsInTreeB * 30;
                    
                    // Prefer reasonable distances
                    if (distA > 300) scoreA -= 150;
                    if (distB > 300) scoreB -= 150;
                    
                    // Prefer higher perches, but with less weight
                    scoreA += (canvas.height - a.y) * 0.02; // Reduced from 0.05
                    scoreB += (canvas.height - b.y) * 0.02; // Reduced from 0.05
                    
                    // Add randomness to perch selection
                    scoreA += Math.random() * 50;
                    scoreB += Math.random() * 50;
                    
                    return scoreB - scoreA;
                });
                
                // Choose perch with some randomness
                const topPerchCount = Math.min(validPerches.length, 5); // Increased choice range
                const selectedIndex = Math.floor(Math.random() * topPerchCount);
                const targetPerch = validPerches[selectedIndex];
                
                // Set perch target and state
                this.perchTarget = targetPerch;
                this.state = BIRD_STATES.PERCHED;
                this.stateTimer = 0;
                
                // Generate a more natural arc path to approach the perch
                const startX = this.x;
                const startY = this.y;
                const midX = (startX + targetPerch.x) / 2;
                const midY = Math.min(startY, targetPerch.y) - 30;
                
                // Create a more natural arc path
                this.path = [
                    { x: startX, y: startY },
                    { x: startX + (midX - startX) * 0.3, y: startY + (midY - startY) * 0.3 },
                    { x: midX, y: midY },
                    { x: midX + (targetPerch.x - midX) * 0.7, y: midY + (targetPerch.y - midY) * 0.7 },
                    { x: targetPerch.x, y: targetPerch.y }
                ];
                
                this.pathIndex = 0;
            }

            findFoodSource() {
                // Try to find food or worms
                let foundFood = false;

                // Expanded vision radius when hungry
                const visionRadius = this.hunger > HUNGER_CRITICAL_THRESHOLD ?
                    BIRD_FOOD_VISION_RADIUS * 2 : BIRD_FOOD_VISION_RADIUS * 1.5;

                // Enhanced: Check for large food piles (ground flocking behavior with crowding)
                // Count food items in clusters - tighter radius for concentrated piles
                const foodClusters = [];
                const clusterRadius = 60; // Tighter clustering for better pile detection

                for (const food of foodItems) {
                    let addedToCluster = false;
                    for (const cluster of foodClusters) {
                        if (distance(food.x, food.y, cluster.x, cluster.y) < clusterRadius) {
                            cluster.count++;
                            cluster.x = (cluster.x * (cluster.count - 1) + food.x) / cluster.count;
                            cluster.y = (cluster.y * (cluster.count - 1) + food.y) / cluster.count;
                            addedToCluster = true;
                            break;
                        }
                    }
                    if (!addedToCluster) {
                        foodClusters.push({ x: food.x, y: food.y, count: 1 });
                    }
                }

                // Enhanced: Major food pile (15+ items) causes birds to interrupt and crowd together
                for (const cluster of foodClusters) {
                    if (cluster.count >= 15 && distance(this.x, this.y, cluster.x, cluster.y) < visionRadius * 2) {
                        // MAJOR FOOD EVENT - birds interrupt current behaviors to join crowd
                        const groundY = canvas.height * GROUND_HEIGHT_RATIO + 40;
                        this.path = [
                            { x: this.x, y: this.y },
                            { x: cluster.x + (Math.random() - 0.5) * 50, y: groundY }
                        ];
                        this.pathIndex = 0;
                        this.intendToHop = true;
                        this.hopData = null;
                        // Interrupt current behavior and transition to PECKING for crowding effect
                        this.state = BIRD_STATES.FLYING; // Fly there first
                        this.stateTimer = 0;
                        debugLog(`Bird INTERRUPTING to join food crowd at (${cluster.x}, ${cluster.y}) with ${cluster.count} items!`);
                        return;
                    }
                    // Normal food pile (5+ items) for regular ground flocking
                    else if (cluster.count >= 5 && distance(this.x, this.y, cluster.x, cluster.y) < visionRadius * 1.5) {
                        const groundY = canvas.height * GROUND_HEIGHT_RATIO + 40;
                        this.path = [
                            { x: this.x, y: this.y },
                            { x: cluster.x + (Math.random() - 0.5) * 40, y: groundY }
                        ];
                        this.pathIndex = 0;
                        this.intendToHop = true;
                        this.hopData = null;
                        debugLog(`Bird joining ground flock at food pile (${cluster.x}, ${cluster.y}) with ${cluster.count} items`);
                        return;
                    }
                }

                // Check food memory first
                const now = Date.now();
                this.foodMemory = this.foodMemory.filter(f => now - f.timestamp < FOOD_KNOWLEDGE_DURATION);

                if (this.foodMemory.length > 0 && Math.random() < 0.4) {
                    const memFood = this.foodMemory[0];
                    // Check if danger zone
                    if (!this.isDangerZone(memFood.x, memFood.y)) {
                        this.target = {
                            type: 'remembered',
                            x: memFood.x,
                            y: memFood.y
                        };
                        this.state = BIRD_STATES.HUNTING;
                        this.stateTimer = 0;
                        debugLog(`Bird using food memory`);
                        return;
                    }
                }

                // Target worms first (more nutritious)
                for (const worm of worms) {
                    if (distance(this.x, this.y, worm.x, worm.y) < visionRadius &&
                        !this.isDangerZone(worm.x, worm.y)) {
                        this.target = {
                            type: 'worm',
                            worm: worm,
                            x: worm.x,
                            y: worm.y
                        };
                        this.state = BIRD_STATES.HUNTING;
                        this.stateTimer = 0;
                        foundFood = true;

                        // Add to memory
                        this.foodMemory.push({x: worm.x, y: worm.y, timestamp: now});

                        // Make food call
                        if (Math.random() < 0.3) {
                            this.makeFoodCall(worm.x, worm.y);
                        }

                        debugLog(`Bird found worm at (${worm.x}, ${worm.y})`);
                        break;
                    }
                }

                // Check for bushes with fruit (nutritious and natural food source)
                if (!foundFood) {
                    for (const bush of bushes) {
                        if (bush.fruitCount > 0 &&
                            distance(this.x, this.y, bush.x, bush.y - bush.height / 2) < visionRadius &&
                            !this.isDangerZone(bush.x, bush.y)) {
                            this.target = {
                                type: 'bush',
                                bush: bush,
                                x: bush.x,
                                y: bush.y - bush.height / 2 // Target near the fruit
                            };
                            this.state = BIRD_STATES.HUNTING;
                            this.stateTimer = 0;
                            foundFood = true;

                            // Add to memory
                            this.foodMemory.push({x: bush.x, y: bush.y, timestamp: now});

                            // Make food call
                            if (Math.random() < 0.25) {
                                this.makeFoodCall(bush.x, bush.y);
                            }

                            debugLog(`Bird found ${bush.fruitType}s on bush at (${bush.x}, ${bush.y})`);
                            break;
                        }
                    }
                }

                // If no worms or bush fruit found, try to find food items
                // PRIORITY #1: Check for player-added food with 2x vision radius
                if (!foundFood) {
                    for (const food of foodItems) {
                        if (food.playerAdded &&
                            distance(this.x, this.y, food.x, food.y) < visionRadius * 2 &&
                            !this.isDangerZone(food.x, food.y)) {
                            this.target = {
                                type: 'food',
                                food: food,
                                x: food.x,
                                y: food.y
                            };
                            this.state = BIRD_STATES.HUNTING;
                            this.stateTimer = 0;
                            foundFood = true;

                            // Add to memory
                            this.foodMemory.push({x: food.x, y: food.y, timestamp: now});

                            // Make food call
                            if (Math.random() < 0.3) {
                                this.makeFoodCall(food.x, food.y);
                            }

                            debugLog(`Bird found PLAYER-ADDED food at (${food.x}, ${food.y}) - prioritized!`);
                            break;
                        }
                    }
                }

                // PRIORITY #2: Check for regular food items with normal vision radius
                if (!foundFood) {
                    for (const food of foodItems) {
                        if (distance(this.x, this.y, food.x, food.y) < visionRadius &&
                            !this.isDangerZone(food.x, food.y)) {
                            this.target = {
                                type: 'food',
                                food: food,
                                x: food.x,
                                y: food.y
                            };
                            this.state = BIRD_STATES.HUNTING;
                            this.stateTimer = 0;
                            foundFood = true;

                            // Add to memory
                            this.foodMemory.push({x: food.x, y: food.y, timestamp: now});

                            // Make food call
                            if (Math.random() < 0.3) {
                                this.makeFoodCall(food.x, food.y);
                            }

                            debugLog(`Bird found food at (${food.x}, ${food.y})`);
                            break;
                        }
                    }
                }
                
                // If no food found, fly to likely food areas
                if (!foundFood) {
                    // Generate path to a likely food location
                    const groundY = canvas.height * GROUND_HEIGHT_RATIO - 10;
                    
                    // Birds prioritize different areas based on hunger level
                    let targetX;
                    
                    if (this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                        // Very hungry - check areas with recent food sightings
                        if (foodItems.length > 0) {
                            // Go to where food actually is
                            const randomFood = foodItems[Math.floor(Math.random() * foodItems.length)];
                            targetX = randomFood.x + (Math.random() - 0.5) * 30;
                        } else if (trees.length > 0) {
                            const randomTree = trees[Math.floor(Math.random() * trees.length)];
                            targetX = randomTree.x + (Math.random() - 0.5) * 50;
                        } else {
                            targetX = Math.random() * canvas.width;
                        }
                    } else {
                        // Less hungry - more random search
                        targetX = Math.random() * canvas.width;
                    }
                    
                    this.generatePath(targetX, groundY);
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    debugLog(`Bird searching for food around ${targetX}`);
                }
            }

            findNearestFood() {
                // Find the nearest food source (worm, bush fruit, or food item) without changing state
                let closestFood = null;
                let closestDist = Infinity;
                const visionRadius = 500; // Use large vision radius for hungry birds

                // Check worms first (most nutritious)
                for (const worm of worms) {
                    const dist = distance(this.x, this.y, worm.x, worm.y);
                    if (dist < closestDist && dist < visionRadius && !this.isDangerZone(worm.x, worm.y)) {
                        closestDist = dist;
                        closestFood = {
                            type: 'worm',
                            entity: worm,
                            x: worm.x,
                            y: worm.y
                        };
                    }
                }

                // Check bushes with fruit
                for (const bush of bushes) {
                    if (bush.fruitCount > 0) {
                        const dist = distance(this.x, this.y, bush.x, bush.y - bush.height / 2);
                        if (dist < closestDist && dist < visionRadius && !this.isDangerZone(bush.x, bush.y)) {
                            closestDist = dist;
                            closestFood = {
                                type: 'bush',
                                entity: bush,
                                x: bush.x,
                                y: bush.y - bush.height / 2
                            };
                        }
                    }
                }

                // Check food items
                for (const food of foodItems) {
                    const dist = distance(this.x, this.y, food.x, food.y);
                    if (dist < closestDist && dist < visionRadius && !this.isDangerZone(food.x, food.y)) {
                        closestDist = dist;
                        closestFood = {
                            type: 'food',
                            entity: food,
                            x: food.x,
                            y: food.y
                        };
                    }
                }

                return closestFood;
            }

            findTwigs() {
                // Find twigs to build nest
                let foundTwig = false;
                
                // Increased vision radius
                const twigsVisionRadius = BIRD_VISION_RADIUS * 2; // Doubled vision for twigs
                
                for (const twig of twigs) {
                    if (distance(this.x, this.y, twig.x, twig.y) < twigsVisionRadius) {
                        this.target = {
                            type: 'twig',
                            twig: twig,
                            x: twig.x,
                            y: twig.y
                        };
                        this.state = BIRD_STATES.COLLECTING;
                        this.stateTimer = 0;
                        foundTwig = true;
                        debugLog(`Bird found twig at (${twig.x}, ${twig.y})`);
                        break;
                    }
                }
                
                // If no twigs found, try to create nest anyway (birds can build without materials in hand)
                if (!foundTwig) {
                    // FIXED: Birds without nests should try to create one even without twigs
                    if (!this.myNest && !this.isWild) {
                        // Try to create a nest - bird will need materials to complete it
                        this.findOrCreateNest();
                        debugLog(`Bird attempting to create nest even without visible twigs`);
                    } else {
                        // Fly to likely twig areas to look for materials
                        const groundY = canvas.height * GROUND_HEIGHT_RATIO - 10;
                        let targetX;

                        // Check if there are trees (likely source of twigs)
                        if (trees.length > 0) {
                            // Pick tree deliberately instead of randomly
                            // Sort trees by health to pick healthier trees first
                            const sortedTrees = [...trees].sort((a, b) => b.health - a.health);
                            const tree = sortedTrees[0]; // Pick healthiest tree
                            targetX = tree.x + (Math.random() - 0.5) * 30;
                        } else {
                            targetX = Math.random() * canvas.width;
                        }

                        // More clear destination
                        this.generatePath(targetX, groundY);
                        this.state = BIRD_STATES.FLYING;
                        this.stateTimer = 0;
                        debugLog(`Bird looking for twigs near healthiest tree`);
                    }
                }
            }

            // V26: Updated nest finding & maintenance for deterioration system
            findOrCreateNest() {
                // Log attempt for debugging
                debugLog(`Bird attempting to find or create nest`);
                
                // Reset counter if it's been a long time since last attempt
                if (Date.now() - this.lastNestFindAttempt > 60000) {
                    this.nestFindAttempts = 0;
                }
                
                this.nestFindAttempts++;
                this.lastNestFindAttempt = Date.now();
                
                // First check if current nest needs maintenance
                if (this.myNest && this.myNest.needsMaintenance) {
                    this.state = BIRD_STATES.BUILDING; // Reuse building state for maintenance
                    this.stateTimer = 0;
                    debugLog(`Bird prioritizing nest maintenance`);
                    return;
                }
                
                // Check if current nest has collapsed and needs rebuilding
                if (this.myNest && !this.myNest.isComplete) {
                    this.state = BIRD_STATES.BUILDING; // Rebuild nest
                    this.stateTimer = 0;
                    debugLog(`Bird rebuilding collapsed nest`);
                    return;
                }
                
                // Try to find existing incomplete nest
                for (const nest of nests) {
                    if (!nest.occupiedBy && !nest.isComplete) {
                        this.myNest = nest;
                        nest.occupiedBy = this;
                        this.state = BIRD_STATES.BUILDING;
                        this.stateTimer = 0;
                        debugLog(`Bird found unoccupied nest at (${nest.x}, ${nest.y})`);
                        return;
                    }
                }
                
                // If no existing suitable nest, create a new one with less restrictions
                if (trees.length > 0 && nests.length < (trees.length * 0.9)) { // Increased from 0.8
                    // Find a suitable tree with more relaxed criteria
                    const potentialTrees = trees.filter(tree => 
                        !tree.nest && tree.health > 30 // Reduced from 50
                    );
                    
                    if (potentialTrees.length > 0) {
                        // Sort trees by health to pick healthier trees first
                        potentialTrees.sort((a, b) => b.health - a.health);
                        
                        // Pick one of the healthiest trees
                        const treeIndex = Math.floor(Math.random() * Math.min(3, potentialTrees.length));
                        const tree = potentialTrees[treeIndex];
                        
                        // Create a new nest with very clear logging
                        const nestX = tree.x + (Math.random() * 20 - 10) * tree.scale;
                        const nestY = tree.y - tree.trunkHeight * 0.8 * tree.scale;
                        
                        const newNest = new Nest(tree, nestX, nestY);
                        nests.push(newNest);
                        tree.nest = newNest;
                        
                        this.myNest = newNest;
                        newNest.occupiedBy = this;
                        
                        this.state = BIRD_STATES.BUILDING;
                        this.stateTimer = 0;
                        
                        debugLog(`Bird created new nest at (${nestX}, ${nestY}) in tree at ${tree.x}`);
                        return;
                    }
                }
                
                // Reset nest find attempts to try again immediately if failed
                if (this.nestFindAttempts > MAX_NEST_FIND_ATTEMPTS) {
                    this.nestFindAttempts = 0;
                    debugLog(`Bird resetting nest find attempts to try again`);
                }
                
                // If we can't create a nest, go back to flying but don't give up
                this.state = BIRD_STATES.FLYING;
                this.stateTimer = 0;
                
                // Rather than find a perch, look for another twig
                this.findTwigs();
            }


            findOrCreateBirdhouse() {
                 // Only non-wild birds build birdhouses AND only after at least 3 days have passed
    if (this.isWild || dayNightCycleCount < 3) return;
                
                // Check if there's already a birdhouse being built
                const incompleteBirdhouse = birdhouses.find(bh => !bh.isComplete);
                
                if (incompleteBirdhouse) {
                    // Join existing birdhouse construction
                    this.buildingBirdhouse = incompleteBirdhouse;
                    this.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                    this.stateTimer = 0;
                    debugLog(`Bird joining birdhouse construction at (${incompleteBirdhouse.x})`);
                    return;
                }
                

                
                // Find a spot for a new birdhouse
                const validSpaces = [];
                const minDistance = 100; // Minimum distance from other birdhouses
                
                // Find valid placement spots
                for (let x = 100; x < canvas.width - 100; x += 50) {
                    let valid = true;
                    
                    // Check if too close to other birdhouses
                    for (const birdhouse of birdhouses) {
                        if (Math.abs(birdhouse.x - x) < minDistance) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) validSpaces.push(x);
                }
                
                // Place birdhouse if valid space found
                if (validSpaces.length > 0 && birdhouses.length < 3) { // Limit to 3 birdhouses
                    const x = validSpaces[Math.floor(Math.random() * validSpaces.length)];
                    const y = canvas.height * GROUND_HEIGHT_RATIO;
                    
                    const newBirdhouse = new Birdhouse(x, y);
                    // Important: Don't set isComplete to true so birds can build it
                    birdhouses.push(newBirdhouse);
                    
                    this.buildingBirdhouse = newBirdhouse;
                    this.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                    this.stateTimer = 0;
                    
                    debugLog(`Bird started new birdhouse at (${x})`);
                }


                
            }

            // V26: Nest condition checking helper
            checkNestCondition() {
                if (!this.isWild && this.myNest) {
                    if (this.myNest.needsMaintenance) {
                        // Find twigs for repairs if needed
                        if (this.materialsHeld === 0) {
                            this.findTwigs();
                            debugLog(`Bird looking for materials to repair nest`);
                        } else {
                            // Go to nest with materials
                            this.state = BIRD_STATES.BUILDING;
                            this.stateTimer = 0;
                            debugLog(`Bird has materials to repair nest`);
                        }
                        return true; // Nest needs attention
                    } else if (!this.myNest.isComplete) {
                        // Nest collapsed - needs rebuilding
                        if (this.materialsHeld === 0) {
                            this.findTwigs();
                            debugLog(`Bird looking for materials to rebuild collapsed nest`);
                        } else {
                            this.state = BIRD_STATES.BUILDING;
                            this.stateTimer = 0;
                            debugLog(`Bird has materials to rebuild collapsed nest`);
                        }
                        return true; // Nest needs attention
                    }
                }
                return false; // Nest doesn't need attention
            }


            findBirdhouse() {
    // Skip if wild bird
    if (this.isWild) return false;
    
    // Find available birdhouses
    const availableBirdhouses = birdhouses.filter(bh => 
        bh.isComplete && bh.canAcceptOccupant()
    );
    
    if (availableBirdhouses.length === 0) {
        return false; // No available birdhouses
    }
    
    // Choose closest birdhouse
    let closestBirdhouse = null;
    let minDistance = Infinity;
    
    for (const birdhouse of availableBirdhouses) {
        const dist = distance(this.x, this.y, birdhouse.x, birdhouse.y);
        if (dist < minDistance) {
            minDistance = dist;
            closestBirdhouse = birdhouse;
        }
    }
    
    if (closestBirdhouse) {
        // Generate path to birdhouse
        this.generatePath(
            closestBirdhouse.x, 
            closestBirdhouse.y - 20 // Position above the birdhouse
        );
        
        // Set state to flying toward birdhouse
        this.state = BIRD_STATES.FLYING;
        this.stateTimer = 0;
        
        // Remember target birdhouse
        this.targetBirdhouse = closestBirdhouse;
        debugLog(`Bird heading to birdhouse at (${closestBirdhouse.x})`);
        return true;
    }
    
    return false;
}

            findPuddle() {
                // Look for puddles or ponds to bathe/drink from
                if (puddles.length === 0 && ponds.length === 0) {
                    // No water available
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;

                    // Find a perch instead
                    this.findPerch();
                    return;
                }



                // Find the nearest puddle or pond
                let closestWater = null;
                let closestDist = Infinity;
                let isPond = false;

                for (const puddle of puddles) {
                    const dist = distance(this.x, this.y, puddle.x, puddle.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestWater = puddle;
                        isPond = false;
                    }
                }

                // Also check ponds
                for (const pond of ponds) {
                    const dist = distance(this.x, this.y, pond.x, pond.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestWater = pond;
                        isPond = true;
                    }
                }

                if (closestWater) {
                    // Go to water source
                    this.generatePath(closestWater.x, closestWater.y);
                    this.state = BIRD_STATES.BATHING;
                    this.stateTimer = 0;
                    this.drinkingFromPond = isPond; // Track if at pond
                    debugLog(`Bird going to ${isPond ? 'drink from pond' : 'bathe in puddle'} at (${closestWater.x}, ${closestWater.y})`);
                } else {
                    // Fallback - find a perch
                    this.findPerch();
                }
            }


            // Add this method to the Bird class, right after findPuddle and before flee methods

            findBabyBirds() {
                // Skip if no babies or if this is a wild bird
                if (babyBirds.length === 0 || this.isWild) {
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    return;
                }
                
               // Prioritize babies in this bird's own nest
               let targetBaby = null;
               let closestDist = Infinity;

               // First check if bird has its own nest with babies
               if (this.myNest) {
                   for (const baby of babyBirds) {
                       // Check if baby is in or near bird's nest
                       if (baby.associatedNest === this.myNest || 
                           distance(baby.x, baby.y, this.myNest.x, this.myNest.y) < 30) {
                           // Prioritize hungry babies
                           const dist = distance(this.x, this.y, baby.x, baby.y);
                           const hungerFactor = baby.timeSinceLastMeal * 5; // Increased from 3 for own nest babies
                           const weightedDist = dist - hungerFactor;
                           
                           if (weightedDist < closestDist) {
                               closestDist = weightedDist;
                               targetBaby = baby;
                           }
                       }
                   }
               }
                
                // If no baby found in own nest, look for any baby
                if (!targetBaby) {
                    for (const baby of babyBirds) {
                        const dist = distance(this.x, this.y, baby.x, baby.y);
                        // Factor in how long since last feeding to prioritize hungrier babies
                        const hungerFactor = baby.timeSinceLastMeal * 2;
                        const weightedDist = dist - hungerFactor;
                        
                        if (weightedDist < closestDist && dist < BIRD_VISION_RADIUS * 1.5) {
                            closestDist = weightedDist;
                            targetBaby = baby;
                        }
                    }
                }
                
                if (targetBaby) {
                    // Go find food first if bird is hungry itself or doesn't have food
                    if (this.hunger > 200) {
                        this.findFoodSource();
                        debugLog(`Bird needs to find food before feeding baby`);
                    } else {
                        // Set target to the baby bird
                        this.target = {
                            type: 'baby',
                            x: targetBaby.x,
                            y: targetBaby.y,
                            baby: targetBaby
                        };
                        this.state = BIRD_STATES.HUNTING;
                        this.stateTimer = 0;
                        debugLog(`Bird targeting baby bird at (${targetBaby.x}, ${targetBaby.y}) to feed it`);
                    }
                } else {
                    // No suitable baby found, go back to flying
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    
                    // Maybe find a perch instead
                    if (Math.random() < 0.5) {
                        this.findPerch();
                    }
                }
            }

            flee(threatX, threatY) {
                // Calculate direction away from threat
                const dx = this.x - threatX;
                const dy = this.y - threatY;
                const dir = normalize(dx, dy);

                // Record danger
                this.recordDanger(threatX, threatY, 'unknown');

                // REALISTIC: Birds freeze briefly before fleeing (ALARM state)
                this.state = BIRD_STATES.ALARM;
                this.stateTimer = 0;

                // Store threat info for ALARM state to use
                this.threatX = threatX;
                this.threatY = threatY;

                // Set direction faced
                this.direction = dx > 0 ? 1 : -1;

                // Alert chirp
                this.chirp(CHIRP_TYPES.ALERT, 1.0);

                debugLog(`Bird alarmed by threat at (${threatX}, ${threatY})`);
            }

            // === NEW BEHAVIOR METHODS ===

            // Get all nearby flockmates
            getFlockmates() {
                return birds.filter(b =>
                    b !== this &&
                    !b.isWild &&
                    distance(this.x, this.y, b.x, b.y) < FLOCK_DISTANCE &&
                    b.birdType.name === this.birdType.name // Same species flock together
                );
            }

            // Check if this bird should be sentinel
            updateSentinelRole(flockmates) {
                if (flockmates.length === 0) {
                    this.isSentinel = false;
                    return;
                }

                const now = Date.now();
                const flockKey = `flock_${this.birdType.name}`;

                // Check if it's time to rotate sentinel
                if (!sentinelRotationTimers.has(flockKey) ||
                    now - sentinelRotationTimers.get(flockKey) > SENTINEL_ROTATION_INTERVAL) {

                    // Choose new sentinel (random from flock)
                    const candidates = [this, ...flockmates];
                    const newSentinel = candidates[Math.floor(Math.random() * candidates.length)];

                    // Clear old sentinel status
                    candidates.forEach(b => b.isSentinel = false);

                    // Assign new sentinel
                    newSentinel.isSentinel = true;
                    currentSentinels.set(flockKey, newSentinel);
                    sentinelRotationTimers.set(flockKey, now);

                    debugLog(`New sentinel assigned in ${this.birdType.name} flock`);
                }
            }

            // Emit a chirp with specific type
            chirp(type, intensity = 1.0) {
                // Don't chirp during playthehits performance
                if (playingTheHits) return;

                const now = Date.now();
                if (now - this.lastChirp < 1000) return; // Cooldown

                this.lastChirp = now;
                console.log("Bird chirp called - type:", type, "intensity:", intensity, "birdId:", this.id);

                activeChirps.push({
                    x: this.x,
                    y: this.y,
                    type: type,
                    timestamp: now,
                    birdId: this.id,
                    intensity: intensity
                });

                // Play audio using simplified bird chirp synthesis
                // Use synthBirdChirp for more natural bird sounds
                // Different chirp types get different volumes
                const volumeMap = {
                    [CHIRP_TYPES.SOCIAL]: 0.3,
                    [CHIRP_TYPES.FOOD_CALL]: 0.4,
                    [CHIRP_TYPES.CONTACT_CALL]: 0.25,
                    [CHIRP_TYPES.ALERT]: 0.5,
                    [CHIRP_TYPES.TERRITORIAL]: 0.35,
                    [CHIRP_TYPES.VICTORY]: 0.45
                };

                const volume = (volumeMap[type] || 0.3) * intensity;
                console.log("Calling synthBirdChirp with volume:", volume);
                synthBirdChirp(volume, this.id); // Pass bird ID for consistent voice
            }

            // Announce food discovery to flockmates
            makeFoodCall(foodX, foodY) {
                const now = Date.now();
                if (now - this.lastFoodCall < 3000) return; // Don't spam food calls

                this.lastFoodCall = now;
                this.chirp(CHIRP_TYPES.FOOD_CALL, 1.2);

                // Add to shared flock knowledge
                sharedFoodKnowledge.push({
                    x: foodX,
                    y: foodY,
                    timestamp: now,
                    discoveredBy: this.id
                });

                // Flockmates add to their own memory too
                const flockmates = this.getFlockmates();
                flockmates.forEach(bird => {
                    if (distance(bird.x, bird.y, this.x, this.y) < 200) {
                        bird.foodMemory.push({
                            x: foodX,
                            y: foodY,
                            timestamp: now
                        });
                    }
                });

                debugLog(`${this.birdType.name} made food call at (${foodX}, ${foodY})`);
            }

            // Make contact call when far from flock
            checkContactCall() {
                const flockmates = this.getFlockmates();
                if (flockmates.length === 0) return;

                const nearestDist = Math.min(...flockmates.map(b =>
                    distance(this.x, this.y, b.x, b.y)
                ));

                const now = Date.now();
                if (nearestDist > CONTACT_CALL_DISTANCE && now - this.lastContactCall > 5000) {
                    this.lastContactCall = now;
                    this.chirp(CHIRP_TYPES.CONTACT_CALL, 0.7);
                }
            }

            // Start mobbing behavior against predator
            startMobbing(predatorX, predatorY, predatorType) {
                this.isMobbing = true;
                this.mobbingTarget = {x: predatorX, y: predatorY, type: predatorType};
                this.state = BIRD_STATES.MOBBING;
                this.stateTimer = 0;
                this.chirp(CHIRP_TYPES.ALERT, 1.5);

                // Alert flockmates to join mobbing
                const flockmates = this.getFlockmates();
                flockmates.forEach(bird => {
                    if (distance(bird.x, bird.y, this.x, this.y) < 300 && bird.aggression > 0.4) {
                        bird.isMobbing = true;
                        bird.mobbingTarget = {x: predatorX, y: predatorY, type: predatorType};
                        bird.state = BIRD_STATES.MOBBING;
                        bird.stateTimer = 0;
                    }
                });

                // Register active mobbing
                activeMobbings.push({
                    targetX: predatorX,
                    targetY: predatorY,
                    participants: [this.id, ...flockmates.filter(b => b.isMobbing).map(b => b.id)],
                    startTime: Date.now()
                });

                debugLog(`Mobbing started against ${predatorType} at (${predatorX}, ${predatorY})`);
            }

            // Update mobbing behavior
            updateMobbing(deltaTime) {
                const now = Date.now();
                if (!this.mobbingTarget || this.stateTimer > MOBBING_DURATION) {
                    // End mobbing
                    this.isMobbing = false;
                    this.mobbingTarget = null;
                    this.state = BIRD_STATES.FLYING;
                    return;
                }

                // Circle and dive at target
                if (now - this.lastMobbingDive > MOBBING_DIVE_FREQUENCY) {
                    this.lastMobbingDive = now;

                    // Calculate dive point near predator
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 50 + Math.random() * 50;
                    const targetX = this.mobbingTarget.x + Math.cos(angle) * radius;
                    const targetY = this.mobbingTarget.y + Math.sin(angle) * radius - 30;

                    this.generatePath(targetX, targetY);

                    // Aggressive chirping
                    if (Math.random() < 0.3) {
                        this.chirp(CHIRP_TYPES.ALERT, 0.8);
                    }
                }
            }

            // Add danger zone to memory
            recordDanger(dangerX, dangerY, threatType) {
                this.lastDangerEncounter = Date.now();
                this.fearLevel = Math.min(1.0, this.fearLevel + 0.3);

                // Add to global danger zones
                dangerZones.push({
                    x: dangerX,
                    y: dangerY,
                    timestamp: Date.now(),
                    threatType: threatType
                });

                debugLog(`Danger recorded at (${dangerX}, ${dangerY}): ${threatType}`);
            }

            // Check if location is in a danger zone
            isDangerZone(x, y) {
                const now = Date.now();

                // Override fear if starving
                if (this.hunger > FEAR_OVERRIDE_HUNGER) {
                    return false;
                }

                // Clean up old danger zones
                dangerZones = dangerZones.filter(d => now - d.timestamp < DANGER_MEMORY_DURATION);

                // Check if point is in any danger zone
                return dangerZones.some(d =>
                    distance(x, y, d.x, d.y) < DANGER_ZONE_RADIUS
                );
            }

            // Ground pecking behavior
            startPecking() {
                this.state = BIRD_STATES.PECKING;
                this.isOnGround = true;
                this.peckTimer = 0;
                this.lastPeckTime = Date.now();

                // Check for nearby flockmates to determine pecking speed (RESPONSIVE)
                const flockProximity = 100 * getResponsiveScale();
                const nearbyFeeding = birds.filter(b =>
                    b !== this &&
                    b.state === BIRD_STATES.PECKING &&
                    distance(this.x, this.y, b.x, b.y) < flockProximity
                );

                // Social facilitation - peck faster in groups
                if (nearbyFeeding.length > 0) {
                    this.peckingInterval = PECKING_INTERVAL_GROUP;
                    debugLog(`${this.birdType.name} started pecking in group (${nearbyFeeding.length} nearby) at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                } else {
                    this.peckingInterval = PECKING_INTERVAL_SOLO;
                    debugLog(`${this.birdType.name} started solo pecking at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                }
            }

            // Update pecking animation
            updatePecking(deltaTime) {
                const now = Date.now();

                // Check if should peck
                if (now - this.lastPeckTime > this.peckingInterval) {
                    this.lastPeckTime = now;
                    this.peckAnimationPhase = 1.0; // Start peck animation

                    // Actually consume food if present (RESPONSIVE)
                    const peckFoodRadius = 20 * getResponsiveScale();
                    const nearbyFood = foodItems.find(f =>
                        distance(this.x, this.y, f.x, f.y) < peckFoodRadius
                    );

                    if (nearbyFood) {
                        this.hunger = Math.max(0, this.hunger - 50);
                        foodItems.splice(foodItems.indexOf(nearbyFood), 1);
                        debugLog(`${this.birdType.name} pecked and consumed food at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                    } else {
                        debugLog(`${this.birdType.name} pecked ground (no food) at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                    }
                }

                // Animate peck
                if (this.peckAnimationPhase > 0) {
                    this.peckAnimationPhase -= deltaTime / 200; // Animation duration
                    this.peckAnimationPhase = Math.max(0, this.peckAnimationPhase);
                }

                // Check for nearby pecking birds for social facilitation
                const nearbyFeeding = birds.filter(b =>
                    b !== this &&
                    b.state === BIRD_STATES.PECKING &&
                    distance(this.x, this.y, b.x, b.y) < 100
                );

                this.peckingInterval = nearbyFeeding.length > 0 ?
                    PECKING_INTERVAL_GROUP : PECKING_INTERVAL_SOLO;
            }

            // Territorial display behavior
            startTerritorialDisplay(rival) {
                this.state = BIRD_STATES.TERRITORIAL_DISPLAY;
                this.lastTerritorialDisplay = Date.now();
                this.stateTimer = 0;
                this.chirp(CHIRP_TYPES.TERRITORIAL, 1.0);

                // Alert flockmates for coalition support
                const flockmates = this.getFlockmates();
                const supporters = flockmates.filter(b =>
                    distance(b.x, b.y, this.x, this.y) < 150 &&
                    b.aggression > 0.5
                );

                // Record territorial dispute
                territorialDisputes.push({
                    bird1: this,
                    bird2: rival,
                    location: {x: this.x, y: this.y},
                    startTime: Date.now(),
                    supporters1: supporters.length,
                    supporters2: 0 // Would count rival's supporters
                });

                debugLog(`Territorial display: ${this.birdType.name} vs ${rival.birdType.name}`);
            }

            update(deltaTime) {
                // Update wingflap with slower movement for calmer appearance
                if (this.state === BIRD_STATES.FLYING || this.state === BIRD_STATES.FLEEING || 
                    Math.abs(this.velocity.x) > 0.2 || Math.abs(this.velocity.y) > 0.2) {
                    this.wingFlap += 0.2 * deltaTime / 16; // Reduced from 0.3
                } else {
                    this.wingFlap += 0.02 * deltaTime / 16; // Reduced from 0.05
                }
                
                // State-independent checks
                this.hunger += BIRD_HUNGER_RATE * deltaTime / 16 * (isRaining ? 1.2 : 1);
                if (this.hunger >= BIRD_MAX_HUNGER) {
                    debugLog(`A ${this.birdType.name} died of hunger!`, DEBUG_LEVELS.WARNING);
                    return true; // Bird dies of hunger
                }
                
                // Wild birds leave after a while
                if (this.isWild && this.stateTimer > 30000) {
                    return true; // Bird leaves the scene
                }
                
                // Update poop timer - create smaller poops
                const now = Date.now();
                if (now - this.lastPoopTime > BIRD_POOP_DELAY && Math.random() < 0.001 * deltaTime / 16) {
                    // Enhanced: wider and more scattered landing area, especially in foreground
                    const horizontalSpread = 30 + Math.random() * 40; // 30-70px horizontal variance
                    const xOffset = (Math.random() - 0.5) * horizontalSpread;
                    birdPoops.push({
                        x: this.x + xOffset,
                        y: this.y,
                        size: 3 + Math.random() * 2, // Reduced from 5 + random * 3
                        yVelocity: 1 + Math.random() * 0.5, // Slight velocity variance
                        grounded: false,
                        timer: 0,
                        foregroundDepth: Math.random() < 0.4 // 40% chance for deeper landing
                    });
                    this.lastPoopTime = now;
                    debugLog(`Bird pooped at (${this.x + xOffset}, ${this.y})`);
                }
                
                this.stateTimer += deltaTime;
                
                // Reset acceleration each frame
                this.acceleration = { x: 0, y: 0 };
                
                // Check if non-wild bird has a nest that needs maintenance
                if (!this.isWild && this.myNest && this.myNest.needsMaintenance && 
                    this.state !== BIRD_STATES.BUILDING && Math.random() < 0.02) {
                    // Higher chance to check nest condition
                    if (this.checkNestCondition()) {
                        // Will transition to maintenance
                        return false; // Skip other state checks
                    }
                }


// Enhanced tree collision avoidance
if (this.state === BIRD_STATES.FLYING) {
    // Check for nearby trees that might cause problems
    for (const tree of trees) {
        const distToTree = Math.abs(this.x - tree.x);
        const treeWidth = tree.trunkWidth * tree.scale;
        
        // If very close to a tree trunk horizontally
        if (distToTree < treeWidth * 1.5) {
            // Check if we're at trunk height (not in the leafy part)
            const trunkTop = tree.y - tree.trunkHeight * tree.scale;
            if (this.y > trunkTop) {
                // Apply stronger horizontal force away from tree
                const pushDirection = this.x < tree.x ? -1 : 1;
                const pushStrength = 0.1; // Stronger push than normal
                
                this.applyForce({
                    x: pushDirection * pushStrength,
                    y: -0.05 // Always push slightly upward to help escape
                });
                
                // If extremely close to tree, make an emergency maneuver
                if (distToTree < treeWidth * 0.8) {
                    // Emergency evasion - stronger push
                    this.velocity.x = pushDirection * this.baseSpeed;
                    this.velocity.y = -this.baseSpeed * 0.5;
                    
                    // Update direction
                    this.direction = pushDirection;
                    
                    // Generate a path away from the tree if stuck for too long
                    if (!this.treeStuckTime) this.treeStuckTime = 0;
                    this.treeStuckTime += 16;
                    
                    if (this.treeStuckTime > 500) {
                        // Clear path and create a new one away from the tree
                        this.path = [];
                        this.pathIndex = 0;
                        
                        // Target position away from tree
                        const targetX = tree.x + (pushDirection * 150);
                        const targetY = Math.min(this.y - 50, tree.y - tree.trunkHeight * tree.scale - 20);
                        
                        this.generatePath(targetX, targetY);
                        debugLog(`Emergency evasion from tree at (${tree.x})`);
                        this.treeStuckTime = 0;
                    }
                }
            }
        } else {
            // Reset tree stuck time when not near trees
            this.treeStuckTime = 0;
        }
    }
}

                // === NEW BEHAVIOR UPDATES ===
                // Update flocking behaviors
                const flockmates = this.getFlockmates();

                // Update sentinel role
                if (!this.isWild && flockmates.length > 0) {
                    this.updateSentinelRole(flockmates);
                }

                // Contact calls - check if far from flock
                if (flockmates.length > 0 && Math.random() < 0.01) {
                    this.checkContactCall();
                }

                // Decrease fear level over time
                if (this.fearLevel > 0) {
                    this.fearLevel = Math.max(0, this.fearLevel - 0.001 * deltaTime / 16);
                }

                // Update defeat timer
                if (this.defeatedRecently) {
                    this.defeatTimer += deltaTime;
                    if (this.defeatTimer > 10000) {
                        this.defeatedRecently = false;
                        this.defeatTimer = 0;
                    }
                }

                // Clean up old food memory (reuse 'now' from earlier)
                this.foodMemory = this.foodMemory.filter(f => now - f.timestamp < FOOD_KNOWLEDGE_DURATION);

                // Check for owl/crow (predators) to mob
                if (!this.isWild && !this.isMobbing && flockmates.length >= 2) {
                    // Check for nearby owls
                    for (const owl of owls) {
                        if (distance(this.x, this.y, owl.x, owl.y) < 250) {
                            // High aggression birds more likely to initiate mobbing
                            if (Math.random() < this.aggression * 0.1) {
                                this.startMobbing(owl.x, owl.y, 'owl');
                                this.recordDanger(owl.x, owl.y, 'owl');
                                break;
                            }
                        }
                    }
                    // Check for nearby crows
                    for (const crow of crows) {
                        if (distance(this.x, this.y, crow.x, crow.y) < 200) {
                            if (Math.random() < this.aggression * 0.05) {
                                this.startMobbing(crow.x, crow.y, 'crow');
                                this.recordDanger(crow.x, crow.y, 'crow');
                                break;
                            }
                        }
                    }
                }

                // Update ground status (RESPONSIVE)
                const groundY = canvas.height * GROUND_HEIGHT_RATIO;
                const responsiveGroundThreshold = 10 * getResponsiveScale();
                this.isOnGround = Math.abs(this.y - groundY) < responsiveGroundThreshold && Math.abs(this.velocity.y) < 0.5;

                // Update bird based on its current state
                switch (this.state) {
                    case BIRD_STATES.IDLE:
                        // Apply air resistance
                        this.velocity.x *= AIR_RESISTANCE;
                        this.velocity.y *= AIR_RESISTANCE;

                        // Apply slight gravity
                        this.applyForce({ x: 0, y: GRAVITY });

                        // Random chirping while idle (ambient sounds)
                        if (Math.random() < 0.005) { // ~0.5% chance per frame (ambient)
                            const chirpTypes = [CHIRP_TYPES.SOCIAL, CHIRP_TYPES.CONTACT_CALL];
                            this.chirp(chirpTypes[Math.floor(Math.random() * chirpTypes.length)], 0.5);
                        }

                        // Check for baby birds needing feeding - higher priority than hunger
                        if (!this.isWild && babyBirds.length > 0 && Math.random() < 0.05) {
                            // Check more frequently for babies that need feeding
                            let hungryBaby = babyBirds.find(baby => baby.timeSinceLastMeal > 30);
                            if (hungryBaby) {
                                this.findBabyBirds();
                                break;
                            }
                        }
                        
// Check for shelter in birdhouses when raining or night
if ((isRaining || timeOfDay >= 1) && Math.random() < 0.4) { // 40% chance to seek shelter
        if (this.findBirdhouse()) {
            break; // Skip other state transitions
        }
    }


                        // Check for state transitions
                        // PRIORITY: Check for player-added food FIRST (even when not hungry)
                        const playerFood = foodItems.find(f => f.playerAdded &&
                            distance(this.x, this.y, f.x, f.y) < 400 &&
                            !this.isDangerZone(f.x, f.y));

                        if (playerFood && Math.random() < 0.80) {
                            // 80% chance to investigate player food even when not hungry
                            this.target = {
                                type: 'food',
                                food: playerFood,
                                x: playerFood.x,
                                y: playerFood.y
                            };
                            this.state = BIRD_STATES.HUNTING;
                            this.stateTimer = 0;
                            debugLog(`Bird investigating PLAYER-ADDED food even though not hungry!`);
                        } else if (this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                            // Hungry - go find food
                            this.findFoodSource();
                        } else if (this.stateTimer > Math.max(MIN_STATE_DURATION, BIRD_STATE_DURATION.IDLE) || Math.random() < 0.0001) { // V40: Reduced random transitions for calmness
                            // Transition to another state
                            const r = Math.random();

                            // NEW: Direct transition to hopping if already on ground (RESPONSIVE)
                            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
                            const nearGroundThreshold = 50 * getResponsiveScale();
                            if (Math.abs(this.y - groundY) < nearGroundThreshold && Math.random() < 0.3) { // 30% chance if near ground
                                this.y = groundY + 40; // Position on ground
                                this.velocity = { x: 0, y: 0 };
                                this.state = BIRD_STATES.HOPPING;
                                this.stateTimer = 0;
                                this.hopData = null;
                                debugLog(`Bird transitioning from IDLE to HOPPING on ground`);
                                break;
                            }

                            // FIX: CHECK FOR BATHING FIRST - check both puddles and ponds:
                            if ((puddles.length > 0 || ponds.length > 0) && Math.random() < 0.4) { // 40% chance to bathe if water exists
                                this.findPuddle();
                            }

                            // V26: Adjusted state preferences for more perching
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 50) {
                                // Go find food if somewhat hungry
                                this.findFoodSource();
                            } else if (!this.isWild && !this.myNest && r < 0.30) { // Increased: 30% chance to collect nest materials for more frequent nests
                                this.findTwigs();
                            } else if (r < BIRD_STATE_PREFERENCES.HOPPING) { // NEW: Check for hopping preference
                                // Prefer hopping on ground for foraging
                                const targetX = Math.random() * canvas.width;
                                this.path = [
                                    { x: this.x, y: this.y },
                                    { x: targetX, y: groundY + 40 }
                                ];
                                this.pathIndex = 0;
                                this.intendToHop = true;
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                debugLog(`Bird flying to ground to hop`);
                            } else if (r < BIRD_STATE_PREFERENCES.PERCHING) { // Increased perching preference
                                // Try to find perch
                                this.findPerch();
                            } else {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                // Set random direction to fly in
                                this.generatePath(
                                    Math.random() * canvas.width,
                                    100 + Math.random() * (canvas.height * 0.5 - 100)
                                );
                            }

                            // Add chance to build birdhouse (5% chance - increased to make birdhouses more common)
                            if (!this.isWild && Math.random() < 0.05 && this.materialsHeld === 0) {
                                this.findOrCreateBirdhouse();
                            }
                        } else {
                            // Random small movements
                            if (Math.random() < 0.05) {
                                this.applyForce({
                                    x: (Math.random() - 0.5) * 0.02,
                                    y: (Math.random() - 0.5) * 0.01
                                });
                            }

                            // Random chirping while idle (increased frequency)
                            if (Math.random() < 0.006) { // ~0.6% chance per frame
                                this.chirp(CHIRP_TYPES.SOCIAL, 0.5);
                            }
                        }
                        break;

                    case BIRD_STATES.PERCHED:
                        // V26: Check nest condition periodically when perched
                        // V40 FIX: Only check after minimum perch time (3 seconds)
                        if (this.stateTimer > 3000 && Math.random() < 0.03) {
                            if (this.checkNestCondition()) {
                                // Will transition to maintenance mode if needed
                                break;
                            }
                        }
                    
                        if (!this.perchTarget || !this.perchTarget.tree || trees.indexOf(this.perchTarget.tree) === -1) {
                            // Tree is gone, can't perch
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            this.perchTarget = null;
                            
                            // Generate path upward
                            this.generatePath(this.x, this.y - 50);
                            break;
                        }
                        
                        // Calculate distance to perch target
                        const perchDist = distance(this.x, this.y, this.perchTarget.x, this.perchTarget.y);

                        // V40: Much larger threshold for easier perching (was 5, now 20), RESPONSIVE
                        const perchThreshold = 20 * getResponsiveScale();
                        if (perchDist < perchThreshold) {
                            // Bird is perched, stop all movement
                            this.velocity = { x: 0, y: 0 };
                            this.acceleration = { x: 0, y: 0 };
                            
                            // Exactly position on perch point
                            this.x = this.perchTarget.x;
                            this.y = this.perchTarget.y;


                            // Check for baby birds more frequently when perched
                            // V40 FIX: Only check after minimum perch time to prevent instant exits
    if (!this.isWild && babyBirds.length > 0 && this.stateTimer > 5000 && Math.random() < 0.008) { // After 5 seconds perched
        // Look for very hungry babies (over 120 seconds without food)
        let veryHungryBaby = babyBirds.find(baby =>
            baby.timeSinceLastMeal > 120 &&
            (baby.associatedNest === this.myNest || !baby.associatedNest)
        );

        if (veryHungryBaby) {
            // Leave perch immediately to feed baby
            this.state = BIRD_STATES.FLYING;
            this.stateTimer = 0;
            this.perchTarget = null;
            this.findBabyBirds();
            debugLog(`${getBirdName(this)} leaving perch to feed VERY hungry baby`);
            break;
        }
    }
                            
                            // Decrease cooldown timer
                            this.directionChangeCooldown -= deltaTime;
                            
                            // Only update direction when cooldown expires
                            if (this.directionChangeCooldown <= 0) {
                                // Face the correct direction based on position in tree
                                if (this.perchTarget.inLeaves) {
                                    // Even less frequent direction changes in leaves
                                    this.direction = Math.random() < 0.2 ? -1 : 1; // Reduced from 0.5
                                } else {
                                    // Face toward tree trunk on branches - no randomness
                                    this.direction = this.x < this.perchTarget.tree.x ? 1 : -1;
                                }
                                
                                // V26: Even longer cooldown for more stable perching
                                this.directionChangeCooldown = 8000 + Math.random() * 12000; // Increased from 5-15 seconds
                            }
                            
                            // Bird behavior while perched
                            this.pecking = Math.random() < 0.1;
                            if (this.pecking) {
                                this.peckTimer = (this.peckTimer + 1) % 100;
                            }

                            // Random chirping while perched (ambient sounds)
                            if (Math.random() < 0.008) { // ~0.8% chance per frame
                                const chirpTypes = [CHIRP_TYPES.SOCIAL, CHIRP_TYPES.CONTACT_CALL, CHIRP_TYPES.TERRITORIAL];
                                this.chirp(chirpTypes[Math.floor(Math.random() * chirpTypes.length)], 0.6);
                            }
                            
                            // Check if there are squirrels nearby
                            // V40 FIX: Allow minimum perch time even with squirrels (birds need to settle first)
                            if (this.stateTimer > 2000) { // Only check after 2 seconds perched
                                const nearbySquirrel = squirrels.find(squirrel =>
                                    squirrel.climbingTree === this.perchTarget.tree &&
                                    distance(squirrel.x, squirrel.y, this.x, this.y) < 60
                                );

                                if (nearbySquirrel) {
                                    // Flee from squirrel
                                    this.flee(nearbySquirrel.x, nearbySquirrel.y);
                                    debugLog(`Bird fleeing from squirrel in tree!`);
                                    break;
                                }
                            }

                            // Check for baby birds while perched if bird has a nest with babies
                            // V40 FIX: Only check after minimum perch time and reduce frequency
                            if (!this.isWild && this.myNest && babyBirds.length > 0 && this.stateTimer > 10000 && Math.random() < 0.001) {
                                // Check after 10 seconds perched, 0.1% chance per frame (~6% per second)
                                // Check if there are hungry babies in this bird's nest
                                let hungryBaby = babyBirds.find(baby =>
                                    baby.associatedNest === this.myNest &&
                                    baby.timeSinceLastMeal > 20 // Reduced threshold from 40
                                );

                                if (hungryBaby) {
                                    this.findBabyBirds();
                                    debugLog(`${getBirdName(this)} leaving perch to feed hungry baby`);
                                    break;
                                }
                            }

                            // Leave perch after a while or if hungry
                            // NEW: Transition to sleeping at night (only after being perched for a while)
                            const isNightTime = timeOfDay >= 1;
                            if (isNightTime && this.stateTimer > 30000 && Math.random() < 0.0005) {
                                // After 30 seconds perched, 0.05% chance per frame (~3% per second)
                                this.state = BIRD_STATES.SLEEPING;
                                this.stateTimer = 0;
                                debugLog(`${getBirdName(this)} fell asleep on perch`);
                                break;
                            }

                            // PRIORITY: Check for player-added food FIRST (even when not hungry)
                            // V40 FIX: Only check after substantial perch time (90 seconds) so birds actually rest first
                            const playerFoodFromPerch = foodItems.find(f => f.playerAdded &&
                                distance(this.x, this.y, f.x, f.y) < 400 &&
                                !this.isDangerZone(f.x, f.y));

                            if (playerFoodFromPerch && this.stateTimer > 90000 && Math.random() < 0.15) {
                                // 15% chance to leave perch for player food after 90 seconds resting
                                this.target = {
                                    type: 'food',
                                    food: playerFoodFromPerch,
                                    x: playerFoodFromPerch.x,
                                    y: playerFoodFromPerch.y
                                };
                                this.state = BIRD_STATES.HUNTING;
                                this.stateTimer = 0;
                                this.perchTarget = null;
                                debugLog(`Bird leaving perch to investigate PLAYER-ADDED food!`);
                                break;
                            }

                            // V40 CRITICAL FIX: Birds must rest for minimum time before hunger can force them to leave
                            const minPerchTimeBeforeHungry = 60000; // 60 seconds minimum rest
                            const canLeaveForHunger = this.stateTimer > minPerchTimeBeforeHungry &&
                                                     this.hunger > HUNGER_CRITICAL_THRESHOLD - 50;

                            if (this.stateTimer > BIRD_STATE_DURATION.PERCHED ||
                                canLeaveForHunger ||
                                Math.random() < 0.0001) { // V40: TINY chance to leave perch early - birds need chill!

                                // Decide what to do next
                                if (canLeaveForHunger) {
                                    // Go find food (but only after resting for 60 seconds)
                                    this.findFoodSource();
                                    debugLog(`${getBirdName(this)} leaving perch after resting - now hungry`);
                                } else if (!this.isWild && !this.myNest && Math.random() < 0.2) {
                                    // Balanced: 20% chance to collect nest materials
                                    this.findTwigs();
                                } else if (Math.random() < 0.4) { // Reduced from 0.6 - less likely to fly away
                                    // Just fly somewhere else rather than another tree
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                    
                                    // Create a path away from the tree first
                                    const dirX = this.perchTarget.tree.x > this.x ? -50 : 50; // Stronger push away
                                    this.generatePath(this.x + dirX, this.y - 30);
                                } else {
                                    // Find a different perch
                                    this.findPerch();
                                }
                            }
                            
                            // Special case: if in the rain, seek shelter after a while
                            if (isRaining && this.stateTimer > 5000 && Math.random() < 0.1) {
                                this.state = BIRD_STATES.SHELTERING;
                                this.stateTimer = 0;
                            }
                            
                        } else {
                            // Moving toward perch
                            const dx = this.perchTarget.x - this.x;
                            const dy = this.perchTarget.y - this.y;
                            const perchDir = normalize(dx, dy);

                            this.applyForce({
                                x: perchDir.x * 0.01,
                                y: perchDir.y * 0.01
                            });

                            // Slow down as we approach the perch (minimal slowdown to maintain speed)
                            const slowdownFactor = Math.min(1, perchDist / 100);
                            this.velocity.x *= Math.min(AIR_RESISTANCE, 0.97 + slowdownFactor * 0.02);
                            this.velocity.y *= Math.min(AIR_RESISTANCE, 0.97 + slowdownFactor * 0.02);

                            // If perching is taking too long, give up
                            if (this.stateTimer > 30000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                this.perchTarget = null;
                                
                                // Fly away from failed perch
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.HUNTING:
                        // Check if target is valid
                        if (!this.target ||
                            (this.target.type === 'worm' && worms.indexOf(this.target.worm) === -1) ||
                            (this.target.type === 'food' && foodItems.indexOf(this.target.food) === -1) ||
                            (this.target.type === 'bush' && (bushes.indexOf(this.target.bush) === -1 || this.target.bush.fruitCount === 0))) {
                            // Target is gone or bush has no more fruit, go back to flying
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            this.target = null;
                            break;
                        }
                        
                        // Move toward target
                        const huntTargetDist = distance(this.x, this.y, this.target.x, this.target.y);
                        
                        if (huntTargetDist < 25) { // Increased from 10 - easier to collect food
                            // Check dominance hierarchy - lower aggression birds wait for dominant birds
                            // Reuse flockmates declared earlier in update()
                            const dominantBirdsNearby = this.getFlockmates().filter(b =>
                                b.aggression > this.aggression &&
                                distance(this.x, this.y, b.x, b.y) < 50 &&
                                b.state === BIRD_STATES.HUNTING
                            );

                            // If dominant birds nearby and this bird is submissive, wait
                            if (dominantBirdsNearby.length > 0 && this.aggression < 0.6) {
                                // Wait 1-2 seconds before feeding
                                if (this.stateTimer < 1500) {
                                    this.velocity.x *= 0.9;
                                    this.velocity.y *= 0.9;
                                    break;
                                }
                            }

                            // Reached target - check if ground food
                            const isGroundFood = (this.target.type === 'worm' || this.target.type === 'food') &&
                                this.target.y > canvas.height * GROUND_HEIGHT_RATIO - 50;

                            if (isGroundFood && huntTargetDist < 30) {
                                // Transition to pecking behavior instead of instant eating
                                this.startPecking();
                                break;
                            }

                            // Eat it (for non-ground food or baby feeding)
                            if (this.target.type === 'worm') {
                                const wormIndex = worms.indexOf(this.target.worm);
                                if (wormIndex !== -1) {
                                    worms.splice(wormIndex, 1);
                                }
                                // Worms are more nutritious
                                this.hunger = Math.max(0, this.hunger - 150); // Increased from 120
                                debugLog(`Bird ate worm at (${this.target.x}, ${this.target.y})`);
                            } else if (this.target.type === 'food') {
                                const foodIndex = foodItems.indexOf(this.target.food);
                                if (foodIndex !== -1) {
                                    foodItems.splice(foodIndex, 1);
                                }
                                this.hunger = Math.max(0, this.hunger - 100); // Increased from 80
                                debugLog(`Bird ate food at (${this.target.x}, ${this.target.y})`);
                            } else if (this.target.type === 'bush') {
                                // Pick fruit from bush
                                if (this.target.bush && bushes.indexOf(this.target.bush) !== -1) {
                                    const fruitItem = this.target.bush.pickFruit();
                                    if (fruitItem) {
                                        // Add fruit to ground food items
                                        foodItems.push(fruitItem);
                                        this.hunger = Math.max(0, this.hunger - 90); // Nutritious!
                                        debugLog(`Bird picked ${this.target.bush.fruitType} from bush at (${this.target.x}, ${this.target.y})`);
                                    }
                                }
                            } else if (this.target.type === 'baby') {
                                // Handle feeding baby birds with improved behavior
                                if (this.target.baby && babyBirds.indexOf(this.target.baby) !== -1) {
                                    // Feed the baby bird
                                    // FIX: Feed baby - check if bird has a worm
                                    this.target.baby.feed();

                                    if (this.carryingWorm) {
                                        // Bird fed a worm to baby! Less energy cost
                                        this.hunger += 10;
                                        this.carryingWorm = false;
                                        debugLog(`Bird fed baby a WORM at (${this.target.x}, ${this.target.y})! üêõ`);

                                        // Special worm feeding effect (bigger, different color)
                                        specialEffects.push({
                                            x: this.target.baby.x,
                                            y: this.target.baby.y - 15,
                                            type: 'worm-feeding',
                                            timer: 0,
                                            duration: 1500,
                                            emoji: 'üêõ'
                                        });
                                    } else {
                                        // Normal feeding costs more energy
                                        this.hunger += 20;
                                        debugLog(`Bird fed baby at (${this.target.x}, ${this.target.y})`);

                                        // Normal feeding effect
                                        specialEffects.push({
                                            x: this.target.baby.x,
                                            y: this.target.baby.y - 10,
                                            type: 'feeding',
                                            timer: 0,
                                            duration: 1000
                                        });
                                    }

                                    // Visual effect for feeding
                                    this.pecking = true;
                                    this.peckTimer = 0;

                                    // After feeding, possibly stay to feed more or look for more food
                                    if (Math.random() < 0.3 && this.hunger < 150) {
                                        // Stay with the baby a bit longer
                                        this.state = BIRD_STATES.RESTING;
                                        this.stateTimer = 0;
                                        this.x = this.target.x + (this.direction * 10);
                                        this.y = this.target.y;
                                    } else if (this.hunger > 150) {
                                        // Go find more food if bird is getting hungry
                                        this.findFoodSource();
                                    } else {
                                        // Look for another baby to feed
                                        setTimeout(() => {
                                            if (!this.isWild && birds.indexOf(this) !== -1) {
                                                this.findBabyBirds();
                                            }
                                        }, 2000);
                                    }
                                }
                            }
                            
                            // Start foraging on the ground (RESPONSIVE)
                            const forageGroundThreshold = 30 * getResponsiveScale();
                            if (this.y > canvas.height * GROUND_HEIGHT_RATIO - forageGroundThreshold) { // Increased from 20, RESPONSIVE
                                this.state = BIRD_STATES.FEEDING;
                                this.stateTimer = 0;
                                debugLog(`Bird started foraging on ground`);
                            } else {
                                // If not close to ground, maybe look for more food
                                if (this.hunger > 100 && Math.random() < 0.6) { // Reduced from 0.7 - less hunting
                                    this.findFoodSource();
                                } else {
                                    // V26: Increased chance to perch after eating
                                    if (Math.random() < 0.6) { // Increased from ~0.3
                                        this.findPerch();
                                    } else {
                                        this.state = BIRD_STATES.FLYING;
                                        this.stateTimer = 0;
                                    }
                                }
                            }
                            
                            this.target = null;
                            
                        } else {
                            // Move toward target with adjusted speed based on distance
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // If getting closer to target, start slowing down
                            const speedFactor = huntTargetDist < 30 ? 
                                0.3 + huntTargetDist / 30 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) { // More sensitive direction change
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If hunting is taking too long, give up
                            if (this.stateTimer > 7000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                this.target = null;
                                
                                // Generate a new flight path
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    Math.random() * (canvas.height * GROUND_HEIGHT_RATIO - 20)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.COLLECTING:
                        // Check if target is valid
                        if (!this.target || 
                            (this.target.type === 'twig' && twigs.indexOf(this.target.twig) === -1)) {
                            // Target is gone, go back to flying
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            this.target = null;
                            debugLog("Bird lost target while collecting");
                            break;
                        }

                        const targetDist = distance(this.x, this.y, this.target.x, this.target.y);
                        
                        if (targetDist < 20) { // Increased from 10 - easier to collect twigs
                            // Reached target - collect it
                            if (this.target.type === 'twig') {
                                const twigIndex = twigs.indexOf(this.target.twig);
                                if (twigIndex !== -1) {
                                    // Check if this twig is special
                                    this.hasSpecialTwig = this.target.twig.isSpecial;
                                    twigs.splice(twigIndex, 1);
                                    this.materialsHeld = 1; // Carrying one twig
                                    debugLog(`Bird collected${this.hasSpecialTwig ? ' special' : ''} twig.`);
                                }
                            }
                            
                            // Now find/build a nest with high priority
                            if (this.isWild) {
                                // Wild birds don't build nests - just drop the twig
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                            } else if (this.myNest) {
                                // Already have a nest - go build it with high priority
                                this.state = BIRD_STATES.BUILDING;
                                this.stateTimer = 0;
                            } else if (this.buildingBirdhouse && this.buildingBirdhouse.isComplete === false) {
                                // Building a birdhouse
                                this.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                                this.stateTimer = 0;
                            } else {
                                // No nest yet - find/create one
                                this.findOrCreateNest();
                            }
                            
                            this.target = null;
                            
                        } else {
                            // Move toward twig
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // Slow down as we approach
                            const speedFactor = targetDist < 30 ? 
                                0.3 + targetDist / 30 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If collecting is taking too long, give up
                            if (this.stateTimer > 7000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                this.target = null;
                                
                                // Try again elsewhere
                                this.findTwigs();
                            }
                        }
                        break;

                    case BIRD_STATES.BUILDING:
                        // Check if nest is still valid
                        if (!this.myNest || nests.indexOf(this.myNest) === -1) {
                            // Nest is gone
                            this.myNest = null;
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            
                            // Drop materials
                            if (this.materialsHeld > 0) {
                                twigs.push({
                                    x: this.x,
                                    y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                    size: 10 + Math.random() * 8,
                                    angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                    isSpecial: this.hasSpecialTwig,
                                    offshoots: []
                                });
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                            }
                            break;
                        }
                        
                        // Move toward nest
                        const nestDist = distance(this.x, this.y, this.myNest.x, this.myNest.y);
                        
                        if (nestDist < 25) { // Increased from 15 - easier to reach nest
                            // Reached nest - add materials
                            if (this.materialsHeld > 0) {
                                const isComplete = this.myNest.addMaterial();
                                debugLog(`Bird added ${this.hasSpecialTwig ? 'special ' : ''}material to nest at (${this.myNest.x}, ${this.myNest.y}). Materials: ${this.myNest.materialsCollected}/${NEST_MATERIALS_NEEDED}`);
                                
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                                
                                // Set this nest as occupied by this bird
                                this.myNest.occupiedBy = this;
                                
                                // FIX: Create EGG first, which will hatch after 1-2 days
                                if (this.myNest.isComplete && this.myNest.readyForBabies) {
                                    this.myNest.readyForBabies = false; // Prevent multiple eggs

                                    this.myNest.lastBabyTime = Date.now(); // Record when egg was laid

                                    // Create an EGG instead of baby bird
                                    const egg = new Egg(this.myNest.x, this.myNest.y, this.birdType, this.myNest);
                                    eggs.push(egg);
                                    debugLog(`Egg laid in nest at (${this.myNest.x}, ${this.myNest.y}), will hatch in ${egg.cyclesToHatch.toFixed(1)} in-game days`);

                                    // Create diary entry for egg
                                    const parentName = getBirdName(this);
                                    addDiaryEntry(`${parentName} laid an egg! It will hatch soon.`, 'birth');

                                    // FIXED: Removed obsolete code that referenced undefined 'baby' variable
                                    // Parent bird will naturally care for baby once egg hatches
                                }
                                
                                // Reset maintenance need if it was needed
                                if (this.myNest.needsMaintenance) {
                                    this.myNest.needsMaintenance = false;
                                    this.lastNestCheckTime = Date.now();
                                }
                            }
                            
                            // Finished building/maintaining - perch on/near nest
                            if (!this.myNest.isComplete || this.myNest.needsMaintenance) {
                                // Get more materials with high priority
                                this.findTwigs();
                            } else if (Math.random() < 0.3) { // Reduced from 0.4
                                // Maybe look for food
                                this.findFoodSource();
                            } else {
                                // Find perch near nest
                                if (babyBirds.length > 0 && Math.random() < 0.7) { // Increased from 0.5
                                    // Look for babies to feed
                                    this.findBabyBirds();
                                } else if (Math.random() < 0.5) {
                                    // REALISTIC: Sit on nest to keep it warm (incubation behavior)
                                    this.state = BIRD_STATES.NEST_SITTING;
                                    this.stateTimer = 0;
                                } else {
                                    // Rest at nest
                                    this.state = BIRD_STATES.RESTING;
                                    this.stateTimer = 0;
                                }
                            }
                            
                        } else {
                            // Move toward nest
                            const dx = this.myNest.x - this.x;
                            const dy = this.myNest.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // Slow down as we approach
                            const speedFactor = nestDist < 30 ? 
                                0.3 + nestDist / 30 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If building trip is taking too long, give up building for now
                            if (this.stateTimer > 10000) {
                                // Drop materials
                                if (this.materialsHeld > 0) {
                                    twigs.push({
                                        x: this.x,
                                        y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                        size: 10 + Math.random() * 8,
                                        angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                        isSpecial: this.hasSpecialTwig,
                                        offshoots: []
                                    });
                                    this.materialsHeld = 0;
                                    this.hasSpecialTwig = false;
                                }
                                
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Generate a new flight path away from trouble
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.BUILDING_BIRDHOUSE:
                       // Check if birdhouse still exists
                        if (!this.buildingBirdhouse || birdhouses.indexOf(this.buildingBirdhouse) === -1) {
                            // Birdhouse is gone
                            this.buildingBirdhouse = null;
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            
                            // Drop materials
                            if (this.materialsHeld > 0) {
                                twigs.push({
                                    x: this.x,
                                    y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                    size: 10 + Math.random() * 8,
                                    angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                    isSpecial: this.hasSpecialTwig,
                                    offshoots: []
                                });
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                            }
                            break;
                        }
                        
                        // Move toward birdhouse
                        const birdhouseDist = distance(this.x, this.y, this.buildingBirdhouse.x, this.buildingBirdhouse.y);
                        
                        if (birdhouseDist < 30) { // Easier to reach birdhouse
                            // Reached birdhouse - add materials
                            if (this.materialsHeld > 0) {
                                const isComplete = this.buildingBirdhouse.addMaterial();
                                debugLog(`Bird added ${this.hasSpecialTwig ? 'special ' : ''}material to birdhouse at (${this.buildingBirdhouse.x}, ${this.buildingBirdhouse.y}). Materials: ${this.buildingBirdhouse.materialsCollected}/${BIRDHOUSE_MATERIALS_NEEDED}`);
                                
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                                
                                // If birdhouse is complete, perch on it
                                if (this.buildingBirdhouse.isComplete) {
                                    // Add bird as occupant
                                    this.buildingBirdhouse.addOccupant(this);
                                    
                                    // Rest at birdhouse
                                    this.state = BIRD_STATES.RESTING;
                                    this.stateTimer = 0;
                                    debugLog(`Bird is now an occupant of the birdhouse`);
                                } else {
                                    // Get more materials
                                    this.findTwigs();
                                }
                            } else {
                                // Get more materials
                                this.findTwigs();
                            }
                            
                        } else {
                            // Move toward birdhouse
                            const dx = this.buildingBirdhouse.x - this.x;
                            const dy = this.buildingBirdhouse.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // Slow down as we approach
                            const speedFactor = birdhouseDist < 50 ? 
                                0.3 + birdhouseDist / 50 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If building trip is taking too long, give up
                            if (this.stateTimer > 10000) {
                                // Drop materials
                                if (this.materialsHeld > 0) {
                                    twigs.push({
                                        x: this.x,
                                        y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                        size: 10 + Math.random() * 8,
                                        angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                        isSpecial: this.hasSpecialTwig,
                                        offshoots: []
                                    });
                                    this.materialsHeld = 0;
                                    this.hasSpecialTwig = false;
                                }
                                
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Generate a new flight path
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.FEEDING:
                        // Bobbing motion while feeding
                        this.pecking = Math.random() < 0.7;
                        if (this.pecking) {
                            this.peckTimer = (this.peckTimer + 1) % 30;
                        }
                        
                        // Apply a small random force for natural movement
                        if (Math.random() < 0.1) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.02,
                                y: 0
                            });
                            
                            // Flip direction occasionally while foraging
                            if (Math.random() < 0.1) {
                                this.direction *= -1;
                            }
                        }
                        
                        // Check for nearby food with larger detection radius (RESPONSIVE)
                        for (let i = foodItems.length - 1; i >= 0; i--) {
                            const food = foodItems[i];
                            const eatFoodThreshold = 30 * getResponsiveScale();
                            if (distance(this.x, this.y, food.x, food.y) < eatFoodThreshold) { // Increased from 20, RESPONSIVE
                                foodItems.splice(i, 1);
                                this.hunger = Math.max(0, this.hunger - 100); // Increased from 80
                                debugLog(`Bird found and ate food while foraging.`);
                            }
                        }
                        
                        // Check for worms with larger detection radius
                        for (let i = worms.length - 1; i >= 0; i--) {
                            const worm = worms[i];
                            const eatWormThreshold = 30 * getResponsiveScale();
                            if (distance(this.x, this.y, worm.x, worm.y) < eatWormThreshold) { // Increased from 20, RESPONSIVE
                                worms.splice(i, 1);
                                this.hunger = Math.max(0, this.hunger - 150); // Increased from 120
                                debugLog(`Bird found and ate worm while foraging.`);
                            }
                        }
                        
                        // V40: ENFORCE ground position with individual depth (like hopping), RESPONSIVE
                        const feedingGroundY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
                        const feedingTolerance = 10 * getResponsiveScale();
                        if (Math.abs(this.y - feedingGroundY) > feedingTolerance) {
                            this.y = feedingGroundY;
                            this.velocity.y = 0;
                        }
                        
                        // End feeding state after configured duration
                        if (this.stateTimer > BIRD_STATE_DURATION.FEEDING || this.hunger < 100) {
                            // REALISTIC: Birds often drink after eating dry food
                            if ((puddles.length > 0 || ponds.length > 0) && Math.random() < 0.7) {
                                this.state = BIRD_STATES.DRINKING;
                                this.stateTimer = 0;
                            }
                            // Or preen to clean beak
                            else if (Math.random() < 0.4) {
                                this.state = BIRD_STATES.PREENING;
                                this.stateTimer = 0;
                                this.isOnGround = Math.abs(this.y - (canvas.height * GROUND_HEIGHT_RATIO)) < (30 * getResponsiveScale());
                            }
                            // Continue if still hungry
                            else if (this.hunger > 200 && Math.random() < 0.4) {
                                // Still hungry - keep searching
                                this.findFoodSource();
                            } else if (!this.isWild && !this.myNest && Math.random() < 0.1) {
                                // Maybe collect nest materials (FIXED: removed twigs.length requirement)
                                this.findTwigs();
                            } else if (!this.isWild && this.myNest && this.myNest.isComplete && babyBirds.length > 0 && Math.random() < 0.4) {
                                // Look for babies to feed
                                this.findBabyBirds();
                            } else {
                                // Increased likelihood to perch rather than fly after feeding
                                if (Math.random() < 0.6) {
                                    this.findPerch();
                                } else {
                                    // Return to flying
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;

                                    // Fly upward
                                    this.generatePath(
                                        this.x + (Math.random() - 0.5) * 50,
                                        100 + Math.random() * 100
                                    );
                                }
                            }
                        }
                        break;

                    case BIRD_STATES.FLEEING:
                        // Strong upward and away motion
                        if (this.velocity.y > -1.0) {
                            this.applyForce({ x: 0, y: -0.05 });
                        }
                        
                        // Continue in flee direction
                        this.applyForce({ 
                            x: this.direction * 0.03, 
                            y: 0 
                        });
                        
                        // After fleeing for a while, transition to flying
                        if (this.stateTimer > BIRD_STATE_DURATION.FLEEING) {
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            
                            // Fly away in current direction
                            const targetX = this.x + this.direction * 200;
                            const targetY = Math.max(50, this.y - 100);
                            this.generatePath(targetX, targetY);
                        }
                        break;

                    case BIRD_STATES.SHELTERING:
                        // Stay in place
                        this.velocity.x *= 0.9;
                        this.velocity.y *= 0.9;
                        
                        // Random small movements
                        if (Math.random() < 0.05) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.01,
                                y: (Math.random() - 0.5) * 0.005
                            });
                        }
                        
                        // Occasional preening motion
                        this.pecking = Math.random() < 0.2;
                        
                        // End sheltering if rain stops or after a while
                        if (!isRaining || this.stateTimer > BIRD_STATE_DURATION.SHELTERING) {
                            // V26: More likely to perch after sheltering
                            if (Math.random() < 0.7) { // Increased from 0.5
                                // Find perch after sheltering
                                this.findPerch();
                            } else if (Math.random() < 0.5) {
                                // Look for food after sheltering
                                this.findFoodSource();
                            } else {
                                // Return to flying
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Fly somewhere
                                this.generatePath(
                                    Math.random() * canvas.width,
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.RESTING:
                        // V26: Check nest condition occasionally while resting
                        if (!this.isWild && this.myNest && Math.random() < 0.02) {
                            this.checkNestCondition();
                        }

                        // V40: ENFORCE ground position for resting birds (they were drifting!)
                        const restingGroundY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
                        this.y = restingGroundY;
                        this.velocity = { x: 0, y: 0 }; // Complete stillness while resting
                        this.acceleration = { x: 0, y: 0 };

                        // Occasional subtle direction change only
                        if (Math.random() < 0.01) {
                            this.direction *= -1;
                        }
                        
                        // End resting after a while or if hungry
                        if (this.stateTimer > BIRD_STATE_DURATION.RESTING || this.hunger > HUNGER_CRITICAL_THRESHOLD - 100) {
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 100) {
                                // Go find food
                                this.findFoodSource();
                            } else if (!this.isWild && babyBirds.length > 0 && Math.random() < 0.5) { // Reduced from 0.6
                                // Look for babies to feed
                                this.findBabyBirds();
                            } else if (wasRaining && puddles.length > 0 && Math.random() < 0.3) {
                                // Go take a bath in a puddle
                                this.findPuddle();
                            } else {
                                // V26: More likely to find a new perch than to fly
                                if (Math.random() < 0.6) { // 60% chance to perch
                                    this.findPerch();
                                } else {
                                    // Return to flying
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                    
                                    // Fly somewhere
                                    this.generatePath(
                                        Math.random() * canvas.width,
                                        100 + Math.random() * (canvas.height * 0.3)
                                    );
                                }
                            }
                        }
                        break;

                    case BIRD_STATES.SLEEPING:
                        // Birds sleep while perched at night
                        // Stay completely still with no movement
                        this.velocity.x = 0;
                        this.velocity.y = 0;
                        this.acceleration.x = 0;
                        this.acceleration.y = 0;

                        // Wake up if:
                        // 1. It becomes daytime
                        // 2. State timer exceeds duration
                        // 3. Very hungry
                        // 4. Danger nearby
                        // 5. V40 FIX: Rain or thunder (weather disturbance)
                        const isDaytime = timeOfDay < 1;
                        const nearbyDanger = rats.some(rat => distance(rat.x, rat.y, this.x, this.y) < 100) ||
                                           owls.some(owl => distance(owl.x, owl.y, this.x, this.y) < 150);
                        const weatherDisturbance = isRaining || isThundering;

                        if (isDaytime ||
                            this.stateTimer > BIRD_STATE_DURATION.SLEEPING ||
                            this.hunger > HUNGER_CRITICAL_THRESHOLD ||
                            nearbyDanger ||
                            weatherDisturbance) {

                            // Wake up and return to perching
                            this.state = BIRD_STATES.PERCHED;
                            this.stateTimer = 0;
                            const wakeReason = weatherDisturbance ? ' (disturbed by weather)' :
                                             nearbyDanger ? ' (danger nearby)' :
                                             isDaytime ? ' (dawn)' : '';
                            debugLog(`${getBirdName(this)} woke up from sleep${wakeReason}`);

                            // If no perch target, find one
                            if (!this.perchTarget) {
                                this.findPerch();
                            }
                        }
                        break;

                    case BIRD_STATES.BATHING: {
                        // FIX: Check for both puddles AND ponds
                        if (puddles.length === 0 && ponds.length === 0) {
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            break;
                        }

                        // Find nearest water source (puddle or pond)
                        let nearestWater = null;
                        let minDist = Infinity;
                        let waterType = null;

                        // Check puddles
                        for (const puddle of puddles) {
                            const dist = distance(this.x, this.y, puddle.x, puddle.y);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestWater = puddle;
                                waterType = 'puddle';
                            }
                        }

                        // Check ponds (prefer closer ponds)
                        for (const pond of ponds) {
                            const dist = distance(this.x, this.y, pond.x, pond.y);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestWater = pond;
                                waterType = 'pond';
                            }
                        }

                        if (!nearestWater || minDist > 50) {
                            // No water nearby, find one
                            this.findPuddle();
                            break;
                        }

                        // If already at water source
                        const bathingRadius = waterType === 'pond' ? 25 : 15; // Larger radius for ponds
                        if (minDist < bathingRadius) {
                            // Bathing behavior - animated fluttering
                            this.velocity.x *= 0.5;
                            this.velocity.y *= 0.5;
                            
                            // Splashing motions
                            if (Math.random() < 0.2) {
                                // FIX: Add ripple to water source (puddle or pond)
                                if (nearestWater.ripples) { // Check if it has ripples array
                                    nearestWater.ripples.push({
                                        size: 2,
                                        maxSize: 5 + Math.random() * 8,
                                        speed: 0.1 + Math.random() * 0.1
                                    });
                                }

                                // Random motion
                                this.applyForce({
                                    x: (Math.random() - 0.5) * 0.1,
                                    y: (Math.random() - 0.5) * 0.05
                                });
                            }
                            
                            // End bathing after a while
                            if (this.stateTimer > BIRD_STATE_DURATION.BATHING) {
                                // CRITICAL: Birds ALWAYS preen after bathing (realistic behavior)
                                this.state = BIRD_STATES.PREENING;
                                this.stateTimer = 0;
                                this.isOnGround = Math.abs(this.y - (canvas.height * GROUND_HEIGHT_RATIO)) < (30 * getResponsiveScale());
                            }
                        } else {
                            // FIX: Move toward water source (puddle or pond)
                            const dx = nearestWater.x - this.x;
                            const dy = nearestWater.y - this.y;
                            const dir = normalize(dx, dy);

                            this.applyForce({
                                x: dir.x * 0.01,
                                y: dir.y * 0.01
                            });

                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }

                            // If taking too long to reach water, give up
                            if (this.stateTimer > 5000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Fly somewhere else
                                this.generatePath(
                                    Math.random() * canvas.width,
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;
                    }

                    case BIRD_STATES.PREENING:
                        // Grooming feathers after bathing, eating, or while idle
                        this.velocity.x *= 0.9; // Slow movement while preening
                        this.velocity.y *= 0.9;

                        // Slight head/body movements simulating grooming
                        if (Math.random() < 0.15) {
                            this.applyForce({
                                x: (Math.random() - 0.5) * 0.008,
                                y: (Math.random() - 0.5) * 0.004
                            });
                        }

                        // Visual: Toggle pecking to simulate beak grooming motion
                        if (Math.random() < 0.3) {
                            this.pecking = !this.pecking;
                        }

                        // End preening after duration
                        if (this.stateTimer > BIRD_STATE_DURATION.PREENING) {
                            // After preening, birds usually rest or resume normal activity
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 100) {
                                this.findFoodSource();
                            } else if (this.isOnGround && Math.random() < 0.3) {
                                // Reduced chance to continue ground activities (0.4 -> 0.3)
                                // Only transition to hopping if bird hasn't been hopping recently
                                if (!this.lastHopTime || Date.now() - this.lastHopTime > 60000) {
                                    this.state = BIRD_STATES.HOPPING;
                                    this.stateTimer = 0;
                                    this.lastHopTime = Date.now();
                                } else {
                                    // Rest instead to prevent quick transitions
                                    this.state = BIRD_STATES.RESTING;
                                    this.stateTimer = 0;
                                }
                            } else if (Math.random() < 0.6) {
                                this.findPerch();
                            } else {
                                this.state = BIRD_STATES.RESTING;
                                this.stateTimer = 0;
                            }
                        }
                        break;

                    case BIRD_STATES.DRINKING: {
                        // Quick drinking behavior at water sources
                        this.velocity.x *= 0.85;
                        this.velocity.y *= 0.85;

                        // Find nearest water source (puddle or pond)
                        let nearestWater = null;
                        let waterDist = Infinity;

                        // Check puddles
                        for (const puddle of puddles) {
                            const dist = distance(this.x, this.y, puddle.x, puddle.y);
                            if (dist < waterDist) {
                                waterDist = dist;
                                nearestWater = { x: puddle.x, y: puddle.y, type: 'puddle' };
                            }
                        }

                        // Check ponds
                        for (const pond of ponds) {
                            const dist = distance(this.x, this.y, pond.x, pond.y);
                            if (dist < waterDist) {
                                waterDist = dist;
                                nearestWater = { x: pond.x, y: pond.y - pond.height / 2, type: 'pond' };
                            }
                        }

                        if (!nearestWater || waterDist > 100) {
                            // No water nearby, end drinking
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            break;
                        }

                        // At water - drinking
                        if (waterDist < 15) {
                            // Dipping head animation (use pecking)
                            if (Math.random() < 0.4) {
                                this.pecking = true;
                            } else {
                                this.pecking = false;
                            }

                            // Add small ripples if drinking from puddle
                            if (nearestWater.type === 'puddle') {
                                const puddle = puddles.find(p => p.x === nearestWater.x && p.y === nearestWater.y);
                                if (puddle && Math.random() < 0.1) {
                                    puddle.ripples.push({
                                        size: 1,
                                        maxSize: 3 + Math.random() * 3,
                                        speed: 0.05 + Math.random() * 0.05
                                    });
                                }
                            }

                            // End drinking after short duration
                            if (this.stateTimer > BIRD_STATE_DURATION.DRINKING) {
                                // After drinking, often preen
                                if (Math.random() < 0.5) {
                                    this.state = BIRD_STATES.PREENING;
                                    this.stateTimer = 0;
                                } else if (this.isOnGround) {
                                    this.state = BIRD_STATES.HOPPING;
                                    this.stateTimer = 0;
                                } else {
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                }
                            }
                        } else {
                            // Move toward water
                            const dx = nearestWater.x - this.x;
                            const dy = nearestWater.y - this.y;
                            const dir = normalize(dx, dy);

                            this.applyForce({
                                x: dir.x * 0.015,
                                y: dir.y * 0.01
                            });

                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                        }
                        break;
                    }

                    case BIRD_STATES.ALARM:
                        // Freeze response before fleeing - complete stillness
                        this.velocity.x = 0;
                        this.velocity.y = 0;
                        this.pecking = false;

                        // After brief freeze, transition to appropriate escape
                        if (this.stateTimer > BIRD_STATE_DURATION.ALARM) {
                            // Check if there are nearby flockmates
                            const flockmates = this.getFlockmates();
                            const nearbyFlockmates = flockmates.filter(b =>
                                distance(this.x, this.y, b.x, b.y) < 150
                            );

                            // If in group, might mob instead of flee
                            if (nearbyFlockmates.length >= 2 && Math.random() < 0.4) {
                                this.state = BIRD_STATES.MOBBING;
                                this.stateTimer = 0;
                            } else {
                                // Flee based on current position
                                if (this.isOnGround) {
                                    this.state = BIRD_STATES.FLEEING_GROUND;
                                } else {
                                    this.state = BIRD_STATES.FLEEING;
                                }
                                this.stateTimer = 0;
                            }
                        }
                        break;

                    case BIRD_STATES.NEST_SITTING:
                        // Sitting on nest to warm eggs/babies
                        if (!this.myNest || !nests.includes(this.myNest)) {
                            // No nest, can't sit
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            break;
                        }

                        // Stay at nest position
                        this.x = this.myNest.x;
                        this.y = this.myNest.y;
                        this.velocity = { x: 0, y: 0 };

                        // Occasional small adjustments
                        if (Math.random() < 0.05) {
                            this.applyForce({
                                x: (Math.random() - 0.5) * 0.002,
                                y: (Math.random() - 0.5) * 0.001
                            });
                        }

                        // Occasional chirping while sitting
                        if (Math.random() < 0.01) {
                            this.chirp(CHIRP_TYPES.SOCIAL, 0.3);
                        }

                        // Leave nest if hungry or after duration
                        if (this.hunger > HUNGER_CRITICAL_THRESHOLD || this.stateTimer > BIRD_STATE_DURATION.NEST_SITTING) {
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                                // Must find food
                                this.findFoodSource();
                            } else {
                                // Check on babies or rest
                                if (babyBirds.length > 0 && Math.random() < 0.6) {
                                    this.findBabyBirds();
                                } else {
                                    this.state = BIRD_STATES.RESTING;
                                    this.stateTimer = 0;
                                }
                            }
                        }
                        break;

                    case BIRD_STATES.FLYING:
                    default:
                        // V26: Check if non-wild bird has a nest that needs maintenance
                        if (!this.isWild && this.myNest && 
                            (this.myNest.needsMaintenance || !this.myNest.isComplete) && 
                            Math.random() < 0.03) {
                            // Higher chance to check nest condition
                            if (this.checkNestCondition()) {
                                break; // Skip other flying behaviors
                            }
                        }
                        
                        // V26: Additional damping for flying state to prevent excessive acceleration
                        this.velocity.x *= 0.97; // More damping
                        this.velocity.y *= 0.97; // More damping

                        // NEW: Calm behavior - birds should land on ground when flying near it
                        const groundY = canvas.height * GROUND_HEIGHT_RATIO;
                        const distanceToGround = Math.abs(this.y - groundY);

                        // RESPONSIVE: Scale ground activity trigger with screen height
                        const nearGroundDistance = 120 * getResponsiveScale();
                        if (distanceToGround < nearGroundDistance && Math.random() < 0.015) { // Significantly increased for much more ground activity
                            // Land on ground and rest/hop - prefer landing under trees
                            let landX = this.x + (Math.random() - 0.5) * 50;

                            // Check if there's a tree nearby to land under (RESPONSIVE)
                            const treeProximity = 150 * getResponsiveScale();
                            const nearbyTree = trees.find(tree =>
                                Math.abs(tree.x - this.x) < treeProximity && tree.health > 30
                            );

                            if (nearbyTree && Math.random() < 0.7) { // 70% chance to prefer tree
                                // Land under the tree for shade/shelter
                                landX = nearbyTree.x + (Math.random() - 0.5) * 60;
                                debugLog(`Bird choosing to land under tree for ground rest`);
                            }

                            // V40 CRITICAL FIX: Include groundDepth in target so it matches hopping state!
                            const targetGroundY = groundY + 40 + this.groundDepth;
                            this.path = [
                                { x: this.x, y: this.y },
                                { x: landX, y: targetGroundY }
                            ];
                            this.pathIndex = 0;
                            this.intendToHop = true;
                            this.hopData = null;
                            debugLog(`Bird landing on ground for calm behavior at (${landX}, ${targetGroundY})`);
                        }

                        // If we have a path, follow it
                        if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                            const waypoint = this.path[this.pathIndex];
                            const waypointDist = distance(this.x, this.y, waypoint.x, waypoint.y);

                            // V40: MUCH LARGER threshold for easier ground landing (was 5px, now 30px)
                            // RESPONSIVE: Scale with screen height for high-res monitors
                            const responsiveScale = getResponsiveScale();
                            const reachThreshold = this.intendToHop ? (30 * responsiveScale) : (20 * responsiveScale); // Birds can land easily now!

                            if (waypointDist < reachThreshold) {
                                // Reached waypoint, move to next
                                this.pathIndex++;
                                debugLog(`Bird reached waypoint ${this.pathIndex - 1} of ${this.path.length}, moving to next`);



                               // If reached final waypoint, clear path
if (this.pathIndex >= this.path.length) {
    // Check if we intended to hop
    // V40 CRITICAL FIX: Include groundDepth to match landing target and hopping state!
    const groundTargetY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
    const responsiveScale = getResponsiveScale();
    if (this.intendToHop && Math.abs(this.y - groundTargetY) < (50 * responsiveScale)) { // V40: Much more lenient (was 20px), RESPONSIVE
        // FIXED: Smooth easing to ground instead of instant positioning
        const easingSpeed = 0.3; // Gradual descent
        this.y += (groundTargetY - this.y) * easingSpeed;

        // Slow down velocity gradually
        this.velocity.x *= 0.8;
        this.velocity.y *= 0.7;

        // V40: Only transition when reasonably close (was 2px, now 15px for easy landing), RESPONSIVE
        if (Math.abs(this.y - groundTargetY) < (15 * responsiveScale)) {
            this.y = groundTargetY; // Snap to final position
            this.velocity = { x: 0, y: 0 }; // Full stop

            // IMPORTANT: Transition to hopping state
            this.state = BIRD_STATES.HOPPING;
            this.stateTimer = 0;
            this.intendToHop = false;
            this.hopData = null; // Force fresh initialization

            debugLog(`Bird smoothly landed and transitioning to hopping state at (${this.x}, ${this.y})`);
        }
    } else {
        // Normal path completion or not close enough to ground
        this.path = [];
        this.pathIndex = 0;
        this.intendToHop = false; // Reset intention if we didn't transition
    }
}
                            } else {
                                // Move toward waypoint
                                const dx = waypoint.x - this.x;
                                const dy = waypoint.y - this.y;
                                const dir = normalize(dx, dy);

                                // Adjust speed based on distance (RESPONSIVE)
                                const responsiveThreshold = 30 * responsiveScale;
                                const speedFactor = waypointDist < responsiveThreshold ?
                                    0.3 + waypointDist / responsiveThreshold * 0.7 : 1.0;
                                
                                this.applyForce({ 
                                    x: dir.x * 0.01 * speedFactor, // Reduced from 0.02
                                    y: dir.y * 0.005 * speedFactor // Reduced from 0.01
                                });
                                
                                // Face the direction of movement when significant
                                if (Math.abs(dx) > 2) { // More sensitive direction change
                                    this.direction = dx > 0 ? 1 : -1;
                                }
                            }
                        } else {
                            // No path, just fly naturally
                            // Apply a small random force
                            if (Math.random() < 0.1) {
                                this.applyForce({ 
                                    x: (Math.random() - 0.5) * 0.02,
                                    y: (Math.random() - 0.5) * 0.01
                                });
                            }
                            
                            // Apply a slight gravity
                            this.applyForce({ x: 0, y: GRAVITY * 0.5 });
                            
                            // Check for state transitions
                            if (this.stateTimer > Math.max(MIN_STATE_DURATION, BIRD_STATE_DURATION.FLYING)) {
                                // Choose a new random activity
                                const r = Math.random();
                                
                                if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 50) {
                                    // Always find food if hungry
                                    this.findFoodSource();
                                } else if (!this.isWild && !this.myNest && r < 0.1) {
                                    // Find building materials (FIXED: removed twigs.length requirement)
                                    this.findTwigs();
                                } else if (!this.isWild && Math.random() < 0.05 && this.materialsHeld === 0) {
                                    // Add chance to build birdhouse (5% chance - increased to make birdhouses more common)
                                    this.findOrCreateBirdhouse();


                                    
                                } 
                                
                                
                                else if (!this.isWild && Math.random() < 0.1) {
        this.findBirdhouse();
    }
                                
                                
                                else if (r < BIRD_STATE_PREFERENCES.PERCHING) { // Significantly increased - 55% chance
                                    // Try to perch (much more likely now)
                                    this.findPerch();
           
    
                                } else if (r < BIRD_STATE_PREFERENCES.PERCHING + BIRD_STATE_PREFERENCES.FEEDING) {
   // Go to ground to forage (below ground line to reach worms/branches)
   // Reuse groundY from earlier in update() - just reference it
   const targetX = Math.random() * canvas.width;
   const forageGroundY = canvas.height * GROUND_HEIGHT_RATIO + 20;

   // Very high chance to hop on ground (increased from 0.95 to 0.98)
   if (Math.random() < 0.98) {
       // Create a direct path to ground
       this.path = [
           { x: this.x, y: this.y }, // Current position
           { x: targetX, y: forageGroundY } // Direct to ground
       ];
       this.pathIndex = 0;

       // Set flag to mark for hopping once we reach ground
       this.intendToHop = true;

       // Clear any existing hop data to ensure fresh start
       this.hopData = null;

       debugLog(`Bird flying directly to ground at (${targetX}, ${forageGroundY}) to hop`);
   }

                                } else {
                                    // Go to idle state
                                    this.state = BIRD_STATES.IDLE;
                                    this.stateTimer = 0;
                                    
                                    // Random horizontal force
                                    this.applyForce({ 
                                        x: (Math.random() - 0.5) * 0.1,
                                        y: 0
                                    });
                                }
                            }
                        }
                        break;







                    

                        case BIRD_STATES.HOPPING:
    // CRITICAL FIX: Immediately verify and enforce ground position (allow hopping below ground into grass)
    // Use bird's individual groundDepth for depth perception (some birds appear in foreground)
    const birdGroundY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
    const hoppingTolerance = 35 * getResponsiveScale(); // RESPONSIVE tolerance
    if (Math.abs(this.y - birdGroundY) > hoppingTolerance) { // Increased tolerance for deeper ground
        debugLog(`Fixing bird position in hopping state: ${this.y} ‚Üí ${birdGroundY}`);
        this.y = birdGroundY;
        this.velocity = { x: 0, y: 0 };
    }

    // Define hopping ground level once to ensure consistency (below ground line for worms/branches) - deeper for better ground presence
    const hoppingGroundY = birdGroundY;

    // Only stay in hopping state for a reasonable duration
    if (this.stateTimer < BIRD_STATE_DURATION.HOPPING) {
        // Initialize hopping properties if not present
        if (!this.hopData) {
            // V40 FIX: Check if food nearby for faster, more excited hopping (RESPONSIVE)
            const foodProximity = 80 * getResponsiveScale();
            const nearbyFood = foodItems.find(f => distance(this.x, this.y, f.x, f.y) < foodProximity);
            const isExcited = nearbyFood !== undefined;

            // V40 FIX: Random hop sequence type (single, double, triple)
            const sequenceType = Math.random();
            let hopSequence = 1; // Default: single hop
            if (sequenceType < 0.3) hopSequence = 2; // 30% - double hop
            else if (sequenceType < 0.45) hopSequence = 3; // 15% - triple hop

            // Set up structured hopping with enforced ground time
            this.hopData = {
                phase: "ground",         // "ground" or "hop"
                phaseTimer: 0,           // Time in current phase
                hopHeight: 0,            // Current height of hop
                nextHopDelay: isExcited ? 600 : 2000, // Faster hopping near food
                baseY: hoppingGroundY,   // Store exact ground level
                hopDistance: 0,          // Distance to move in this hop
                lastX: this.x,           // Track position to detect external changes
                headBobTimer: 0,         // Timer for head bob animation
                lookAroundTimer: 0,      // Timer for looking around behavior
                hopSequence: hopSequence,  // Number of quick hops in sequence
                hopsRemaining: hopSequence, // Track remaining hops
                isExcited: isExcited     // Excited state near food
            };

            // Force initial position
            this.y = hoppingGroundY;
            this.velocity.y = 0;

            const sequenceDesc = hopSequence > 1 ? ` (${hopSequence}-hop sequence)` : '';
            debugLog(`HOPPING STATE INITIALIZED - forcing ground position${sequenceDesc}`);
        }
        
        // Update phase timer
        this.hopData.phaseTimer += deltaTime;
        
        // Check if something else moved the bird - if so, reset
        if (Math.abs(this.x - this.hopData.lastX) > 10 && this.hopData.phase === "ground") {
            debugLog("WARNING: Bird position changed externally during hopping");
            this.hopData.lastX = this.x;
        }
        
        // Clear all velocity and acceleration influences
        this.velocity.y = 0;
        this.acceleration.y = 0;
        
        // CONTROLLED STATE MACHINE
        if (this.hopData.phase === "ground") {
            // Keep bird FIRMLY on ground during ground phase
            this.y = hoppingGroundY;

            // Slow x movement while on ground
            this.velocity.x *= 0.9;

            // Update animation timers for visual variety
            this.hopData.headBobTimer += deltaTime;
            this.hopData.lookAroundTimer += deltaTime;

            // Occasional pecking (more frequent for feeding appearance)
            if (Math.random() < 0.08) {
                this.pecking = !this.pecking;
            }

            // Looking around behavior - occasionally change direction to simulate alertness
            if (this.hopData.lookAroundTimer > 3000 + Math.random() * 2000) {
                // Every 3-5 seconds, look in opposite direction briefly
                if (Math.random() < 0.4) {
                    this.direction *= -1;
                }
                this.hopData.lookAroundTimer = 0;
            }

            // Subtle head bob creates life-like idle animation
            // (Used during draw - stored in hopData for state persistence)
            this.hopData.headBobPhase = Math.sin(this.hopData.headBobTimer / 500) * 0.5;

            // Check if time to hop - guaranteed minimum ground time
            if (this.hopData.phaseTimer > this.hopData.nextHopDelay) {
                // Transition to hop phase
                this.hopData.phase = "hop";
                this.hopData.phaseTimer = 0;

                // V40 FIX: Varied hop heights based on sequence and excitement
                let hopHeightMultiplier = 1.0;
                if (this.hopData.hopSequence > 1) {
                    // Quick hops in sequence are smaller
                    hopHeightMultiplier = 0.7;
                }
                if (this.hopData.isExcited) {
                    // Excited hops are slightly higher
                    hopHeightMultiplier *= 1.2;
                }

                // Random hop height with variation
                const baseHeight = 12 + Math.random() * 15; // 12-27px range
                this.hopData.maxHopHeight = baseHeight * hopHeightMultiplier;
                this.hopData.hopDuration = this.hopData.isExcited ? 350 : 500; // Faster when excited

                // Determine hop direction and distance
                if (Math.random() < 0.2) {
                    this.direction *= -1;
                }

                // Set distance to hop - varies by sequence type
                const baseDistance = this.hopData.isExcited ? 8 : 12; // Smaller hops when excited
                const distanceVariation = Math.random() * 12;
                this.hopData.hopDistance = this.direction * (baseDistance + distanceVariation);

                this.pecking = false; // Stop pecking during hop

                debugLog(`Bird starting hop (${this.hopData.hopsRemaining}/${this.hopData.hopSequence}) height ${Math.round(this.hopData.maxHopHeight)}px`);
            }
        } else if (this.hopData.phase === "hop") {
            // In hop phase - follow a precise arc
            const hopProgress = Math.min(1, this.hopData.phaseTimer / this.hopData.hopDuration);
            
            // Sinusoidal hop height - max at middle of hop
            const normalizedHeight = Math.sin(hopProgress * Math.PI);
            this.hopData.hopHeight = this.hopData.maxHopHeight * normalizedHeight;
            
            // Apply precise position with arc motion
            this.y = hoppingGroundY - this.hopData.hopHeight;

            // Move horizontally during hop - linear movement
            this.x = this.hopData.lastX + (this.hopData.hopDistance * hopProgress);

            // Remember position to prevent external interference
            if (hopProgress >= 1) {
                // Hop complete - check if more hops in sequence
                this.hopData.hopsRemaining--;

                if (this.hopData.hopsRemaining > 0) {
                    // V40 FIX: More hops in sequence - quick transition
                    this.hopData.phase = "ground";
                    this.hopData.phaseTimer = 0;
                    this.hopData.lastX = this.x;
                    this.hopData.nextHopDelay = 300 + Math.random() * 200; // Very short delay (0.3-0.5s) for rapid hops

                    this.y = hoppingGroundY;
                    this.velocity.y = 0;
                    this.pecking = false; // No pecking during rapid sequence

                    debugLog(`Bird finished hop, ${this.hopData.hopsRemaining} more in sequence`);
                } else {
                    // Sequence complete - normal ground time
                    this.hopData.phase = "ground";
                    this.hopData.phaseTimer = 0;
                    this.hopData.lastX = this.x;
                    this.hopData.nextHopDelay = this.hopData.isExcited ? 800 : (1500 + Math.random() * 1500); // Faster when excited

                    // Force ground position to prevent any drift
                    this.y = hoppingGroundY;
                    this.velocity.y = 0;

                    // Start pecking again
                    this.pecking = true;

                    // Reset hop sequence
                    const sequenceType = Math.random();
                    let hopSequence = 1;
                    if (sequenceType < 0.3) hopSequence = 2;
                    else if (sequenceType < 0.45) hopSequence = 3;
                    this.hopData.hopSequence = hopSequence;
                    this.hopData.hopsRemaining = hopSequence;

                    debugLog("Bird finished hop sequence, returning to ground");
                }
            }
        }
        
        // Check for food while hopping
        let foundFood = false;
        const hopFoodRadius = 25;
        
        for (let i = foodItems.length - 1; i >= 0; i--) {
            const food = foodItems[i];
            if (distance(this.x, this.y, food.x, food.y) < hopFoodRadius) {
                foodItems.splice(i, 1);
                this.hunger = Math.max(0, this.hunger - 100);
                foundFood = true;
                debugLog(`Bird found and ate food while hopping.`);
                break;
            }
        }
        
        if (!foundFood) {
            for (let i = worms.length - 1; i >= 0; i--) {
                const worm = worms[i];
                if (distance(this.x, this.y, worm.x, worm.y) < hopFoodRadius) {
                    // FIX: Check if bird has hungry babies - if so, collect worm instead of eating it
                    const hasHungryBaby = !this.isWild && babyBirds.some(baby =>
                        baby.timeSinceLastMeal > 15 &&
                        (baby.associatedNest === this.myNest || !baby.associatedNest)
                    );

                    if (hasHungryBaby && !this.carryingWorm) {
                        // Pick up worm to bring to baby
                        worms.splice(i, 1);
                        this.carryingWorm = true;
                        foundFood = true;
                        debugLog(`Bird picked up worm to feed baby!`);

                        // Immediately go find baby to feed
                        this.findBabyBirds();
                        break;
                    } else {
                        // Eat worm for self
                        worms.splice(i, 1);
                        this.hunger = Math.max(0, this.hunger - 150);
                        foundFood = true;
                        debugLog(`Bird found and ate worm while hopping.`);
                        break;
                    }
                }
            }
        }
        
        // FIX: Check if bird is very hungry - should stop hopping and actively seek food
        if (this.hunger > 500 && this.stateTimer > 5000) { // Very hungry (50%+) and hopped for at least 5 seconds
            // Find nearest food source
            const nearestFood = this.findNearestFood();
            if (nearestFood) {
                // Transition to feeding state to actively pursue food
                this.state = BIRD_STATES.FEEDING;
                this.stateTimer = 0;
                this.targetFood = nearestFood;
                this.hopData = null;
                debugLog(`Hungry bird exiting hopping state to seek food`);
                break;
            }
        }

        // Check for threats while hopping - allow state to be interrupted for safety
        const nearbyRat = rats.find(rat =>
            distance(this.x, this.y, rat.x, rat.y) < 50
        );

        if (nearbyRat) {
            // Flee from rat
            this.flee(nearbyRat.x, nearbyRat.y);
            debugLog(`Bird interrupted hopping to flee from rat`);
            this.hopData = null; // Reset hopping data
            break;
        }
    }

    // V40: Only exit hopping after FULL duration (no early exits for maximum chill)
    if (this.stateTimer > BIRD_STATE_DURATION.HOPPING && (!this.hopData || this.hopData.phase === "ground")) {
        // ONLY exit when on ground AND full time elapsed
        // V40 FIX: Add transitions to other calm ground states
        const transitionRoll = Math.random();

        if (transitionRoll < 0.35) {
            // 35% - Perch (most common after hopping)
            this.findPerch();
            this.hopData = null;
            debugLog("Bird finished hopping, going to perch");
        } else if (transitionRoll < 0.5) {
            // 15% - Rest on ground
            this.state = BIRD_STATES.RESTING;
            this.stateTimer = 0;
            this.hopData = null;
            debugLog("Bird finished hopping, now resting on ground");
        } else if (transitionRoll < 0.65 && foodItems.length > 0) {
            // 15% - Peck for food (if food exists)
            const nearbyFood = foodItems.find(f => distance(this.x, this.y, f.x, f.y) < 100);
            if (nearbyFood) {
                this.state = BIRD_STATES.PECKING;
                this.target = { type: 'food', food: nearbyFood, x: nearbyFood.x, y: nearbyFood.y };
                this.stateTimer = 0;
                this.hopData = null;
                debugLog("Bird finished hopping, now pecking for food");
            } else {
                this.state = BIRD_STATES.RESTING;
                this.stateTimer = 0;
                this.hopData = null;
            }
        } else if (transitionRoll < 0.75 && puddles.length > 0) {
            // 10% - Bathe (if puddles exist)
            const nearbyPuddle = puddles.find(p => distance(this.x, this.y, p.x, p.y) < 120);
            if (nearbyPuddle) {
                this.state = BIRD_STATES.BATHING;
                this.target = { type: 'puddle', puddle: nearbyPuddle, x: nearbyPuddle.x, y: nearbyPuddle.y };
                this.stateTimer = 0;
                this.hopData = null;
                debugLog("Bird finished hopping, going to bathe");
            } else {
                this.state = BIRD_STATES.RESTING;
                this.stateTimer = 0;
                this.hopData = null;
            }
        } else if (transitionRoll < 0.85 && (puddles.length > 0 || ponds.length > 0)) {
            // FIXED: 10% - Drink from nearby water (puddles or ponds)
            const nearbyPuddle = puddles.find(p => distance(this.x, this.y, p.x, p.y) < 120);
            const nearbyPond = ponds.find(p => distance(this.x, this.y, p.x, p.y) < 150);
            if (nearbyPuddle || nearbyPond) {
                this.state = BIRD_STATES.DRINKING;
                this.stateTimer = 0;
                this.hopData = null;
                debugLog("Bird finished hopping, going to drink from water");
            } else {
                this.state = BIRD_STATES.RESTING;
                this.stateTimer = 0;
                this.hopData = null;
            }
        } else {
            // 15% - Fly away
            this.state = BIRD_STATES.FLYING;
            this.stateTimer = 0;
            this.hopData = null;
            this.generatePath(Math.random() * canvas.width, 100 + Math.random() * (canvas.height * 0.3));
            debugLog("Bird finished hopping, flying away");
        }
    }
    break;

                    case BIRD_STATES.MOBBING:
                        // Update mobbing behavior
                        this.updateMobbing(deltaTime);

                        // Follow path if one exists (RESPONSIVE)
                        if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                            const currentTarget = this.path[this.pathIndex];
                            const dist = distance(this.x, this.y, currentTarget.x, currentTarget.y);
                            const mobbingPathThreshold = 20 * getResponsiveScale();

                            if (dist < mobbingPathThreshold) {
                                this.pathIndex++;
                            } else {
                                const dx = currentTarget.x - this.x;
                                const dy = currentTarget.y - this.y;
                                const dir = normalize(dx, dy);
                                this.applyForce({ x: dir.x * 0.04, y: dir.y * 0.04 });
                            }
                        }
                        break;

                    case BIRD_STATES.PECKING:
                        // Update pecking behavior
                        this.updatePecking(deltaTime);

                        // Sentinel doesn't peck
                        if (this.isSentinel) {
                            this.pecking = false;
                            // Scan for threats
                            if (Math.random() < 0.02) {
                                this.chirp(CHIRP_TYPES.SOCIAL, 0.5);
                            }
                        } else {
                            // Actually peck
                            this.pecking = this.peckAnimationPhase > 0;
                        }

                        // V40: Stay on ground with individual depth (like hopping/feeding)
                        const peckingGroundY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
                        this.y = peckingGroundY;
                        this.velocity = { x: 0, y: 0 }; // Complete stillness while pecking

                        // Check if should make food call
                        const nearbyFood = foodItems.find(f =>
                            distance(this.x, this.y, f.x, f.y) < 30
                        );
                        if (nearbyFood && Math.random() < 0.02) {
                            this.makeFoodCall(nearbyFood.x, nearbyFood.y);
                        }

                        // Chance to stop pecking (use configured duration)
                        if (this.stateTimer > BIRD_STATE_DURATION.PECKING || this.hunger < 100) {
                            this.state = BIRD_STATES.FLYING;
                            this.isOnGround = false;
                        }
                        break;

                    case BIRD_STATES.SENTINEL:
                        // Sentinel stays alert, doesn't feed
                        this.pecking = false;
                        this.isOnGround = true;
                        this.y = canvas.height * GROUND_HEIGHT_RATIO;
                        this.velocity = { x: 0, y: 0 };

                        // Scan for threats
                        if (Math.random() < 0.05) {
                            // Check for predators
                            for (const owl of owls) {
                                if (distance(this.x, this.y, owl.x, owl.y) < 300) {
                                    // Alert call
                                    this.chirp(CHIRP_TYPES.ALERT, 1.5);
                                    this.recordDanger(owl.x, owl.y, 'owl');
                                    // Alert flockmates
                                    const flockmates = this.getFlockmates();
                                    flockmates.forEach(b => {
                                        if (b.state === BIRD_STATES.PECKING) {
                                            b.flee(owl.x, owl.y);
                                        }
                                    });
                                    break;
                                }
                            }
                        }

                        // CRITICAL FIX: Exit sentinel duty after timeout or if hungry
                        if (this.stateTimer > BIRD_STATE_DURATION.SENTINEL || this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                                // Must find food
                                this.findFoodSource();
                            } else {
                                // Resume normal ground activity
                                this.state = BIRD_STATES.PECKING;
                                this.stateTimer = 0;
                            }
                        }
                        break;

                    case BIRD_STATES.TERRITORIAL_DISPLAY:
                        // Territorial display behavior
                        if (this.isOnGround) {
                            // Ground display - hopping toward rival
                            if (Math.random() < 0.3) {
                                this.pecking = true;
                            }
                        }

                        // Occasional territorial chirps
                        if (Math.random() < 0.05) {
                            this.chirp(CHIRP_TYPES.TERRITORIAL, 0.8);
                        }

                        // End display after duration
                        if (this.stateTimer > TERRITORIAL_DISPLAY_DURATION) {
                            // Determine winner based on aggression and flock support
                            const flockSupport = this.getFlockmates().filter(b =>
                                distance(b.x, b.y, this.x, this.y) < 150
                            ).length;

                            if (flockSupport > 0 || this.aggression > 0.7) {
                                // Victory!
                                this.chirp(CHIRP_TYPES.VICTORY, 1.2);
                                debugLog(`${this.birdType.name} won territorial dispute!`);
                            } else {
                                // Defeat
                                this.defeatedRecently = true;
                                this.defeatTimer = 0;
                                debugLog(`${this.birdType.name} lost territorial dispute`);
                            }

                            this.state = BIRD_STATES.FLYING;
                        }
                        break;

                    case BIRD_STATES.FLEEING_GROUND:
                        // Ground birds flee slower - hop launch delay
                        if (this.stateTimer < GROUND_ESCAPE_DELAY) {
                            // Delay before takeoff
                            this.y = canvas.height * GROUND_HEIGHT_RATIO;
                            this.velocity.y = 0;
                        } else {
                            // Now take off
                            this.state = BIRD_STATES.FLEEING;
                            this.velocity.y = -this.baseSpeed * 2;
                        }
                        break;

}







                
                // Update position with velocity
                this.velocity.x += this.acceleration.x * (deltaTime / 16);
                this.velocity.y += this.acceleration.y * (deltaTime / 16);
                
                // V26: Limit speed with more aggressive cap for smoother movement
                const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (speed > MAX_SPEED * 0.8) { // 20% lower speed cap
                    this.velocity.x = (this.velocity.x / speed) * MAX_SPEED * 0.8;
                    this.velocity.y = (this.velocity.y / speed) * MAX_SPEED * 0.8;
                }
                
                // Update position
                this.x += this.velocity.x * (deltaTime / 16);
                this.y += this.velocity.y * (deltaTime / 16);

                // CRITICAL FIX: Re-enforce ground position for hopping birds AFTER physics
                // This prevents physics from overriding the explicit ground positioning
                if (this.state === BIRD_STATES.HOPPING && this.hopData) {
                    const birdGroundY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
                    if (this.hopData.phase === "ground") {
                        // Force ground position during ground phase
                        this.y = birdGroundY;
                        this.velocity.y = 0;
                        this.acceleration.y = 0;
                    } else if (this.hopData.phase === "hop") {
                        // During hop, ensure position matches hop arc (calculated in state logic)
                        // Don't let physics drift override the precise hop positioning
                        this.velocity.y = 0;
                        this.acceleration.y = 0;
                    }
                }

                // Ensure birds always face their movement direction when moving significantly
                if (Math.abs(this.velocity.x) > 0.2) { // Only change direction when there's meaningful horizontal movement
                    this.direction = this.velocity.x > 0 ? 1 : -1;
                }

                // Apply position constraints
                validatePosition(this);
                
                return false; // Bird continues to exist
            }

            // V26: Enhanced bird drawing with outlined wings
            draw() {
                const sizeMultiplier = this.birdType.sizeMultiplier;
                
                // V40 FIX: Improved wing state detection for gliding visual
                // Determine if wings should be actively flapping or gliding
                const isActivelyFlapping =
                    this.state === BIRD_STATES.FLYING ||
                    this.state === BIRD_STATES.FLEEING ||
                    (Math.abs(this.velocity.x) > 1.5 || Math.abs(this.velocity.y) > 1.5);

                // Detect gliding: moving through air but not actively flapping
                const isGliding =
                    !isActivelyFlapping &&
                    (Math.abs(this.velocity.x) > 0.3 || Math.abs(this.velocity.y) > 0.3) &&
                    this.y < canvas.height * GROUND_HEIGHT_RATIO - 20; // Above ground

                // Calculate position adjustments for flapping/gliding/hopping motion
    let yOffset;

    if (this.state === BIRD_STATES.HOPPING) {
        // Hopping creates a bouncy motion - more pronounced up and down
        yOffset = Math.abs(Math.sin(this.wingFlap * 1.5)) * 3;
    } else {
        // Regular flight bobbing
        yOffset = Math.sin(this.wingFlap * 0.5) * (isActivelyFlapping ? 1.5 : 0.3);
    }

                // Wing position and spread - three states: flapping, gliding, folded
                let wingSpread, wingY;
                if (isActivelyFlapping) {
                    // Active flapping - animated wings
                    wingSpread = Math.abs(Math.sin(this.wingFlap)) * this.birdType.wingFlapAmplitude * 1.2;
                    wingY = Math.cos(this.wingFlap) * 5;
                } else if (isGliding) {
                    // Gliding - wings extended but static
                    wingSpread = this.birdType.wingFlapAmplitude * 0.9; // 90% extended for glide
                    wingY = 2; // Slightly raised wing position
                } else {
                    // Folded wings - perched or resting
                    wingSpread = this.birdType.glideRatio * 1.2;
                    wingY = 0;
                }
                
                // Draw body
                 // Use rare variant colors if present, otherwise normal colors
    const bodyColor = this.isRareVariant ? this.rareVariant.bodyColor : this.birdType.bodyColor;
    ctx.fillStyle = mushroomMode ? getMushroomColor(bodyColor) : bodyColor;
    ctx.beginPath();
    ctx.ellipse(
        this.x, 
        this.y + yOffset, 
        10 * sizeMultiplier, 
        7 * sizeMultiplier, 
        0, 0, Math.PI * 2
    );
    ctx.fill();
                
                // Draw the belly
              // MODIFY THIS LINE to use mushroom color:
    ctx.fillStyle = mushroomMode ? getMushroomColor(this.birdType.bellyColor) : this.birdType.bellyColor;
    ctx.beginPath();
    ctx.ellipse(
        this.x, 
        this.y + 3 * sizeMultiplier + yOffset, 
        8 * sizeMultiplier, 
        5 * sizeMultiplier, 
        0, 0, Math.PI
    );
    ctx.fill();
                
               // Use same body color for tail
    ctx.fillStyle = mushroomMode ? getMushroomColor(bodyColor) : bodyColor;
    ctx.beginPath();
    if (this.direction > 0) {
        ctx.moveTo(this.x - 10 * sizeMultiplier, this.y + yOffset);
        ctx.lineTo(this.x - 16 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
        ctx.lineTo(this.x - 16 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
    } else {
        ctx.moveTo(this.x + 10 * sizeMultiplier, this.y + yOffset);
        ctx.lineTo(this.x + 16 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
        ctx.lineTo(this.x + 16 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
    }
    ctx.fill();

    // ADD YOUR RAINBOW TAIL CODE RIGHT HERE, after the normal tail is drawn:
    if (mushroomMode) {
        // Draw a more elaborate, colorful tail
        const tailLength = 20 * sizeMultiplier;
        const segments = 5;
        
        for (let i = 0; i < segments; i++) {
            // Each segment gets a different color
            const hue = (this.wingFlap * 20 + i * 30) % 360;
            ctx.fillStyle = `hsl(${hue}, 90%, 60%)`;
            
            // Calculate position based on segment
            const segmentSize = (segments - i) / segments;
            const waveOffset = Math.sin(this.wingFlap + i) * 5;
            
            if (this.direction > 0) {
                ctx.beginPath();
                ctx.ellipse(
                    this.x - (10 + i * 3) * sizeMultiplier,
                    this.y + yOffset + waveOffset,
                    tailLength * 0.3 * segmentSize,
                    tailLength * 0.15 * segmentSize,
                    Math.PI / 3,
                    0, Math.PI * 2
                );
            } else {
                ctx.beginPath();
                ctx.ellipse(
                    this.x + (10 + i * 3) * sizeMultiplier,
                    this.y + yOffset + waveOffset,
                    tailLength * 0.3 * segmentSize,
                    tailLength * 0.15 * segmentSize,
                    -Math.PI / 3,
                    0, Math.PI * 2
                );
            }
            ctx.fill();
        }
    }

    if (mushroomMode) {
    // Rainbow outline for wings in mushroom mode
    ctx.strokeStyle = `hsl(${(colorCycleTimer / 100) % 360}, 100%, 70%)`;
    ctx.lineWidth = 2;
    
    // Pulsing glow effect based on time
    const glowSize = 3 + Math.sin(colorCycleTimer / 500) * 2;
    ctx.shadowColor = `hsl(${(colorCycleTimer / 80 + 30) % 360}, 100%, 60%)`;
    ctx.shadowBlur = glowSize;
} else {
    // Regular style for non-mushroom mode
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 0.02;
    ctx.shadowBlur = 0;
}
                // Draw wings with improved visibility, downward angle, and more volume
                ctx.strokeStyle = '#000000'; // Black outline
                ctx.lineWidth = .02;

                if (this.direction > 0) {
                    // Facing right - left wing outline
                    ctx.beginPath();
                    ctx.moveTo(this.x - 5, this.y + yOffset); // Wider at body
                    // Curve with more downward angle and volume
                    ctx.quadraticCurveTo(
                        this.x - 8 * wingSpread, 
                        this.y + 2 * wingSpread + wingY, // Adjusted for more volume
                        this.x - 10 * wingSpread * sizeMultiplier, 
                        this.y + 3 * sizeMultiplier + wingY  // Top edge of wing
                    );
                    // Fatter wing tip - more separation between points
                    ctx.lineTo(
                        this.x - 9 * wingSpread * sizeMultiplier,
                        this.y + 9 * sizeMultiplier + wingY // Increased separation from 7 to 9
                    );
                    ctx.quadraticCurveTo(
                        this.x - 7 * wingSpread,
                        this.y + 7 * wingSpread + wingY, // Increased from 5 to 7 for fuller shape
                        this.x - 5,
                        this.y + 3 + yOffset // Increased from 2 to 3 for fuller connection
                    );
                    ctx.closePath();
                    ctx.stroke(); // Draw outline
                    
                    // Now fill the wing
                    ctx.fillStyle = this.birdType.wingColor;
                    ctx.fill();
                } else {
                    // Similar changes for left-facing birds
                    ctx.beginPath();
                    ctx.moveTo(this.x + 5, this.y + yOffset);
                    ctx.quadraticCurveTo(
                        this.x + 8 * wingSpread,
                        this.y + 2 * wingSpread + wingY, // Adjusted for more volume
                        this.x + 10 * wingSpread * sizeMultiplier,
                        this.y + 3 * sizeMultiplier + wingY // Top edge of wing
                    );
                    ctx.lineTo(
                        this.x + 9 * wingSpread * sizeMultiplier,
                        this.y + 9 * sizeMultiplier + wingY // Increased separation for fatter tip
                    );
                    ctx.quadraticCurveTo(
                        this.x + 7 * wingSpread,
                        this.y + 7 * wingSpread + wingY, // Increased for fuller shape
                        this.x + 5,
                        this.y + 3 + yOffset // Increased for fuller connection
                    );
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fillStyle = this.birdType.wingColor;
                    ctx.fill();
                }
                
              // Draw the head
ctx.fillStyle = mushroomMode ? getMushroomColor(this.birdType.bodyColor) : this.birdType.bodyColor;
ctx.beginPath();
ctx.arc(
    this.x + (this.direction * 8 * sizeMultiplier), 
    this.y - 2 * sizeMultiplier + yOffset, 
    6 * sizeMultiplier, 
    0, Math.PI * 2
);
ctx.fill();
                
                // Draw beak
                ctx.fillStyle = this.pecking ? '#FF8800' : '#FFAA00';
                ctx.beginPath();
                if (this.direction > 0) {
                    ctx.moveTo(this.x + 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x + 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x + 12 * sizeMultiplier, this.y + yOffset);
                } else {
                    ctx.moveTo(this.x - 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x - 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x - 12 * sizeMultiplier, this.y + yOffset);
                }
                ctx.fill();
                
                // Eyes with pupil and highlight for cuter appearance
                // ENHANCED: Draw closed eyes when sleeping
                if (this.state === BIRD_STATES.SLEEPING) {
                    // Draw closed eyes (horizontal lines)
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1.5 * sizeMultiplier;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    // Draw a gentle curved line for closed eye
                    const eyeX = this.x + (this.direction * 8 * sizeMultiplier);
                    const eyeY = this.y - 3 * sizeMultiplier + yOffset;
                    ctx.moveTo(eyeX - 2 * sizeMultiplier, eyeY);
                    ctx.quadraticCurveTo(
                        eyeX, eyeY + 0.5 * sizeMultiplier,
                        eyeX + 2 * sizeMultiplier, eyeY
                    );
                    ctx.stroke();
                } else {
                    // Draw open eyes
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + (this.direction * 8 * sizeMultiplier),
                        this.y - 3 * sizeMultiplier + yOffset,
                        2 * sizeMultiplier,
                        0, Math.PI * 2
                    );
                    ctx.fill();

                    // Add white highlight to eyes for cute effect
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + (this.direction * 8.5 * sizeMultiplier),
                        this.y - 3.5 * sizeMultiplier + yOffset,
                        0.8 * sizeMultiplier,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Draw carried twig if holding materials
                if (this.materialsHeld > 0) {
                    ctx.save();
                    ctx.translate(
                        this.x + (this.direction * 15 * sizeMultiplier), 
                        this.y - 2 * sizeMultiplier + yOffset
                    );
                    ctx.rotate(this.direction * Math.PI * 0.25);
                    
                    if (this.hasSpecialTwig) {
                        ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                        ctx.shadowBlur = 3;
                        ctx.fillStyle = '#D2B48C'; // Lighter wood color
                    } else {
                        ctx.fillStyle = '#8B4513';
                    }
                    
                    ctx.fillRect(-2, -2, 15, 2);
                    ctx.restore();
                }

                // Draw "ZzZz" above sleeping birds
                if (this.state === BIRD_STATES.SLEEPING) {
                    const time = Date.now() / 1000;
                    ctx.save();
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Multiple "z" letters that float upward
                    for (let i = 0; i < 3; i++) {
                        const offset = (time * 0.5 + i * 0.7) % 2; // Cycles every 2 seconds
                        const floatY = this.y - 20 - (offset * 15); // Float up 15px
                        const opacity = 1 - (offset / 2); // Fade out as they float up
                        const size = 12 + i * 3; // Larger z's as they go up

                        ctx.globalAlpha = opacity;
                        ctx.font = `bold ${size}px Arial`;

                        // White outline
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.strokeText('Z', this.x + (i - 1) * 8, floatY);

                        // Dark blue fill
                        ctx.fillStyle = '#4169E1'; // Royal blue
                        ctx.fillText('Z', this.x + (i - 1) * 8, floatY);
                    }

                    ctx.restore();
                }

                // Debug info
                if (debugVisuals) {
                 // Vision radius
ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';  // Brighter yellow with higher opacity
ctx.lineWidth = 2;  // Make the line thicker
ctx.beginPath();
ctx.arc(this.x, this.y, BIRD_VISION_RADIUS, 0, Math.PI * 2);
ctx.stroke();
                    
                    // Hunger bar
                    const hungerRatio = this.hunger / BIRD_MAX_HUNGER;
                    ctx.fillStyle = hungerRatio > 0.7 ? 'red' : (hungerRatio > 0.4 ? 'yellow' : 'green');
                    ctx.fillRect(this.x - 10, this.y - 15, 20 * hungerRatio, 3);
                    
                    // State text
                    ctx.fillStyle = 'white';
                    ctx.font = '8px Arial';
                    ctx.fillText(this.state, this.x - 10, this.y - 20);
                }
            }
        }

        // V26: Modified Rat class with reduced spawn rate and king formation chance
        class Rat {
            constructor(x, y, isRatKing = false) {
                this.id = Math.random().toString(36).substr(2, 9); // Unique ID for tracking
                this.x = x;
                this.y = y;
                this.direction = x < canvas.width / 2 ? 1 : -1;
                this.velocity = { x: 0, y: 0 };
                this.acceleration = { x: 0, y: 0 };
                this.speed = 0.7;
                this.state = 'wandering';
                this.stateTimer = 0;
                this.targetX = null;
                this.isRatKing = isRatKing;
                this.nestTarget = null;
                this.wanderTimer = 0;
                this.bobTimer = 0; // For animation

                // Enhanced ground exploration: rats can move in grass depth (0-30px below ground)
                this.groundDepth = Math.random() * 30;
                this.targetDepth = this.groundDepth; // Target depth for exploration
                this.exploreTimer = 0; // Timer for changing exploration depth

                // For rat king
                if (isRatKing) {
                    this.kingSize = 1.5;
                    this.ratCount = 3 + Math.floor(Math.random() * 3); // 3-5 rats in the king
                    this.rattiness = Math.random() * 0.5 + 0.7; // Higher value = more chaotic
                }
            }
            
            applyForce(force) {
                this.acceleration.x += force.x;
                this.acceleration.y += force.y;
            }
            
            nearestNest() {
                let closest = null;
                let closestDist = Infinity;
                
                for (const nest of nests) {
                    const dist = distance(this.x, this.y, nest.x, nest.y);
                    if (dist < closestDist && nest.isComplete) {
                        closestDist = dist;
                        closest = nest;
                    }
                }
                
                return closestDist < 100 ? closest : null;
            }
            
            update(deltaTime) {
                this.stateTimer += deltaTime;
                this.bobTimer += deltaTime * 0.01;
                
                // Reset acceleration each frame
                this.acceleration = { x: 0, y: 0 };
                
                // FIX: Only check for birds and enter fleeing state if not already fleeing
                if (this.state !== 'fleeing') {
                    const nearbyBird = birds.find(bird =>
                        distance(this.x, this.y, bird.x, bird.y) < 50
                    );

                    if (nearbyBird && !this.isRatKing) {
                        // Run away from bird
                        this.state = 'fleeing';
                        this.stateTimer = 0;

                        const fleeDirection = this.x < nearbyBird.x ? -1 : 1;
                        this.direction = fleeDirection;
                        debugLog(`Rat fleeing from bird at (${nearbyBird.x}, ${nearbyBird.y})`);
                    }
                }

                switch (this.state) {
                    case 'wandering': {
                        this.wanderTimer += deltaTime;
                        this.exploreTimer += deltaTime;

                        // Enhanced ground exploration: change target depth every 3-5 seconds
                        if (this.exploreTimer > 3000 + Math.random() * 2000) {
                            this.targetDepth = Math.random() * 30; // New depth to explore
                            this.exploreTimer = 0;
                        }

                        // Smoothly move toward target depth
                        const groundBase = canvas.height * GROUND_HEIGHT_RATIO;
                        const targetY = groundBase + this.targetDepth;
                        const depthDiff = targetY - this.y;
                        if (Math.abs(depthDiff) > 2) {
                            this.applyForce({
                                x: 0,
                                y: depthDiff * 0.001 // Gentle vertical movement
                            });
                        }

                        // Check for food caches to dig up
                        if (Math.random() < 0.005) {
                            // Find any nearby cache (not just own caches)
                            for (const cache of foodCaches) {
                                if (cache.retrieved) continue;
                                const dist = distance(this.x, this.y, cache.x, cache.y);
                                if (dist < 30) {
                                    // Rat digs up the cache!
                                    cache.retrieved = true;
                                    debugLog(`Rat dug up food cache at (${cache.x}, ${cache.y})!`);

                                    // Add the food back to the world
                                    foodItems.push({
                                        x: cache.x,
                                        y: cache.y,
                                        type: cache.type === 'nut' ? 'seed' : cache.type,
                                        timer: 0
                                    });
                                    break;
                                }
                            }
                        }

                        // V26: Reduced nest raiding chance for better ecosystem balance
                        if (!this.nestTarget && Math.random() < 0.007) { // Reduced from 0.01
                            const nearestNest = this.nearestNest();
                            if (nearestNest && !nearestNest.ratOccupied) {
                                this.nestTarget = nearestNest;
                                this.state = 'raiding';
                                this.stateTimer = 0;
                                debugLog(`Rat targeting nest at (${nearestNest.x}, ${nearestNest.y})`);
                            }
                        }

                        // Move in current direction (horizontal)
                        this.applyForce({
                            x: this.direction * 0.01,
                            y: 0
                        });

                        // Random direction changes
                        if (Math.random() < 0.01) {
                            this.direction *= -1;
                        }

                        // Random stops
                        if (Math.random() < 0.005) {
                            this.state = 'stopped';
                            this.stateTimer = 0;
                        }
                        break;
                    }

                    case 'fleeing': {
                        // FIX: Add missing fleeing state case
                        // Move away from threat quickly
                        this.applyForce({
                            x: this.direction * 0.04,
                            y: 0
                        });

                        // Clamp to ground level
                        const groundBase = canvas.height * GROUND_HEIGHT_RATIO;
                        this.y = Math.min(this.y, groundBase + 30);

                        // Return to wandering after fleeing for 3 seconds
                        if (this.stateTimer > 3000) {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                            debugLog(`Rat stopped fleeing and returned to wandering`);
                        }
                        break;
                    }

                    case 'stopped':
                        // Leave after a longer while or if off-screen
                        if ((this.wanderTimer > 40000) || // Increased from 20000
                            (this.direction < 0 && this.x < -50) || 
                            (this.direction > 0 && this.x > canvas.width + 50)) {
                            return true; // Rat should be removed
                        }
                        break;
                        
                    case 'stopped':
                        // Stand still with slight movement
                        this.velocity.x *= 0.9;
                        
                        if (Math.random() < 0.05) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.01, 
                                y: 0 
                            });
                        }
                        
                        // Resume wandering after a pause
                        if (this.stateTimer > 3000 + Math.random() * 2000) {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                        }
                        break;
                        
                    case 'fleeing':
                        // Run away fast
                        this.applyForce({ 
                            x: this.direction * 0.02, 
                            y: 0 
                        });
                        
                        // Return to wandering after fleeing
                        if (this.stateTimer > 3000) {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                        }
                        break;
                        
                    case 'raiding':
                        if (!this.nestTarget || nests.indexOf(this.nestTarget) === -1) {
                            this.nestTarget = null;
                            this.state = 'wandering';
                            this.stateTimer = 0;
                            break;
                        }
                        
                        const nestDist = distance(this.x, this.y, this.nestTarget.x, this.nestTarget.y);
                        
                        if (nestDist < 10) {
                            // At the nest, attempt to damage it
                            if (Math.random() < 0.08) { // Reduced from 0.1 - less aggressive damage
                                const destroyed = this.nestTarget.damage(8); // Reduced from 10
                                debugLog(`Rat damaged nest: ${destroyed ? 'Significant damage!' : 'Minor damage'}`);
                                
                                // Occupy nest if it's really damaged
                                if (this.nestTarget.health < 30 && Math.random() < 0.25) { // Reduced from 0.3
                                    this.nestTarget.ratOccupied = true;
                                    debugLog(`Rat occupied damaged nest!`);
                                }
                            }
                            
                            // Stand still with slight movement
                            this.velocity.x *= 0.8;
                            
                            // Return to wandering after a while
                            if (this.stateTimer > 10000 || this.nestTarget.ratOccupied) {
                                this.state = 'wandering';
                                this.stateTimer = 0;
                                this.nestTarget = null;
                            }
                        } else {
                            // Move toward nest
                            const dx = this.nestTarget.x - this.x;
                            this.direction = dx > 0 ? 1 : -1;
                            
                            this.applyForce({ 
                                x: this.direction * 0.015, 
                                y: 0 
                            });
                            
                            // Give up after trying too long
                            if (this.stateTimer > 15000) {
                                this.state = 'wandering';
                                this.stateTimer = 0;
                                this.nestTarget = null;
                            }
                        }
                        break;
                }
                
                // Update position with velocity
                this.velocity.x += this.acceleration.x * (deltaTime / 16);
                this.velocity.y += this.acceleration.y * (deltaTime / 16);
                
                // Limit speed
                const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (speed > this.speed) {
                    this.velocity.x = (this.velocity.x / speed) * this.speed;
                    this.velocity.y = (this.velocity.y / speed) * this.speed;
                }
                
                // Update position
                this.x += this.velocity.x * (deltaTime / 16);
                this.y += this.velocity.y * (deltaTime / 16);

                // CRITICAL FIX: Clamp rat to ground level or below (prevent floating)
                const minGroundY = canvas.height * GROUND_HEIGHT_RATIO;
                if (this.y < minGroundY) {
                    this.y = minGroundY;
                    this.velocity.y = 0; // Stop upward movement
                }

                return false;
            }
            
            draw() {
                if (this.isRatKing) {
                    this.drawRatKing();
                } else {
                    this.drawRegularRat();
                }
                
                if (debugVisuals) {
                    // Vision circle
                    ctx.strokeStyle = 'rgba(200, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, RAT_VISION_RADIUS, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // State text
                    ctx.fillStyle = 'white';
                    ctx.font = '8px Arial';
                    ctx.fillText(this.state, this.x - 10, this.y - 15);
                }
            }
            
            drawRegularRat() {
                const bobAmount = Math.sin(this.bobTimer) * 2;
                
                // Body
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(
                    this.x, 
                    this.y + bobAmount, 
                    10, 
                    5, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Tail
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const tailWag = Math.sin(this.bobTimer * 2) * 3;
                
                if (this.direction > 0) {
                    ctx.moveTo(this.x - 8, this.y + bobAmount);
                    ctx.bezierCurveTo(
                        this.x - 20, this.y + bobAmount, 
                        this.x - 30, this.y + tailWag + bobAmount, 
                        this.x - 35, this.y + tailWag + bobAmount
                    );
                } else {
                    ctx.moveTo(this.x + 8, this.y + bobAmount);
                    ctx.bezierCurveTo(
                        this.x + 20, this.y + bobAmount, 
                        this.x + 30, this.y + tailWag + bobAmount, 
                        this.x + 35, this.y + tailWag + bobAmount
                    );
                }
                ctx.stroke();
                
                // Head
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(
                    this.x + (this.direction * 8), 
                    this.y + bobAmount, 
                    6, 
                    4, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(
                    this.x + (this.direction * 10), 
                    this.y - 1 + bobAmount, 
                    1, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            drawRatKing() {
                const bobAmount = Math.sin(this.bobTimer) * 2;
                
                // Draw the outline first for better visibility
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                
                // Multiple intertwined rats for the king
                for (let i = 0; i < this.ratCount; i++) {
                    const angle = (i / this.ratCount) * Math.PI * 2;
                    const rattiness = this.rattiness;
                    
                    const offsetX = Math.cos(angle) * 5 * rattiness;
                    const offsetY = Math.sin(angle) * 5 * rattiness;
                    
                    // Body outline
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x + offsetX, 
                        this.y + offsetY + bobAmount, 
                        10 * this.kingSize, 
                        5 * this.kingSize, 
                        angle, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // Body fill
                    ctx.fillStyle = '#4B0082'; // Darker color for rat king
                    ctx.fill();
                    
                    // Tail - intertwined in center
                    ctx.beginPath();
                    ctx.moveTo(this.x + offsetX, this.y + offsetY + bobAmount);
                    ctx.lineTo(this.x, this.y + bobAmount);
                    ctx.stroke();
                    
                    // Head outline
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x + offsetX * 1.5 + (this.direction * 5), 
                        this.y + offsetY * 1.5 + bobAmount, 
                        6 * this.kingSize, 
                        4 * this.kingSize, 
                        angle, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // Head fill
                    ctx.fillStyle = '#4B0082';
                    ctx.fill();
                    
                    // Glowing red eyes
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + offsetX * 1.5 + (this.direction * 7), 
                        this.y + offsetY * 1.5 - 1 + bobAmount, 
                        1.5 * this.kingSize, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Center knot of tails
                ctx.fillStyle = '#4B0082';
                ctx.beginPath();
                ctx.arc(
                    this.x, 
                    this.y + bobAmount, 
                    5 * this.kingSize, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Add a crown on top for the rat king
                ctx.fillStyle = '#FFD700'; // Gold crown
                ctx.beginPath();
                ctx.moveTo(this.x - 6 * this.kingSize, this.y - 6 * this.kingSize + bobAmount);
                ctx.lineTo(this.x - 4 * this.kingSize, this.y - 10 * this.kingSize + bobAmount);
                ctx.lineTo(this.x - 2 * this.kingSize, this.y - 7 * this.kingSize + bobAmount);
                ctx.lineTo(this.x, this.y - 10 * this.kingSize + bobAmount);
                ctx.lineTo(this.x + 2 * this.kingSize, this.y - 7 * this.kingSize + bobAmount);
                ctx.lineTo(this.x + 4 * this.kingSize, this.y - 10 * this.kingSize + bobAmount);
                ctx.lineTo(this.x + 6 * this.kingSize, this.y - 6 * this.kingSize + bobAmount);
                ctx.closePath();
                ctx.fill();
                
                // Crown outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }


// NEW: Bush class for ground-level vegetation
class Bush {
    constructor(x, depth) {
        this.x = x;
        this.depth = depth !== undefined ? depth : Math.random(); // For layering (0 = foreground, 1 = background)
        this.scale = 1 - this.depth * 0.3; // Scale based on depth (0.7x to 1.0x)
        this.width = (40 + Math.random() * 30) * this.scale; // Varied bush widths, scaled by depth
        this.height = (30 + Math.random() * 20) * this.scale; // Varied heights, scaled by depth

        // Depth offset: foreground bushes go deeper into grass area for depth perception
        const depthOffset = this.depth < 0.3 ? (15 + Math.random() * 30) : (Math.random() * 15);
        this.depthOffset = depthOffset;
        this.y = canvas.height * GROUND_HEIGHT_RATIO + depthOffset;

        // Berry/seed production
        this.hasFruit = Math.random() < 0.6; // 60% of bushes have fruit
        this.fruitType = Math.random() < 0.5 ? 'berry' : 'seed';
        this.fruitCount = 0;
        this.maxFruit = 3 + Math.floor(Math.random() * 3); // 3-5 fruit max
        this.lastFruitTime = Date.now();
        this.fruitGrowthRate = 60000 + Math.random() * 60000; // 1-2 minutes per fruit

        // Visual variety
        this.color = this.generateBushColor();
        this.leafDensity = Math.random(); // For visual variation
    }

    generateBushColor() {
        // Varied green shades for bushes
        const greenVariants = [
            '#2d5016', // Dark green
            '#3d6b1f', // Medium green
            '#4a7c2f', // Light green
            '#2a4a1a', // Forest green
        ];
        return greenVariants[Math.floor(Math.random() * greenVariants.length)];
    }

    update() {
        // Grow fruit over time
        if (this.hasFruit && this.fruitCount < this.maxFruit) {
            const timeSinceLastFruit = Date.now() - this.lastFruitTime;
            if (timeSinceLastFruit > this.fruitGrowthRate) {
                this.fruitCount++;
                this.lastFruitTime = Date.now();
                debugLog(`Bush at (${this.x}) grew a ${this.fruitType}! (${this.fruitCount}/${this.maxFruit})`);
            }
        }
    }

    draw() {
        ctx.save();

        // Width and height already scaled in constructor, Y already includes depth offset
        const drawY = this.y;

        // Draw bush as rounded shape with multiple circles for leafy look
        ctx.fillStyle = this.color;

        // Main bush body (3-5 overlapping circles for natural look)
        const circleCount = 3 + Math.floor(this.leafDensity * 2);
        for (let i = 0; i < circleCount; i++) {
            const offsetX = (i - circleCount / 2) * (this.width / circleCount);
            const offsetY = Math.sin(i) * (this.height * 0.2);
            ctx.beginPath();
            ctx.arc(
                this.x + offsetX,
                drawY + offsetY,
                this.width / (circleCount * 0.8),
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        // Draw berries/seeds if present
        if (this.fruitCount > 0) {
            const fruitColor = this.fruitType === 'berry' ? '#8B0000' : '#D2691E';
            ctx.fillStyle = fruitColor;

            for (let i = 0; i < this.fruitCount; i++) {
                const angle = (i / this.fruitCount) * Math.PI * 2;
                const fruitX = this.x + Math.cos(angle) * (this.width * 0.3);
                const fruitY = drawY + Math.sin(angle) * (this.height * 0.3);

                ctx.beginPath();
                ctx.arc(fruitX, fruitY, 3 * this.scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore();
    }

    // Pick fruit from bush (returns food item or null)
    pickFruit() {
        if (this.fruitCount > 0) {
            this.fruitCount--;
            debugLog(`Fruit picked from bush at (${this.x}). Remaining: ${this.fruitCount}`);

            // Create food item
            return {
                x: this.x,
                y: this.y - this.height / 2,
                type: this.fruitType,
                lifetime: 0
            };
        }
        return null;
    }

    // Check if position is suitable for perching (on top of bush)
    getPerchPosition() {
        return {
            x: this.x + (Math.random() - 0.5) * this.width * 0.6,
            y: this.y - this.height * this.scale * 0.8 // On top of bush
        };
    }
}

// NEW: TallGrass class for ground-level vegetation that attracts fireflies
class TallGrass {
    constructor(x, width, depth) {
        this.x = x;
        this.depth = depth !== undefined ? depth : Math.random(); // For layering (0 = foreground, 1 = background)
        this.scale = 1 - this.depth * 0.3; // Scale based on depth (0.7x to 1.0x)
        this.width = (width || (30 + Math.random() * 50)) * this.scale; // 30-80px wide patches, scaled by depth
        this.bladeCount = Math.floor((10 + Math.random() * 15) * this.scale); // 10-25 blades, scaled by depth
        this.height = (35 + Math.random() * 25) * this.scale; // 35-60px tall, scaled by depth
        this.color = this.generateGrassColor();
        this.swayOffset = Math.random() * Math.PI * 2; // For animation

        // Depth offset: foreground grass goes deeper into grass area for depth perception
        const depthOffset = this.depth < 0.3 ? (10 + Math.random() * 20) : (Math.random() * 10);
        this.depthOffset = depthOffset;
        this.y = canvas.height * GROUND_HEIGHT_RATIO + depthOffset;

        // Pre-calculate blade heights to prevent jittering
        this.bladeHeights = [];
        for (let i = 0; i < this.bladeCount; i++) {
            this.bladeHeights[i] = this.height * (0.7 + Math.random() * 0.3);
        }
    }

    generateGrassColor() {
        // Varied green shades, slightly darker than regular grass
        const grassVariants = [
            '#3a5f0b',
            '#2d4a0b',
            '#4a6f1f',
            '#3d6b20'
        ];
        return grassVariants[Math.floor(Math.random() * grassVariants.length)];
    }

    update(deltaTime, timeOfDay) {
        // Gentle swaying animation (slowed down significantly)
        this.swayOffset += deltaTime * 0.0003; // Reduced from 0.001 for slower, more natural sway
    }

    draw() {
        ctx.save();

        // Draw individual grass blades
        for (let i = 0; i < this.bladeCount; i++) {
            const bladeX = this.x - this.width / 2 + (i / this.bladeCount) * this.width;
            const sway = Math.sin(this.swayOffset + i * 0.5) * 3; // Gentle sway
            const bladeHeight = this.bladeHeights[i]; // Use pre-calculated height to prevent jitter

            // Draw grass blade as a curved line
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(bladeX, this.y);

            // Curved blade using quadratic curve
            const midX = bladeX + sway;
            const midY = this.y - bladeHeight / 2;
            const topX = bladeX + sway * 1.5;
            const topY = this.y - bladeHeight;

            ctx.quadraticCurveTo(midX, midY, topX, topY);
            ctx.stroke();
        }

        ctx.restore();
    }

    // Check if a position is within or near this grass patch
    isNearGrass(x, y) {
        const distX = Math.abs(x - this.x);
        const distY = Math.abs(y - this.y);
        return distX < this.width && distY < this.height + 20;
    }
}

// NEW: Stone class for ground decoration
class Stone {
    constructor(x, y, depth) {
        this.x = x;
        this.depth = depth !== undefined ? depth : Math.random(); // For layering (0 = foreground, 1 = background)
        this.scale = 1 - this.depth * 0.3; // Scale based on depth (0.7x to 1.0x)
        this.size = (8 + Math.random() * 15) * this.scale; // 8-23px, scaled by depth
        this.color = this.generateStoneColor();
        this.shape = Math.random(); // For visual variety
        this.rotation = Math.random() * Math.PI * 2;
        // Pre-calculate ellipse ratio to prevent vibration
        this.ellipseRatio = 0.7 + Math.random() * 0.4;

        // Depth offset: foreground stones go deeper into grass area for depth perception
        const depthOffset = this.depth < 0.3 ? (5 + Math.random() * 15) : (Math.random() * 10);
        this.depthOffset = depthOffset;
        this.y = y || (canvas.height * GROUND_HEIGHT_RATIO + depthOffset);
    }

    generateStoneColor() {
        // Varied stone/rock colors (grays, browns)
        const stoneColors = [
            '#696969', // Dim gray
            '#808080', // Gray
            '#778899', // Light slate gray
            '#5c5c5c', // Dark gray
            '#6b5b4f', // Brown-gray
            '#7a7268', // Warm gray
        ];
        return stoneColors[Math.floor(Math.random() * stoneColors.length)];
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Draw stone as irregular oval/circle
        ctx.fillStyle = this.color;
        ctx.beginPath();

        if (this.shape < 0.5) {
            // Round stone
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        } else {
            // Irregular stone (ellipse) - use pre-calculated ratio to prevent vibration
            ctx.ellipse(0, 0, this.size, this.size * this.ellipseRatio, 0, 0, Math.PI * 2);
        }

        ctx.fill();

        // Add slight highlight for depth
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(-this.size * 0.2, -this.size * 0.2, this.size * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Add shadow for depth
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        ctx.arc(this.size * 0.3, this.size * 0.3, this.size * 0.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

// V26: Improved Squirrel class with less frequent spawn rate
class Squirrel {
    constructor(x, y) {
        this.id = Math.random().toString(36).substr(2, 9); // Unique ID for tracking
        this.x = x;
        this.y = y;
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.speed = 1.2;
        this.state = 'wandering';
        this.stateTimer = 0;
        this.climbingTree = null;
        this.targetY = null;
        this.tailWobble = 0;
        this.nutCollected = false;
        this.lastJumpTime = 0; // Track last jump to prevent loop
        this.lastJumpTree = null; // Track tree jumped from to avoid immediate return
        this.fleeing = false;
        this.groundY = canvas.height * GROUND_HEIGHT_RATIO;
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    nearestTree() {
        let closest = null;
        let closestDist = Infinity;
        
        for (const tree of trees) {
            const dist = distance(this.x, this.y, tree.x, this.y);
            if (dist < closestDist && dist < 100) { // Only consider trees within 100px
                closestDist = dist;
                closest = tree;
            }
        }
        
        return closest;
    }
    
    update(deltaTime) {
        this.stateTimer += deltaTime;
        this.tailWobble += 0.1 * deltaTime / 16;
        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        // Squirrels are scared of nearby birds
        const nearbyBird = birds.find(bird => 
            distance(this.x, this.y, bird.x, bird.y) < 50 &&
            bird.state !== BIRD_STATES.FLEEING
        );
        
        if (nearbyBird && this.state !== 'climbing' && !this.fleeing) {
            // Run away from bird
            this.state = 'fleeing';
            this.stateTimer = 0;
            this.fleeing = true;
            
            const fleeDirection = this.x < nearbyBird.x ? -1 : 1;
            this.direction = fleeDirection;
            
            debugLog(`Squirrel fleeing from bird at (${nearbyBird.x}, ${nearbyBird.y})`);
        }
        
        switch (this.state) {
            case 'wandering':
                // Check for cached food to retrieve
                if (!this.nutCollected && Math.random() < 0.001) {
                    const cache = findNearestCache(this.x, this.y, this.id);
                    if (cache && distance(this.x, this.y, cache.x, cache.y) < 200) {
                        // Move toward cache
                        const dx = cache.x - this.x;
                        if (Math.abs(dx) < 15) {
                            // Close enough to retrieve
                            this.nutCollected = true;
                            cache.retrieved = true;
                            debugLog(`Squirrel retrieved cached nut at (${cache.x}, ${cache.y})`);
                        } else {
                            // Move toward cache
                            this.direction = dx > 0 ? 1 : -1;
                        }
                    }
                }

                // Check for trees to climb - reduced chance
                if (!this.fleeing && Math.random() < 0.003) { // Reduced from 0.005
                    const nearestTree = this.nearestTree();
                    if (nearestTree && trees.indexOf(nearestTree) !== -1) { // Verify tree exists
                        this.climbingTree = nearestTree;
                        this.state = 'climbing';
                        this.stateTimer = 0;
                        debugLog(`Squirrel climbing tree at (${nearestTree.x})`);
                    }
                }

                // Move along ground
                this.applyForce({
                    x: this.direction * 0.02,
                    y: 0
                });
                
                // Random direction changes
                if (Math.random() < 0.01) {
                    this.direction *= -1;
                }
                
                // Random stops
                if (Math.random() < 0.02) {
                    this.state = 'foraging';
                    this.stateTimer = 0;
                }

                // Allow exploring slightly below ground to reach worms/branches
                this.y = Math.min(this.y, this.groundY + 15); // Can go 15px below ground line
                
                // Leave after a while
                if (this.stateTimer > 60000 || 
                    (this.direction < 0 && this.x < -30) || 
                    (this.direction > 0 && this.x > canvas.width + 30)) {
                    
                    if (this.x < -30 || this.x > canvas.width + 30) {
                        this.state = 'leaving';
                    } else {
                        this.state = 'leaving'; // go offscreen intentionally
                        this.direction = Math.random() < 0.5 ? -1 : 1;
                    }
                    debugLog(`Squirrel leaving scene in direction: ${this.direction}`);
                }
                break;
                
            case 'foraging':
                // Allow squirrels to explore below ground while foraging for worms/branches
                this.y = Math.min(this.y, this.groundY + 15); // Can go 15px below ground line
                
                // Bobbing and foraging motions
                this.velocity.x *= 0.9;
                
                if (Math.random() < 0.05) {
                    this.applyForce({ 
                        x: (Math.random() - 0.5) * 0.02, 
                        y: 0 
                    });
                    
                    // Flip direction occasionally while foraging
                    if (Math.random() < 0.1) {
                        this.direction *= -1;
                    }
                }
                
                // Find nuts occasionally
                if (!this.nutCollected && Math.random() < 0.001) {
                    this.nutCollected = true;
                    debugLog(`Squirrel found a nut!`);
                }

                // Chance to cache the nut if squirrel has one
                if (this.nutCollected && Math.random() < 0.002) {
                    createFoodCache(this.x, this.y, 'nut', this.id);
                    this.nutCollected = false; // Nut is now cached
                    debugLog(`Squirrel cached nut at (${this.x}, ${this.y})`);
                }

                // Resume wandering after foraging
                if (this.stateTimer > 5000) {
                    if (this.nutCollected && Math.random() < 0.7) {
                        // More likely to climb trees with nuts
                        const nearestTree = this.nearestTree();
                        if (nearestTree && trees.indexOf(nearestTree) !== -1) { // Verify tree exists
                            this.climbingTree = nearestTree;
                            this.state = 'climbing';
                            this.stateTimer = 0;
                            debugLog(`Squirrel climbing tree with nut`);
                        } else {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                        }
                    } else {
                        this.state = 'wandering';
                        this.stateTimer = 0;
                    }
                }
                break;
                
            case 'climbing':
                // Verify tree still exists
                if (!this.climbingTree || trees.indexOf(this.climbingTree) === -1) {
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.climbingTree = null;
                    debugLog(`Squirrel's tree disappeared!`);
                    break;
                }
                
                // IMPORTANT FIX: Reset acceleration and limit velocity to prevent drift
                this.acceleration = { x: 0, y: 0 };
                this.velocity.x *= 0.8; // Stronger damping
                
                // Move toward tree trunk
                const distToTrunk = Math.abs(this.x - this.climbingTree.x);
                
                // Reduced threshold for closer tree attachment
                if (distToTrunk < 3) { // Changed from 5 to 3
                    // IMPORTANT: Force the X position to be exactly at the trunk
                    this.x = this.climbingTree.x;
                    this.velocity.x = 0; // Stop horizontal movement
                    
                    // At trunk, climb up
                    if (!this.targetY) {
                        // Target height is top of trunk
                        this.targetY = this.climbingTree.y - this.climbingTree.trunkHeight * 0.8 * this.climbingTree.scale;
                    }
                    
                    const heightDiff = this.y - this.targetY;

                    if (Math.abs(heightDiff) < 5) {
                        // Reached target height - check if at ground or in tree
                        if (this.targetY >= this.groundY - 20) {
                            // Reached ground level - return to wandering
                            this.state = 'wandering';
                            this.stateTimer = 0;
                            this.climbingTree = null;
                            this.targetY = null;
                            this.y = this.groundY; // Place on ground
                            this.velocity = { x: 0, y: 0 };
                            debugLog(`Squirrel reached ground and resumed wandering`);
                        } else {
                            // Reached tree top - enter inTree state
                            this.state = 'inTree';
                            this.stateTimer = 0;
                            this.x = this.climbingTree.x; // Center on trunk
                            this.velocity = { x: 0, y: 0 }; // Stop all movement
                            debugLog(`Squirrel reached top of tree at (${this.climbingTree.x})`);
                        }
                    } else {
                        // Climb up or down - use constant speed rather than deltaTime
                        // to avoid dependency issues
                        const climbSpeed = 0.9;
                        this.y -= Math.sign(heightDiff) * climbSpeed;
                        
                        // IMPORTANT: Ensure squirrel stays exactly on trunk while climbing
                        this.x = this.climbingTree.x;
                        this.velocity.x = 0;
                    }
                } else {
                    // Move toward trunk with more control
                    const moveDir = this.x < this.climbingTree.x ? 1 : -1;
                    this.direction = moveDir;
                    
                    // Adjust force based on distance - slower approach when close
                    const approachForce = Math.min(0.01, distToTrunk * 0.003);
                    this.applyForce({ 
                        x: moveDir * approachForce, 
                        y: 0 
                    });
                    
                    // Add this check to prevent overshooting
                    if ((moveDir > 0 && this.velocity.x > 0.5) || 
                        (moveDir < 0 && this.velocity.x < -0.5)) {
                        this.velocity.x = moveDir * 0.5; // Cap velocity
                    }
                }
                
                // Birds sometimes chase squirrels from trees
                const nearbyBirdInTree = birds.find(bird => 
                    bird.perchTarget && 
                    bird.perchTarget.tree === this.climbingTree &&
                    distance(this.x, this.y, bird.x, bird.y) < 50
                );
                
                if (nearbyBirdInTree) {
                    // Fall out of tree
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.velocity.y = 0.5; // Initial falling velocity
                    debugLog(`Bird chased squirrel out of tree!`);
                }
                break;
                
            case 'inTree':
                // Verify tree still exists
                if (!this.climbingTree || trees.indexOf(this.climbingTree) === -1) {
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.climbingTree = null;
                    debugLog(`Squirrel's tree disappeared while in it!`);
                    break;
                }

                // CRITICAL FIX: Reset acceleration and force position to tree
                this.acceleration = { x: 0, y: 0 };
                
                // Keep squirrel at the target position with stronger enforcement
                this.x = this.climbingTree.x;
                this.y = this.targetY;
                this.velocity.x = 0; // Stop horizontal movement
                this.velocity.y *= 0.8; // Dampen vertical movement
                
                // Random small movements, but MUCH smaller to stay on trunk
                if (Math.random() < 0.1) {
                    this.applyForce({ 
                        x: (Math.random() - 0.5) * 0.0005, // Reduced by 2x
                        y: (Math.random() - 0.5) * 0.0005  // Reduced by 2x
                    });
                }
                
                // Eat nuts, or check nests
                if (this.nutCollected) {
                    // Eating animation
                    if (this.stateTimer > 8000) {
                        this.nutCollected = false;
                        debugLog(`Squirrel finished eating nut`);
                    }
                } else {
                    // V26: Reduced nest damage chance
                    // Look for bird nests - only if squirrel doesn't already have food
                    const nearbyNest = nests.find(nest => 
                        nest.tree === this.climbingTree &&
                        distance(this.x, this.y, nest.x, nest.y) < 40
                    );
                    
                    if (nearbyNest && Math.random() < 0.07) { // Reduced from 0.1
                        // Raid nest
                        nearbyNest.damage(4); // Reduced from 5
                        debugLog(`Squirrel damaged nest at (${nearbyNest.x}, ${nearbyNest.y})`);
                    }
                }

                // Random chance to knock a branch loose (becomes a twig on the ground)
                if (Math.random() < 0.0004) { // Reduced by 50% from 0.0008 to prevent branch pileup
                    const branchX = this.climbingTree.x + (Math.random() - 0.5) * 30;
                    const branchY = this.groundY - 5;
                    twigs.push({
                        x: branchX,
                        y: branchY,
                        collected: false,
                        size: 15 + Math.random() * 10,
                        angle: Math.random() * Math.PI * 2
                    });
                    debugLog(`Squirrel knocked a branch loose at (${branchX}, ${branchY})`);
                }

                // Birds sometimes chase squirrels from trees
                const birdInTree = birds.find(bird =>
                    bird.perchTarget &&
                    bird.perchTarget.tree === this.climbingTree &&
                    distance(this.x, this.y, bird.x, bird.y) < 30
                );
                
                if (birdInTree) {
                    // Fall out of tree
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.velocity.y = 0.5; // Initial falling velocity
                    debugLog(`Bird chased squirrel out of tree!`);
                }
                
                // Check for nearby trees to jump to (branch traversal)
                // FIX: Add cooldown (min 15 seconds between jumps) and prevent jumping back to same tree
                const timeSinceLastJump = Date.now() - this.lastJumpTime;
                const canJump = this.stateTimer > 5000 && timeSinceLastJump > 15000; // 15 second cooldown

                if (canJump && Math.random() < 0.02) { // Reduced chance from 0.03 to 0.02
                    // Look for nearby trees (exclude the tree we just came from)
                    const nearbyTrees = trees.filter(tree =>
                        tree !== this.climbingTree &&
                        tree !== this.lastJumpTree && // Don't jump back to tree we just came from
                        Math.abs(tree.x - this.climbingTree.x) < 120 && // Trees within 120px
                        Math.abs((tree.y - tree.trunkHeight * 0.8 * tree.scale) - this.y) < 60 // Similar height
                    );

                    if (nearbyTrees.length > 0) {
                        // Jump to nearby tree!
                        const targetTree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                        this.state = 'branchJumping';
                        this.jumpTargetTree = targetTree;
                        this.jumpStartX = this.x;
                        this.jumpStartY = this.y;
                        this.jumpProgress = 0;
                        this.stateTimer = 0;
                        this.lastJumpTime = Date.now(); // Track jump time
                        this.lastJumpTree = this.climbingTree; // Remember tree we're leaving
                        debugLog(`Squirrel jumping from tree to nearby tree at (${targetTree.x})`);
                        break;
                    }
                }

                // Eventually climb down
                if (this.stateTimer > 15000) {
                    this.state = 'climbing';
                    this.stateTimer = 0;
                    this.targetY = this.groundY - 5; // Ground level
                    debugLog(`Squirrel climbing down`);
                }
                break;
                
            case 'falling':
                // Apply gravity
                this.applyForce({ x: 0, y: 0.05 });
                
                // Check if reached ground (allow slightly below for foraging)
                if (this.y >= this.groundY + 15) {
                    this.y = this.groundY + 15;
                    this.velocity.y = 0;
                    this.state = 'stunned';
                    this.stateTimer = 0;
                    debugLog(`Squirrel hit the ground!`);
                }
                break;
                
            case 'stunned':
                // Stunned after falling, minimal movement
                this.velocity.x *= 0.95;
                this.velocity.y = 0;
                
                // Recover after a moment
                if (this.stateTimer > 2000) {
                    this.state = 'wandering';
                    this.stateTimer = 0;
                    this.fleeing = false;
                    this.climbingTree = null;
                    this.targetY = null;
                    debugLog(`Squirrel recovered from fall`);
                }
                break;
                
            case 'fleeing':
                // Run away fast
                this.applyForce({
                    x: this.direction * 0.05,
                    y: 0
                });

                // Allow exploring slightly below ground
                this.y = Math.min(this.y, this.groundY + 15);

                // Return to wandering after fleeing
                if (this.stateTimer > 3000) {
                    this.state = 'wandering';
                    this.stateTimer = 0;
                    this.fleeing = false;
                }
                break;

            case 'branchJumping':
                // Animate jump between trees
                if (!this.jumpTargetTree || trees.indexOf(this.jumpTargetTree) === -1) {
                    // Target tree disappeared, fall
                    this.state = 'falling';
                    this.stateTimer = 0;
                    break;
                }

                this.jumpProgress += deltaTime / 500; // 500ms jump duration

                if (this.jumpProgress >= 1) {
                    // Jump complete, attach to new tree
                    this.climbingTree = this.jumpTargetTree;
                    this.x = this.jumpTargetTree.x;
                    this.y = this.jumpTargetTree.y - this.jumpTargetTree.trunkHeight * 0.8 * this.jumpTargetTree.scale;
                    this.targetY = this.y;
                    this.state = 'inTree';
                    this.stateTimer = 0;
                    this.velocity = { x: 0, y: 0 };
                    debugLog(`Squirrel landed on tree at (${this.jumpTargetTree.x})`);
                } else {
                    // Arc motion during jump
                    const targetX = this.jumpTargetTree.x;
                    const targetY = this.jumpTargetTree.y - this.jumpTargetTree.trunkHeight * 0.8 * this.jumpTargetTree.scale;

                    this.x = this.jumpStartX + (targetX - this.jumpStartX) * this.jumpProgress;
                    this.y = this.jumpStartY + (targetY - this.jumpStartY) * this.jumpProgress - Math.sin(this.jumpProgress * Math.PI) * 30;

                    // Face direction of jump
                    this.direction = targetX > this.jumpStartX ? 1 : -1;
                }
                break;
                
                case 'leaving':
    // Follow path to exit just like 'flying' state
    if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
        const waypoint = this.path[this.pathIndex];
        const waypointDist = distance(this.x, this.y, waypoint.x, waypoint.y);
        
        if (waypointDist < 10) {
            // Reached waypoint, move to next
            this.pathIndex++;
        } else {
            // Move toward waypoint
            const dx = waypoint.x - this.x;
            const dy = waypoint.y - this.y;
            const dir = normalize(dx, dy);
            
            // Move faster when leaving
            this.applyForce({ 
                x: dir.x * 0.03, 
                y: dir.y * 0.02 
            });
            
            // Face direction of movement
            if (Math.abs(dx) > 2) {
                this.direction = dx > 0 ? 1 : -1;
            }
        }
    }
    
    // Check if off screen - only return true when actually off screen
    if (this.x < -50 || this.x > canvas.width + 50 || 
        this.y < -50 || this.y > canvas.height + 50) {
        debugLog(`Crow has left the screen at (${this.x}, ${this.y})`);
        return true; // Remove the crow
    }
    break;
        }
        
        // Update position with velocity
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.speed) {
            this.velocity.x = (this.velocity.x / speed) * this.speed;
            this.velocity.y = (this.velocity.y / speed) * this.speed;
        }
        
        // Update position
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);

        // CRITICAL FIX: Clamp squirrel to ground level when on ground (prevent floating)
        // Allow below ground for foraging, but never above ground unless in tree/jumping
        if (this.state === 'wandering' || this.state === 'foraging' || this.state === 'fleeing' || this.state === 'stunned') {
            if (this.y < this.groundY) {
                this.y = this.groundY;
                this.velocity.y = Math.max(0, this.velocity.y); // Only allow downward movement
            }
        }

        // Apply position constraints if not intentionally leaving
        if (this.state !== 'leaving') {
            validatePosition(this);
        }

        return false;
    }
    
    draw() {
        const tailWag = Math.sin(this.tailWobble) * 8;
        const tailWagOffset = Math.cos(this.tailWobble) * 5;
        
        // Draw bushy tail
        ctx.fillStyle = '#B25D18';
        
        // Tail position and shape depends on state
        const tailBaseX = this.x + (this.direction * -8);
        const tailBaseY = this.y - 3;
        
        // Tail shape varies by state
        if (this.state === 'falling') {
            // Spread tail when falling
            ctx.beginPath();
            ctx.ellipse(
                tailBaseX, 
                tailBaseY + 5,
                20, 
                10, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
        } else if (this.state === 'stunned') {
            // Flat tail when stunned
            ctx.beginPath();
            ctx.ellipse(
                tailBaseX, 
                tailBaseY + 5,
                12, 
                4, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
        } else {
            // Normal bushy tail with movement
            ctx.beginPath();
            ctx.moveTo(tailBaseX, tailBaseY);
            
            ctx.bezierCurveTo(
    tailBaseX + (this.direction * -20), tailBaseY + tailWagOffset, 
    tailBaseX + (this.direction * -50), tailBaseY + tailWag, 
    tailBaseX + (this.direction * -30), tailBaseY + tailWag + 5
);
            
            ctx.bezierCurveTo(
                tailBaseX + (this.direction * -18), tailBaseY + tailWag, 
                tailBaseX + (this.direction * -10), tailBaseY + tailWagOffset - 2, 
                tailBaseX, tailBaseY - 3
            );
            
            ctx.fill();
        }
        
        // Body
        ctx.fillStyle = '#B25D18';
        ctx.beginPath();
        ctx.ellipse(
            this.x, 
            this.y, 
            12, 
            7, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Head
        ctx.fillStyle = '#B25D18';
        ctx.beginPath();
        ctx.ellipse(
            this.x + (this.direction * 10), 
            this.y - 3, 
            7, 
            6, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 12), 
            this.y - 4, 
            1.5, 
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Ears
        ctx.fillStyle = '#B25D18';
        ctx.beginPath();
        ctx.ellipse(
            this.x + (this.direction * 13), 
            this.y - 8, 
            2, 
            3, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw nut if holding one
        if (this.nutCollected) {
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(
                this.x + (this.direction * 15), 
                this.y, 
                3, 
                0, Math.PI * 2
            );
            ctx.fill();
        }
        
        if (debugVisuals) {
            // Vision circle
            ctx.strokeStyle = 'rgba(200, 100, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, SQUIRREL_VISION_RADIUS, 0, Math.PI * 2);
            ctx.stroke();
            
            // State text
            ctx.fillStyle = 'white';
            ctx.font = '8px Arial';
            ctx.fillText(this.state, this.x - 10, this.y - 15);
        }
    }
}



class Butterfly {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.state = 'flying'; // flying, approaching, resting, leaving
        this.stateTimer = 0;
        this.wingFlap = Math.random() * Math.PI * 2; // Random start position
        this.targetFlower = null;
        this.speed = 0.6 + Math.random() * 0.4; // Slower than birds
        this.size = 8 + Math.random() * 5; // Increased size for visibility
        this.restingTime = 3000 + Math.random() * 7000; // 3-10 seconds at a flower
        this.dancingFrequency = 0.01 + Math.random() * 0.02; // For dancing flight pattern
        this.dancingAmplitude = 10 + Math.random() * 15; // How large the dancing circles are
        this.dancingTimer = Math.random() * Math.PI * 2; // Offset the dancing pattern
        this.exitPoint = null;
        this.lastFlowerChange = 0; // Track when we last moved to a different flower
        
        // Choose a butterfly style (0-3)
        this.butterflyStyle = Math.floor(Math.random() * 4);
        
        // Cute pastel colors for butterflies
        const butterflyColors = [
            // Pastel colors for cuter appearance
            "#FFB6C1", // Light pink
            "#FFC3A0", // Peach
            "#FFDFBA", // Pale orange
            "#FFFFBA", // Pale yellow
            "#BAFFC9", // Pale green
            "#BAE1FF", // Pale blue
            "#E2BAFF", // Pale purple
            "#D4F0F0", // Pale turquoise
            "#FFC8DD", // Pink
            "#BDFFFD"  // Aqua
        ];
        
        // Choose main color
        this.primaryColor = butterflyColors[Math.floor(Math.random() * butterflyColors.length)];
        
        // Choose secondary color with some logic for good combinations
        const index = butterflyColors.indexOf(this.primaryColor);
        const complementaryIndex = (index + 4) % butterflyColors.length; // Pick a complementary color
        this.secondaryColor = butterflyColors[complementaryIndex];
        
        // Pattern type (0-2: dots, stripes, gradient)
        this.patternType = Math.floor(Math.random() * 3);
        
        // Pattern color
        const patternIndex = (index + 2) % butterflyColors.length;
        this.patternColor = butterflyColors[patternIndex];
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    update(deltaTime) {


// Make butterflies leave at night
if (timeOfDay >= 1 && this.state !== 'leaving') {
        this.state = 'leaving';
        this.stateTimer = 0;
        this.targetFlower = null;
        
        // Choose a random edge to exit toward
        const exitEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let exitX, exitY;
        switch(exitEdge) {
            case 0: // Top
                exitX = Math.random() * canvas.width;
                exitY = -50;
                break;
            case 1: // Right
                exitX = canvas.width + 50;
                exitY = Math.random() * canvas.height * 0.7;
                break;
            case 2: // Bottom
                exitX = Math.random() * canvas.width;
                exitY = canvas.height + 50;
                break;
            case 3: // Left
                exitX = -50;
                exitY = Math.random() * canvas.height * 0.7;
                break;
        }
        this.exitPoint = { x: exitX, y: exitY };
        
        if (typeof debugLog === 'function') {
            debugLog("Butterfly leaving due to nightfall");
        }
    }

        // Update animation timers
        this.stateTimer += deltaTime;
        this.wingFlap += 0.3 * deltaTime / 16; // Wing flap speed
        this.dancingTimer += this.dancingFrequency * deltaTime / 16; // Dancing motion timer
        


        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        switch (this.state) {
            case 'flying':
                // Apply a dancing/bobbing motion for cute effect
                const dancingX = Math.sin(this.dancingTimer) * this.dancingAmplitude;
                const dancingY = Math.cos(this.dancingTimer * 0.8) * (this.dancingAmplitude * 0.5);
                
                this.applyForce({
                    x: dancingX * 0.001, // Gentle force for dancing motion
                    y: dancingY * 0.001
                });
                
                // Occasional random direction changes
                if (Math.random() < 0.02) {
                    this.applyForce({
                        x: (Math.random() - 0.5) * 0.03,
                        y: (Math.random() - 0.5) * 0.02
                    });
                    
                    // Occasionally flip direction for visual interest
                    if (Math.random() < 0.3) {
                        this.direction *= -1;
                    }
                }
                
                // Look for flowers to visit
                if (typeof flowers !== 'undefined' && Array.isArray(flowers) && flowers.length > 0 && Math.random() < 0.1) {
                    // Find a flower to visit that isn't the current target
                    let availableFlowers = flowers.filter(flower => 
                        this.targetFlower === null || flower !== this.targetFlower
                    );
                    
                    if (availableFlowers.length > 0) {
                        // Choose a random flower from available ones
                        this.targetFlower = availableFlowers[Math.floor(Math.random() * availableFlowers.length)];
                        this.state = 'approaching';
                        this.stateTimer = 0;
                        this.lastFlowerChange = Date.now();
                        
                        if (typeof debugLog === 'function') {
                            debugLog(`Butterfly heading to a new flower at (${this.targetFlower.x}, ${this.targetFlower.y})`);
                        }
                    }
                }
                
                // Occasionally decide to leave
                if (this.stateTimer > 30000 && Math.random() < 0.01) {
                    this.state = 'leaving';
                    this.stateTimer = 0;
                    this.targetFlower = null;
                    
                    if (typeof debugLog === 'function') {
                        debugLog(`Butterfly decided to leave the garden`);
                    }
                }
                break;
                
            case 'approaching':
                if (!this.targetFlower || typeof flowers === 'undefined' || !Array.isArray(flowers) || 
                    !flowers.includes(this.targetFlower)) {
                    // Target flower is gone, return to flying
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.targetFlower = null;
                    break;
                }
                
                // Move toward flower with a dancing motion
                const dx = this.targetFlower.x - this.x;
                const dy = this.targetFlower.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Add dancing motion while approaching
                const approachDancingX = Math.sin(this.dancingTimer * 1.5) * (this.dancingAmplitude * 0.5);
                const approachDancingY = Math.cos(this.dancingTimer) * (this.dancingAmplitude * 0.3);
                
                if (dist < 10) {
                    // Reached flower, start resting
                    this.state = 'resting';
                    this.stateTimer = 0;
                    
                    // Position exactly on flower
                    this.x = this.targetFlower.x;
                    this.y = this.targetFlower.y - 5; // Just above flower
                    
                    if (typeof debugLog === 'function') {
                        debugLog(`Butterfly resting on flower at (${this.targetFlower.x}, ${this.targetFlower.y})`);
                    }
                } else {
                    // Calculate direction to flower
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    
                    // Apply dancing motion to approach path
                    dirX += approachDancingX * 0.01;
                    dirY += approachDancingY * 0.01;
                    
                    // Normalize the direction
                    const normFactor = 1 / Math.sqrt(dirX * dirX + dirY * dirY);
                    dirX *= normFactor;
                    dirY *= normFactor;
                    
                    // Apply force toward flower with dancing
                    this.applyForce({
                        x: dirX * 0.01,
                        y: dirY * 0.01
                    });
                    
                    // Face direction of movement
                    if (Math.abs(dx) > 2) {
                        this.direction = dx > 0 ? 1 : -1;
                    }
                    
                    // If taking too long to reach flower, give up
                    if (this.stateTimer > 10000) {
                        this.state = 'flying';
                        this.stateTimer = 0;
                        this.targetFlower = null;
                    }
                }
                break;
                
            case 'resting':
                // Stay at flower position with slight movement
                if (this.targetFlower && typeof flowers !== 'undefined' && Array.isArray(flowers) && 
                    flowers.includes(this.targetFlower)) {
                    
                    // Subtle movement while resting (wing fluttering)
                    this.x = this.targetFlower.x + Math.sin(this.wingFlap * 0.5) * 2;
                    this.y = this.targetFlower.y - 5 + Math.cos(this.wingFlap * 0.3) * 2;
                    
                    // Reset velocity while resting
                    this.velocity.x *= 0.8;
                    this.velocity.y *= 0.8;
                } else {
                    // Flower is gone, go back to flying
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.targetFlower = null;
                    break;
                }
                
                // End resting after specified time
                if (this.stateTimer > this.restingTime) {
                    if (Math.random() < 0.8) {
                        // Usually look for a new flower
                        this.state = 'flying';
                        this.stateTimer = 0;
                        // Don't immediately clear target flower so we don't pick the same one
                        setTimeout(() => {
                            if (this && this.state === 'flying') {
                                this.targetFlower = null;
                            }
                        }, 1000);
                    } else {
                        // Sometimes decide to leave
                        this.state = 'leaving';
                        this.stateTimer = 0;
                        this.targetFlower = null;
                    }
                }
                break;
                
            case 'leaving':
                // Choose a random edge to fly toward if we haven't yet
                if (!this.exitPoint) {
                    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                    
                    switch (edge) {
                        case 0: // Top
                            this.exitPoint = { x: Math.random() * canvas.width, y: -50 };
                            break;
                        case 1: // Right
                            this.exitPoint = { x: canvas.width + 50, y: Math.random() * canvas.height * 0.7 };
                            break;
                        case 2: // Bottom
                            this.exitPoint = { x: Math.random() * canvas.width, y: canvas.height + 50 };
                            break;
                        case 3: // Left
                            this.exitPoint = { x: -50, y: Math.random() * canvas.height * 0.7 };
                            break;
                    }
                }
                
                // Move toward exit point with dancing motion
                const exitDx = this.exitPoint.x - this.x;
                const exitDy = this.exitPoint.y - this.y;
                const exitDist = Math.sqrt(exitDx * exitDx + exitDy * exitDy);
                
                // Add dancing motion while leaving
                const leavingDanceX = Math.sin(this.dancingTimer * 1.2) * this.dancingAmplitude;
                const leavingDanceY = Math.cos(this.dancingTimer * 0.9) * (this.dancingAmplitude * 0.5);
                
                // If reached exit point or off screen, remove butterfly
                if (exitDist < 10 || 
                    this.x < -100 || this.x > (canvas ? canvas.width : 1000) + 100 || 
                    this.y < -100 || this.y > (canvas ? canvas.height : 1000) + 100) {
                    return true; // Remove butterfly
                }
                
                // Calculate direction to exit
                let exitDirX = exitDx / exitDist;
                let exitDirY = exitDy / exitDist;
                
                // Add dancing motion
                exitDirX += leavingDanceX * 0.001;
                exitDirY += leavingDanceY * 0.001;
                
                // Apply force toward exit with dancing
                this.applyForce({
                    x: exitDirX * 0.02,
                    y: exitDirY * 0.01
                });
                
                // Face direction of movement
                if (Math.abs(exitDx) > 2) {
                    this.direction = exitDx > 0 ? 1 : -1;
                }
                break;
        }
        
        // Update velocity with acceleration
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Add gentle gravity (lighter than birds)
        if (this.state !== 'resting' && typeof GRAVITY !== 'undefined') {
            this.applyForce({ x: 0, y: GRAVITY * 0.2 });
        }
        
        // Apply air resistance
        if (typeof AIR_RESISTANCE !== 'undefined') {
            this.velocity.x *= AIR_RESISTANCE;
            this.velocity.y *= AIR_RESISTANCE;
        } else {
            // Fallback if AIR_RESISTANCE isn't defined
            this.velocity.x *= 0.98;
            this.velocity.y *= 0.98;
        }
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.speed) {
            this.velocity.x = (this.velocity.x / speed) * this.speed;
            this.velocity.y = (this.velocity.y / speed) * this.speed;
        }
        
        // Update position
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Apply position constraints if not intentionally leaving
        if (this.state !== 'leaving' && typeof validatePosition === 'function') {
            try {
                validatePosition(this);
            } catch (e) {
                // Ignore errors in validatePosition
            }
        }
        
        return false; // Don't remove by default
    }
    
    draw() {
        // Get wing flap animation parameters
        const wingOpen = Math.abs(Math.sin(this.wingFlap)); // 0-1 for closed-open wings
        const wingFlapSpeed = this.state === 'resting' ? 0.2 : 1.0; // Slower flapping when resting
        
        // Save context for transformations
        ctx.save();
        
        // Translate to butterfly position
        ctx.translate(this.x, this.y);
        
        // Different butterfly styles
        switch (this.butterflyStyle) {
            case 0: // Heart-shaped wings
                this.drawHeartButterfly(wingOpen);
                break;
            case 1: // Rounded wings with patterns
                this.drawRoundedButterfly(wingOpen);
                break;
            case 2: // Fairy-like wings
                this.drawFairyButterfly(wingOpen);
                break;
            case 3: // Classic butterfly shape
            default:
                this.drawClassicButterfly(wingOpen);
                break;
        }
        
        // Restore context
        ctx.restore();
    }
    
    drawHeartButterfly(wingOpen) {
        // Heart-shaped wings butterfly
        const wingScale = this.size * (0.8 + wingOpen * 0.4); // Size changes with wing flap
        const bodyWidth = this.size * 0.2;
        const bodyLength = this.size * 1.2;
        
        // Draw wings - they'll be heart-shaped
        ctx.fillStyle = this.primaryColor;
        
        // Upper wings (heart shapes)
        // Right wing
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Draw heart-shaped wing
        this.drawHeart(
            bodyWidth * 1.5, // x offset from center
            -bodyLength * 0.3, // y offset from center
            wingScale // size factor
        );
        
        // Left wing (mirror)
        this.drawHeart(
            -bodyWidth * 1.5, // opposite x offset 
            -bodyLength * 0.3,
            wingScale
        );
        
        // Lower wings (smaller hearts)
        this.drawHeart(
            bodyWidth * 1.3,
            bodyLength * 0.2,
            wingScale * 0.7
        );
        
        this.drawHeart(
            -bodyWidth * 1.3,
            bodyLength * 0.2,
            wingScale * 0.7
        );
        
        ctx.restore();
        
        // Draw patterns on wings
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Draw patterns based on pattern type
        switch (this.patternType) {
            case 0: // Dots
                ctx.fillStyle = this.patternColor;
                // Dots on upper wings
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        bodyWidth * 1.5 + (i - 1) * (wingScale * 0.3),
                        -bodyLength * 0.3 + (i % 2) * (wingScale * 0.2),
                        wingScale * 0.1,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Mirror for left wing
                    ctx.beginPath();
                    ctx.arc(
                        -bodyWidth * 1.5 - (i - 1) * (wingScale * 0.3),
                        -bodyLength * 0.3 + (i % 2) * (wingScale * 0.2),
                        wingScale * 0.1,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                break;
                
            case 1: // Stripes
                ctx.fillStyle = this.patternColor;
                // Stripes on upper wings
                for (let i = 0; i < 3; i++) {
                    // Right wing stripe
                    ctx.beginPath();
                    ctx.moveTo(bodyWidth * 1.2 + i * (wingScale * 0.2), -bodyLength * 0.5);
                    ctx.lineTo(bodyWidth * 1.8 + i * (wingScale * 0.2), -bodyLength * 0.1);
                    ctx.lineTo(bodyWidth * 1.8 + i * (wingScale * 0.2) + 2, -bodyLength * 0.1);
                    ctx.lineTo(bodyWidth * 1.2 + i * (wingScale * 0.2) + 2, -bodyLength * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Left wing stripe (mirrored)
                    ctx.beginPath();
                    ctx.moveTo(-bodyWidth * 1.2 - i * (wingScale * 0.2), -bodyLength * 0.5);
                    ctx.lineTo(-bodyWidth * 1.8 - i * (wingScale * 0.2), -bodyLength * 0.1);
                    ctx.lineTo(-bodyWidth * 1.8 - i * (wingScale * 0.2) - 2, -bodyLength * 0.1);
                    ctx.lineTo(-bodyWidth * 1.2 - i * (wingScale * 0.2) - 2, -bodyLength * 0.5);
                    ctx.closePath();
                    ctx.fill();
                }
                break;
                
            case 2: // Gradient/eye spots
                // Eye spots on wings
                ctx.fillStyle = this.secondaryColor;
                
                // Right wing eye spot
                ctx.beginPath();
                ctx.arc(
                    bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.25,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Left wing eye spot
                ctx.beginPath();
                ctx.arc(
                    -bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.25,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Inner eye spots
                ctx.fillStyle = this.patternColor;
                
                ctx.beginPath();
                ctx.arc(
                    bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.15,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    -bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.15,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Center of eye spots
                ctx.fillStyle = 'white';
                
                ctx.beginPath();
                ctx.arc(
                    bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.05,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    -bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.05,
                    0, Math.PI * 2
                );
                ctx.fill();
                break;
        }
        
        ctx.restore();
        
        // Draw body
        this.drawBody(bodyWidth, bodyLength);
    }
    
    drawRoundedButterfly(wingOpen) {
        // Rounded wings butterfly with patterns
        const wingScale = this.size * (0.8 + wingOpen * 0.4);
        const bodyWidth = this.size * 0.2;
        const bodyLength = this.size * 1.2;
        
        // Draw wings - round and cute
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Upper wings
        ctx.fillStyle = this.primaryColor;
        
        // Right upper wing
        ctx.beginPath();
        ctx.ellipse(
            bodyWidth * 1.2,
            -bodyLength * 0.3,
            wingScale,
            wingScale * 1.2,
            -Math.PI * 0.2,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Left upper wing
        ctx.beginPath();
        ctx.ellipse(
            -bodyWidth * 1.2,
            -bodyLength * 0.3,
            wingScale,
            wingScale * 1.2,
            Math.PI * 0.2,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Lower wings
        ctx.fillStyle = this.secondaryColor;
        
        // Right lower wing
        ctx.beginPath();
        ctx.ellipse(
            bodyWidth * 1.0,
            bodyLength * 0.3,
            wingScale * 0.8,
            wingScale * 0.9,
            -Math.PI * 0.1,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Left lower wing
        ctx.beginPath();
        ctx.ellipse(
            -bodyWidth * 1.0,
            bodyLength * 0.3,
            wingScale * 0.8,
            wingScale * 0.9,
            Math.PI * 0.1,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw patterns
        ctx.fillStyle = this.patternColor;
        
        // Pattern depends on pattern type
        switch (this.patternType) {
            case 0: // Polka dots
                // Dots on right wing
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI;
                    const dotX = bodyWidth * 1.2 + Math.cos(angle) * (wingScale * 0.6);
                    const dotY = -bodyLength * 0.3 + Math.sin(angle) * (wingScale * 0.7);
                    
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, wingScale * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Mirror for left wing
                    ctx.beginPath();
                    ctx.arc(-dotX, dotY, wingScale * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 1: // Border trim
                // Right upper wing border
                ctx.beginPath();
                ctx.ellipse(
                    bodyWidth * 1.2,
                    -bodyLength * 0.3,
                    wingScale * 0.8,
                    wingScale,
                    -Math.PI * 0.2,
                    0, Math.PI * 2
                );
                ctx.stroke();
                
                // Left upper wing border
                ctx.beginPath();
                ctx.ellipse(
                    -bodyWidth * 1.2,
                    -bodyLength * 0.3,
                    wingScale * 0.8,
                    wingScale,
                    Math.PI * 0.2,
                    0, Math.PI * 2
                );
                ctx.stroke();
                break;
                
            case 2: // Swirls
                // Right wing swirl
                ctx.beginPath();
                ctx.moveTo(bodyWidth, -bodyLength * 0.3);
                for (let i = 0; i < 3; i++) {
                    const t = i / 3;
                    const spiralX = bodyWidth + wingScale * t * Math.cos(t * Math.PI * 4);
                    const spiralY = -bodyLength * 0.3 + wingScale * t * Math.sin(t * Math.PI * 4);
                    ctx.lineTo(spiralX, spiralY);
                }
                ctx.stroke();
                
                // Left wing swirl (mirrored)
                ctx.beginPath();
                ctx.moveTo(-bodyWidth, -bodyLength * 0.3);
                for (let i = 0; i < 3; i++) {
                    const t = i / 3;
                    const spiralX = -bodyWidth - wingScale * t * Math.cos(t * Math.PI * 4);
                    const spiralY = -bodyLength * 0.3 + wingScale * t * Math.sin(t * Math.PI * 4);
                    ctx.lineTo(spiralX, spiralY);
                }
                ctx.stroke();
                break;
        }
        
        ctx.restore();
        
        // Draw body
        this.drawBody(bodyWidth, bodyLength);
    }
    
    drawFairyButterfly(wingOpen) {
        // Fairy-like wings butterfly (more ethereal and translucent)
        const wingScale = this.size * (0.8 + wingOpen * 0.4);
        const bodyWidth = this.size * 0.3; // Slimmer body
        const bodyLength = this.size * 1.2;
        
        // Wing transparency
        ctx.globalAlpha = 0.7; // Make wings translucent
        
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Upper wings (elongated and more fairy-like)
        ctx.fillStyle = this.primaryColor;
        
        // Right wing
        ctx.beginPath();
        ctx.moveTo(0, 0); // Start at body center
        ctx.quadraticCurveTo(
            bodyWidth * 2, -bodyLength * 0.8,
            bodyWidth * 3, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            bodyWidth * 2.5, bodyLength * 0.1,
            0, 0
        );
        ctx.fill();
        
        // Left wing (mirrored)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            -bodyWidth * 2, -bodyLength * 0.8,
            -bodyWidth * 3, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 2.5, bodyLength * 0.1,
            0, 0
        );
        ctx.fill();
        
        // Lower wings
        ctx.fillStyle = this.secondaryColor;
        
        // Right lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            bodyWidth * 1.5, bodyLength * 0.3,
            bodyWidth * 2, bodyLength * 0.7
        );
        ctx.quadraticCurveTo(
            bodyWidth * 1, bodyLength * 0.5,
            0, 0
        );
        ctx.fill();
        
        // Left lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            -bodyWidth * 1.5, bodyLength * 0.3,
            -bodyWidth * 2, bodyLength * 0.7
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 1, bodyLength * 0.5,
            0, 0
        );
        ctx.fill();
        
        // Add magical sparkles/fairy dust
        ctx.fillStyle = 'white';
        for (let i = 0; i < 10; i++) {
            // Random position across both wings
            const side = Math.random() < 0.5 ? 1 : -1;
            const sparkleX = side * bodyWidth * (0.5 + Math.random() * 2.5);
            const sparkleY = (Math.random() - 0.5) * bodyLength;
            
            // Vary sparkle size based on wing flap
            const sparkleSize = wingScale * 0.05 * (0.5 + wingOpen * 0.5);
            
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Wing veins
        ctx.strokeStyle = this.patternColor;
        ctx.lineWidth = 0.5;
        
        // Draw delicate wing veins
        // Right upper wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(bodyWidth * 1.5, -bodyLength * 0.5);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(bodyWidth * 2, -bodyLength * 0.2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(bodyWidth * 2, bodyLength * 0.1);
        ctx.stroke();
        
        // Left upper wing (mirrored)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-bodyWidth * 1.5, -bodyLength * 0.5);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-bodyWidth * 2, -bodyLength * 0.2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-bodyWidth * 2, bodyLength * 0.1);
        ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1.0; // Reset transparency
        
        // Draw body - more elongated for fairy-like appearance
        this.drawFairyBody(bodyWidth, bodyLength);
    }
    
    drawClassicButterfly(wingOpen) {
        // Classic butterfly shape
        const wingScale = this.size * (0.8 + wingOpen * 0.4);
        const bodyWidth = this.size * 0.1;
        const bodyLength = this.size * 1.3;
        
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Upper wings
        ctx.fillStyle = this.primaryColor;
        
        // Right upper wing
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.3);
        ctx.quadraticCurveTo(
            bodyWidth * 1.2, -bodyLength * 0.9,
            bodyWidth * 2.2, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            bodyWidth * 1.5, bodyLength * 0.1,
            0, 0
        );
        ctx.closePath();
        ctx.fill();
        
        // Left upper wing (mirrored)
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.3);
        ctx.quadraticCurveTo(
            -bodyWidth * 1.2, -bodyLength * 0.9,
            -bodyWidth * 2.2, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 1.5, bodyLength * 0.1,
            0, 0
        );
        ctx.closePath();
        ctx.fill();
        
        // Lower wings
        ctx.fillStyle = this.secondaryColor;
        
        // Right lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            bodyWidth * 1.2, bodyLength * 0.3,
            bodyWidth * 1.5, bodyLength * 0.8
        );
        ctx.quadraticCurveTo(
            bodyWidth * 0.5, bodyLength * 0.5,
            0, bodyLength * 0.3
        );
        ctx.closePath();
        ctx.fill();
        
        // Left lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            -bodyWidth * 1.2, bodyLength * 0.3,
            -bodyWidth * 1.5, bodyLength * 0.8
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 0.5, bodyLength * 0.5,
            0, bodyLength * 0.3
        );
        ctx.closePath();
        ctx.fill();
        
        // Wing patterns
        ctx.fillStyle = this.patternColor;
        
        switch (this.patternType) {
            case 0: // Border pattern
                ctx.lineWidth = wingScale * 0.15;
                ctx.strokeStyle = this.patternColor;
                
                // Right upper wing border
                ctx.beginPath();
                ctx.moveTo(bodyWidth * 0.5, -bodyLength * 0.2);
                ctx.quadraticCurveTo(
                    bodyWidth * 1.0, -bodyLength * 0.6,
                    bodyWidth * 1.8, -bodyLength * 0.3
                );
                ctx.stroke();
                
                // Left upper wing border (mirrored)
                ctx.beginPath();
                ctx.moveTo(-bodyWidth * 0.5, -bodyLength * 0.2);
                ctx.quadraticCurveTo(
                    -bodyWidth * 1.0, -bodyLength * 0.6,
                    -bodyWidth * 1.8, -bodyLength * 0.3
                );
                ctx.stroke();
                break;
                
            case 1: // Spots
                // Right wing spots
                for (let i = 0; i < 3; i++) {
                    const spotX = bodyWidth * (0.5 + i * 0.5);
                    const spotY = -bodyLength * 0.2 - i * bodyLength * 0.1;
                    const spotSize = wingScale * (0.1 + i * 0.02);
                    
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Mirror spots for left wing
                    ctx.beginPath();
                    ctx.arc(-spotX, spotY, spotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 2: // Stripes
                // Upper wing stripes
                ctx.lineWidth = wingScale * 0.1;
                ctx.strokeStyle = this.patternColor;
                
                for (let i = 0; i < 3; i++) {
                    const y = -bodyLength * 0.3 + i * bodyLength * 0.15;
                    
                    // Right wing stripe
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.quadraticCurveTo(
                        bodyWidth * 0.8, y - bodyLength * 0.1,
                        bodyWidth * 1.6, y
                    );
                    ctx.stroke();
                    
                    // Left wing stripe (mirrored)
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.quadraticCurveTo(
                        -bodyWidth * 0.8, y - bodyLength * 0.1,
                        -bodyWidth * 1.6, y
                    );
                    ctx.stroke();
                }
                break;
        }
        
        ctx.restore();
        
        // Draw body
        this.drawBody(bodyWidth, bodyLength);
    }
    
    drawBody(bodyWidth, bodyLength) {
        // Body
        ctx.fillStyle = '#555555'; // Darker body
        
        // Main body
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyWidth, bodyLength * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.4, bodyWidth * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Antennae
        ctx.strokeStyle = '#555555';
        ctx.lineWidth = 1;
        
        // Left antenna
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        let antennaEndX = -bodyWidth * 1.5;
        let antennaEndY = -bodyLength * 0.8;
        ctx.quadraticCurveTo(
            -bodyWidth * 0.8, -bodyLength * 0.7,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Antenna ball
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right antenna
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        antennaEndX = bodyWidth * 1.5;
        ctx.quadraticCurveTo(
            bodyWidth * 0.8, -bodyLength * 0.7,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Antenna ball
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'white';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupils
        ctx.fillStyle = 'black';
        
        // Left pupil
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Right pupil
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Smile
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.35, bodyWidth * 0.3, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }
    
    drawFairyBody(bodyWidth, bodyLength) {
        // Slimmer body for fairy butterfly
        ctx.fillStyle = '#555555';
        
        // Main body - slimmer
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyWidth * 0.8, bodyLength * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head - smaller
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.4, bodyWidth * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        // Longer, more elegant antennae
        ctx.strokeStyle = '#555555';
        ctx.lineWidth = 1;
        
        // Left antenna - curved
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        let antennaEndX = -bodyWidth * 2;
        let antennaEndY = -bodyLength * 1.0;
        ctx.quadraticCurveTo(
            -bodyWidth, -bodyLength * 0.8,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Small glowing dot at antenna end
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right antenna - curved
        ctx.strokeStyle = '#555555';
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        antennaEndX = bodyWidth * 2;
        ctx.quadraticCurveTo(
            bodyWidth, -bodyLength * 0.8,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Small glowing dot at antenna end
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Larger, more expressive eyes
        ctx.fillStyle = 'white';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupils - larger and more anime-like
        ctx.fillStyle = 'black';
        
        // Left pupil
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Right pupil
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlights
        ctx.fillStyle = 'white';
        
        // Left eye highlight
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.5, -bodyLength * 0.45, bodyWidth * 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye highlight
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.3, -bodyLength * 0.45, bodyWidth * 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Cute smile
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.33, bodyWidth * 0.3, 0.1, Math.PI - 0.1);
        ctx.stroke();
    }
    
    drawHeart(x, y, size) {
        // Helper function to draw a heart shape
        const halfSize = size / 2;
        
        ctx.beginPath();
        ctx.moveTo(x, y + halfSize * 0.7);
        
        // Left curve
        ctx.bezierCurveTo(
            x, y,
            x - halfSize, y,
            x - halfSize, y - halfSize * 0.5
        );
        
        // Left top curve
        ctx.bezierCurveTo(
            x - halfSize, y - halfSize * 1.5,
            x, y - halfSize * 1.5,
            x, y - halfSize * 0.7
        );
        
        // Right top curve
        ctx.bezierCurveTo(
            x, y - halfSize * 1.5,
            x + halfSize, y - halfSize * 1.5,
            x + halfSize, y - halfSize * 0.5
        );
        
        // Right curve
        ctx.bezierCurveTo(
            x + halfSize, y,
            x, y,
            x, y + halfSize * 0.7
        );
        
        ctx.fill();
    }
}

class Crow {
    constructor(startX, startY, index) {
        this.id = Math.random().toString(36).substr(2, 9); // Unique ID for naming
        this.x = startX;
        this.y = startY;
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.baseSpeed = 1.2; // Faster than regular birds
        this.state = 'flying';
        this.stateTimer = 0;
        this.path = [];
        this.pathIndex = 0;
        this.target = null;
        this.pecking = false;
        this.peckTimer = 0;
        this.wingFlap = Math.random() * Math.PI * 2; // Randomize wing position
        this.isFlying = true;
        this.flockIndex = index; // Position in the murder of crows
        this.moveOffset = Math.random() * Math.PI * 2; // For synchronized movement
        this.wormsEaten = 0;
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    findNearestWorm() {
        let closestWorm = null;
        let closestDist = Infinity;
        
        for (const worm of worms) {
            const dist = distance(this.x, this.y, worm.x, worm.y);
            if (dist < closestDist) {
                closestDist = dist;
                closestWorm = worm;
            }
        }
        
        if (closestWorm && closestDist < 500) { // Much larger vision radius
            this.target = {
                type: 'worm',
                worm: closestWorm,
                x: closestWorm.x,
                y: closestWorm.y
            };
            this.state = 'hunting';
            this.stateTimer = 0;
            return true;
        }
        
        return false;
    }

    findNearestFood() {
        // Find the nearest food source (worm, bush fruit, or food item)
        let closestFood = null;
        let closestDist = Infinity;
        const visionRadius = 500; // Use large vision radius for hungry birds

        // Check worms first (most nutritious)
        for (const worm of worms) {
            const dist = distance(this.x, this.y, worm.x, worm.y);
            if (dist < closestDist && dist < visionRadius && !this.isDangerZone(worm.x, worm.y)) {
                closestDist = dist;
                closestFood = {
                    type: 'worm',
                    entity: worm,
                    x: worm.x,
                    y: worm.y
                };
            }
        }

        // Check bushes with fruit
        for (const bush of bushes) {
            if (bush.fruitCount > 0) {
                const dist = distance(this.x, this.y, bush.x, bush.y - bush.height / 2);
                if (dist < closestDist && dist < visionRadius && !this.isDangerZone(bush.x, bush.y)) {
                    closestDist = dist;
                    closestFood = {
                        type: 'bush',
                        entity: bush,
                        x: bush.x,
                        y: bush.y - bush.height / 2
                    };
                }
            }
        }

        // Check food items
        for (const food of foodItems) {
            const dist = distance(this.x, this.y, food.x, food.y);
            if (dist < closestDist && dist < visionRadius && !this.isDangerZone(food.x, food.y)) {
                closestDist = dist;
                closestFood = {
                    type: 'food',
                    entity: food,
                    x: food.x,
                    y: food.y
                };
            }
        }

        return closestFood;
    }

    generatePath(targetX, targetY) {
        // Clear existing path
        this.path = [];
        this.pathIndex = 0;

        // FIXED: Use responsive scaling for high-res monitors
        const responsiveScale = getResponsiveScale();
        const margin = 50 * responsiveScale;

        // Keep target coordinates within visible bounds
        targetX = Math.max(margin, Math.min(canvas.width - margin, targetX));
        // Allow squirrels to reach ground level
        targetY = Math.max(margin, Math.min(canvas.height * GROUND_HEIGHT_RATIO + 20, targetY));
        
        // Start path at current position
        this.path.push({ x: this.x, y: this.y });
        
        // For longer paths, add intermediate points for more natural movement
        const dist = distance(this.x, this.y, targetX, targetY);
        
        if (dist > 100) {
            // Add proportional waypoints based on distance
            const waypoints = Math.min(3, 1 + Math.floor(dist / 200));
            
            for (let i = 0; i < waypoints; i++) {
                const progress = (i + 1) / (waypoints + 1);
                
                // Arc height for natural flight
                const arcHeight = Math.sin(progress * Math.PI) * 50;
                
                // Calculate position with arc
                const wayX = this.x + (targetX - this.x) * progress;
                const wayY = this.y + (targetY - this.y) * progress - arcHeight;
                
                this.path.push({ x: wayX, y: wayY });
            }
        }
        
        // Add target as final waypoint
        this.path.push({ x: targetX, y: targetY });
        
        // Set direction
        this.direction = targetX > this.x ? 1 : -1;
    }
    
    update(deltaTime) {

        let dx, dy, dist; // Declare once up here

        this.stateTimer += deltaTime;
        this.wingFlap += 0.2 * deltaTime / 16;
        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        // Update based on state
        switch (this.state) {
            case 'flying':
                // Follow flock path if not hunting
                this.velocity.x *= 0.97;
                this.velocity.y *= 0.97;
                
                // Check for worms periodically
                if (Math.random() < 0.05) {
                    if (this.findNearestWorm()) {
                        break; // Found a worm, switch to hunting
                    }
                }
                
                // Check for flock leader's path
                if (crows.length > 0 && this.flockIndex > 0) {
                    const leader = crows[0];
                    if (leader && leader.path && leader.path.length > 0) {
                        // Follow leader with slight offset based on flock position
                        const pathTarget = leader.path[Math.min(leader.pathIndex, leader.path.length - 1)];
                        
                        // Add periodic circular motion for flock formation
                        const circleRadius = 30 + this.flockIndex * 10;
                        const circleAngle = this.moveOffset + simulationTime * 0.0005;
                        const offsetX = Math.cos(circleAngle) * circleRadius;
                        const offsetY = Math.sin(circleAngle) * circleRadius * 0.5;
                        
                        // Move toward leader's path plus offset
                        if (pathTarget) {
                            const dx = (pathTarget.x + offsetX) - this.x;
                            const dy = (pathTarget.y + offsetY) - this.y;
                            const dir = normalize(dx, dy);
                            
                            this.applyForce({ 
                                x: dir.x * 0.02, 
                                y: dir.y * 0.01 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                        }
                    }
                } else if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                    // Leader or solo crow - follow own path
                    const waypoint = this.path[this.pathIndex];
                    const waypointDist = distance(this.x, this.y, waypoint.x, waypoint.y);
                    
                    if (waypointDist < 10) {
                        // Reached waypoint, move to next
                        this.pathIndex++;
                        
                        // If reached final waypoint, circle the area
                        if (this.pathIndex >= this.path.length) {
                            // Circle around current position
                            this.circleCurrent();
                        }
                    } else {
                        // Move toward waypoint
                        const dx = waypoint.x - this.x;
                        const dy = waypoint.y - this.y;
                        const dir = normalize(dx, dy);
                        
                        this.applyForce({ 
                            x: dir.x * 0.02, 
                            y: dir.y * 0.01 
                        });
                        
                        // Face direction of movement
                        if (Math.abs(dx) > 2) {
                            this.direction = dx > 0 ? 1 : -1;
                        }
                    }
                } else {
                    // No path, pick new destination
                    const groundY = canvas.height * GROUND_HEIGHT_RATIO - 30;
                    const targetX = Math.random() * canvas.width;
                    const targetY = Math.random() < 0.7 ? groundY : 100 + Math.random() * 150;
                    this.generatePath(targetX, targetY);
                }
                break;
                
            case 'hunting':
                // Check if target is valid
                if (!this.target || 
                    (this.target.type === 'worm' && worms.indexOf(this.target.worm) === -1)) {
                    // Target is gone, go back to flying
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.target = null;
                    break;
                }
                
                // Move toward target
                const huntTargetDist = distance(this.x, this.y, this.target.x, this.target.y);
                
                if (huntTargetDist < 15) {
                    // Reached target - eat it
                    if (this.target.type === 'worm') {
                        const wormIndex = worms.indexOf(this.target.worm);
                        if (wormIndex !== -1) {
                            worms.splice(wormIndex, 1);
                            this.wormsEaten++;
                            debugLog(`Crow ate worm at (${this.target.x}, ${this.target.y})`);
                        }
                    }

                    // Enhanced: Crows leave 3-4 worms behind (don't eat them all)
                    const wormsToLeave = 3 + Math.floor(Math.random() * 2); // 3-4 worms
                    if (worms.length > wormsToLeave && !this.findNearestWorm()) {
                        this.state = 'flying';
                        this.stateTimer = 0;
                    } else if (worms.length <= wormsToLeave) {
                        // Stop hunting, leave remaining worms for birds
                        this.state = 'flying';
                        this.stateTimer = 0;
                        debugLog(`Crow leaving ${worms.length} worms for the birds`);
                    }

                    this.target = null;
                } else {
                    // Move toward target
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dir = normalize(dx, dy);
                    
                    // Adjust speed based on distance
                    const speedFactor = huntTargetDist < 30 ? 
                        0.3 + huntTargetDist / 30 * 0.7 : 1.0;
                    
                    this.applyForce({ 
                        x: dir.x * 0.02 * speedFactor, 
                        y: dir.y * 0.01 * speedFactor 
                    });
                    
                    // Face direction of movement
                    if (Math.abs(dx) > 2) {
                        this.direction = dx > 0 ? 1 : -1;
                    }
                    
                    // If hunting is taking too long, give up
                    if (this.stateTimer > 5000) {
                        this.state = 'flying';
                        this.stateTimer = 0;
                        this.target = null;
                    }
                }
                break;
                
            case 'circling':
                // Circle around the current position
                if (this.stateTimer > 10000) {
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.findNearestWorm();
                }
                
                const circleTime = simulationTime * 0.001;
                const circleX = Math.cos(circleTime + this.moveOffset) * 100;
                const circleY = Math.sin(circleTime + this.moveOffset) * 50;
                
                const circleCenterX = this.x - circleX;
                const circleCenterY = this.y - circleY;
                
                const dx = circleCenterX + circleX - this.x;
                const dy = circleCenterY + circleY - this.y;
                
                const dir = normalize(dx, dy);
                this.applyForce({ 
                    x: dir.x * 0.01, 
                    y: dir.y * 0.005 
                });
                
                // Check for worms while circling
                if (Math.random() < 0.05) {
                    this.findNearestWorm();
                }
                break;
        }
        
        // Update position with velocity
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.baseSpeed) {
            this.velocity.x = (this.velocity.x / speed) * this.baseSpeed;
            this.velocity.y = (this.velocity.y / speed) * this.baseSpeed;
        }
        
        // Update position
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Keep crows in bounds
        validatePosition(this);
        
        return false; // Crow stays alive
    }
    
    circleCurrent() {
        this.state = 'circling';
        this.stateTimer = 0;
    }
    
    draw() {
        // Similar to bird drawing but black
        const sizeMultiplier = 1.05; // Slightly larger than regular birds
        
        // Determine if wings should be flapping
        const isFlapping = true; // Crows are always flying/flapping
        
        // Calculate position adjustments for flapping
        const yOffset = Math.sin(this.wingFlap * 0.5) * 1.5;
        
        // Wing position and spread
        const wingSpread = Math.abs(Math.sin(this.wingFlap)) * 1.2;
        const wingY = Math.cos(this.wingFlap) * 5;
        
        // Draw body - deep black
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(
            this.x, 
            this.y + yOffset, 
            10 * sizeMultiplier, 
            7 * sizeMultiplier, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw the tail - longer for crows
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        if (this.direction > 0) {
            ctx.moveTo(this.x - 10 * sizeMultiplier, this.y + yOffset);
            ctx.lineTo(this.x - 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x - 18 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
        } else {
            ctx.moveTo(this.x + 10 * sizeMultiplier, this.y + yOffset);
            ctx.lineTo(this.x + 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x + 18 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
        }
        ctx.fill();

        // Draw wings with dark color
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;

        if (this.direction > 0) {
            // Wing with stroke
            ctx.beginPath();
            ctx.moveTo(this.x - 5, this.y + yOffset);
            ctx.quadraticCurveTo(
                this.x - 8 * wingSpread, 
                this.y + 2 * wingSpread + wingY,
                this.x - 10 * wingSpread * sizeMultiplier, 
                this.y + 3 * sizeMultiplier + wingY
            );
            ctx.lineTo(
                this.x - 9 * wingSpread * sizeMultiplier,
                this.y + 9 * sizeMultiplier + wingY
            );
            ctx.quadraticCurveTo(
                this.x - 7 * wingSpread,
                this.y + 7 * wingSpread + wingY,
                this.x - 5,
                this.y + 3 + yOffset
            );
            ctx.closePath();
            ctx.stroke();
            
            ctx.fillStyle = '#000000';
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.moveTo(this.x + 5, this.y + yOffset);
            ctx.quadraticCurveTo(
                this.x + 8 * wingSpread,
                this.y + 2 * wingSpread + wingY,
                this.x + 10 * wingSpread * sizeMultiplier,
                this.y + 3 * sizeMultiplier + wingY
            );
            ctx.lineTo(
                this.x + 9 * wingSpread * sizeMultiplier,
                this.y + 9 * sizeMultiplier + wingY
            );
            ctx.quadraticCurveTo(
                this.x + 7 * wingSpread,
                this.y + 7 * wingSpread + wingY,
                this.x + 5,
                this.y + 3 + yOffset
            );
            ctx.closePath();
            ctx.stroke();
            
            ctx.fillStyle = '#000000';
            ctx.fill();
        }
        
        // Draw the head
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 8 * sizeMultiplier), 
            this.y - 2 * sizeMultiplier + yOffset, 
            6 * sizeMultiplier, 
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw beak - gray for crow orange chnaged 
        ctx.fillStyle = '#FF8800';
        ctx.beginPath();
        if (this.direction > 0) {
            ctx.moveTo(this.x + 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x + 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x + 12 * sizeMultiplier, this.y + yOffset);
        } else {
            ctx.moveTo(this.x - 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x - 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x - 12 * sizeMultiplier, this.y + yOffset);
        }
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 8 * sizeMultiplier), 
            this.y - 3 * sizeMultiplier + yOffset, 
            2 * sizeMultiplier,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Eye pupils - black
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 8.5 * sizeMultiplier), 
            this.y - 3 * sizeMultiplier + yOffset, 
            1 * sizeMultiplier,
            0, Math.PI * 2
        );
        ctx.fill();
    }
}

// Function to check if we should spawn crows
function checkForCrowVisit(deltaTime) {
    // Update timer if visit is in progress
    if (crowVisitInProgress) {
        crowVisitTimer += deltaTime;

        // Check if visit should end
        if (crowVisitTimer >= CROW_VISIT_DURATION) {
            // Make crows leave
            makeCrowsLeave();
            crowVisitInProgress = false;
            crowVisitTimer = 0;
            debugLog("Murder of crows leaving");
        }
        return;
    }

    // Don't spawn crows if a scarecrow is present
    if (scarecrow) {
        return;
    }

    // More random crow spawning - varies by worm count
    // The more worms, the higher the spawn chance, but it's still random
    const wormExcessFactor = Math.max(0, (worms.length - CROW_WORM_THRESHOLD) / 10);
    const baseSpawnChance = 0.0005; // Lower base chance (0.05% per frame)
    const wormBonusChance = wormExcessFactor * 0.0003; // Bonus increases with worm count
    const totalChance = Math.min(baseSpawnChance + wormBonusChance, 0.003); // Cap at 0.3%

    if (Math.random() < totalChance && worms.length >= CROW_WORM_THRESHOLD) {
        // Additional random roll to make it even more unpredictable
        if (Math.random() < 0.15) { // 15% chance after first roll
            spawnMurderOfCrows();
        }
    }
}

// Spawn a murder of crows
function spawnMurderOfCrows() {
    // Don't spawn if already visiting
    if (crowVisitInProgress) return;
    
    // Clear any existing crows
    crows = [];
    
    // Dramatic effect - darken sky slightly
    addSpecialEffect({
        type: 'darkening',
        duration: 5000,
        intensity: 0.2
    });
    
    // Add a sound effect if wind chimes are enabled
    if (windChimeEnabled && audioContext) {
        // Play ominous crow sound (low notes)
        const notes = ['C2', 'G2', 'D2'];
        for (let i = 0; i < notes.length; i++) {
            setTimeout(() => {
                playNote(notes[i], 2);
            }, i * 500);
        }
    }
    
    // Decide where crows will enter from
    const entryEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    
    // Entry point depends on edge
    let entryX, entryY;
    switch (entryEdge) {
        case 0: // Top
            entryX = canvas.width / 2;
            entryY = -50;
            break;
        case 1: // Right
            entryX = canvas.width + 50;
            entryY = canvas.height * 0.3;
            break;
        case 2: // Bottom
            entryX = canvas.width / 2;
            entryY = canvas.height + 50;
            break;
        case 3: // Left
            entryX = -50;
            entryY = canvas.height * 0.3;
            break;
    }
    
    // Spawn 5-7 crows
    const crowCount = 5 + Math.floor(Math.random() * 3);
    
    for (let i = 0; i < crowCount; i++) {
        const crow = new Crow(entryX, entryY, i);
        
        // Set initial target - area with worms
        const targetArea = getWormHotspot();
        const targetX = targetArea.x + (Math.random() - 0.5) * 100;
        const targetY = targetArea.y + (Math.random() - 0.5) * 50;
        
        crow.generatePath(targetX, targetY);
        crows.push(crow);
    }
    
    crowVisitInProgress = true;
    crowVisitTimer = 0;

    // Get names for all crows for the diary entry
    const crowNames = crows.map(c => getCrowName(c));
    const crowNamesText = crowNames.length > 3
        ? `${crowNames.slice(0, 2).join(', ')} and ${crowNames.length - 2} others`
        : crowNames.join(', ');

    debugLog(`Murder of ${crowCount} crows has arrived!`);
    addDiaryEntry(`The Great Worm Feast! A murder of crows (${crowNamesText}) descended upon the garden.`, 'visitor');
}

// Make all crows leave
function makeCrowsLeave() {
    // Choose an exit point
    const exitEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    
    // Exit coordinates
    let exitX, exitY;
    switch (exitEdge) {
        case 0: // Top
            exitX = canvas.width / 2;
            exitY = -100;
            break;
        case 1: // Right
            exitX = canvas.width + 100;
            exitY = canvas.height * 0.3;
            break;
        case 2: // Bottom
            exitX = canvas.width / 2;
            exitY = canvas.height + 100;
            break;
        case 3: // Left
            exitX = -100;
            exitY = canvas.height * 0.3;
            break;
    }
    
    // Give all crows a path to exit
    for (let i = 0; i < crows.length; i++) {
        const crow = crows[i];
        // Add slight offsets for formation
        const offsetX = exitX + (Math.random() - 0.5) * 150;
        const offsetY = exitY + (Math.random() - 0.5) * 50;
        
        // Create a state for leaving
        crow.state = 'leaving';
        crow.stateTimer = 0;
        
        // Generate path with intermediate points for smoother exit
        // Start with current position
        crow.path = [{ x: crow.x, y: crow.y }];
        
        // Add mid-point for natural arc
        const midX = crow.x + (offsetX - crow.x) * 0.5;
        const midY = crow.y + (offsetY - crow.y) * 0.3 - 50; // Higher mid-point for arc
        crow.path.push({ x: midX, y: midY });
        
        // Add exit point
        crow.path.push({ x: offsetX, y: offsetY });
        
        // Reset path index
        crow.pathIndex = 0;
        
        // Set direction based on exit
        crow.direction = offsetX > crow.x ? 1 : -1;
        
        debugLog(`Crow ${i} leaving toward (${offsetX}, ${offsetY})`);
    }
    
    // Don't remove crows with timeout anymore - they'll remove themselves when off-screen
}

// Find area with most worms
function getWormHotspot() {
    if (worms.length === 0) {
        return { 
            x: canvas.width / 2, 
            y: canvas.height * GROUND_HEIGHT_RATIO 
        };
    }
    
    // Divide canvas into grid cells
    const gridSize = 100;
    const gridCols = Math.ceil(canvas.width / gridSize);
    const gridRows = Math.ceil(canvas.height / gridSize);
    const grid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
    
    // Count worms in each grid cell
    for (const worm of worms) {
        const col = Math.min(gridCols - 1, Math.max(0, Math.floor(worm.x / gridSize)));
        const row = Math.min(gridRows - 1, Math.max(0, Math.floor(worm.y / gridSize)));
        grid[row][col]++;
    }
    
    // Find cell with most worms
    let maxWorms = 0;
    let maxRow = 0;
    let maxCol = 0;
    
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            if (grid[row][col] > maxWorms) {
                maxWorms = grid[row][col];
                maxRow = row;
                maxCol = col;
            }
        }
    }
    
    // Return center of that cell
    return {
        x: maxCol * gridSize + gridSize / 2,
        y: maxRow * gridSize + gridSize / 2
    };
}

// Add special effect (like screen darkening for crow arrival)

// ADD THIS FUNCTION HERE:
function addSpecialEffect(effect) {
    specialEffects.push(effect);
}

function drawSpecialEffects(deltaTime) {
    // Update and remove expired effects
    for (let i = specialEffects.length - 1; i >= 0; i--) {
        const effect = specialEffects[i];
        
        // Update effect timer
        if (!effect.timer) effect.timer = 0;
        effect.timer += deltaTime * 0.5; // Half speed
        
        // Remove expired effects
        if (effect.timer >= effect.duration) {
            specialEffects.splice(i, 1);
            continue;
        }
        
        // Calculate effect progress (0 to 1)
        const progress = effect.timer / effect.duration;
        
        // Draw based on effect type
        switch (effect.type) {
            case 'darkening':
                // Darken screen temporarily (like shadow of crows passing over)
                const fadeIn = progress < 0.2 ? progress / 0.2 : 1;
                const fadeOut = progress > 0.7 ? (1 - progress) / 0.3 : 1;
                const alpha = Math.min(fadeIn, fadeOut) * effect.intensity;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                break;
                
            case 'sparkle':
                // Celebration sparkles
                drawSparkleEffect(effect);
                break;
                
            case 'rainbowButterfly':
                // Rainbow butterfly effect
                const opacity = progress < 0.2 ? progress / 0.2 : 
                               (progress > 0.8 ? (1 - progress) / 0.2 : 1);
                
                const wingFlap = progress * Math.PI * 10; // Fast wing flapping
                const wingOpen = Math.abs(Math.sin(wingFlap));
                
                // Draw a simple, glowing butterfly
                ctx.save();
                ctx.globalAlpha = opacity;
                
                // Draw wings
                ctx.fillStyle = effect.color;
                
                // Upper wings
                ctx.beginPath();
                ctx.ellipse(
                    effect.x + 5, 
                    effect.y - effect.size * 0.3, 
                    effect.size * wingOpen, 
                    effect.size * 1.2, 
                    -Math.PI * 0.2, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(
                    effect.x - 5, 
                    effect.y - effect.size * 0.3, 
                    effect.size * wingOpen, 
                    effect.size * 1.2, 
                    Math.PI * 0.2, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Body
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(
                    effect.x, 
                    effect.y, 
                    effect.size * 0.2, 
                    effect.size * 0.7, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.restore();
                break;
                
            // ADD NEW CASES HERE:
            case 'dissolve':
                // Dissolving effect for ant hill
                const dissolveProgress = effect.timer / effect.duration;
                const dissolveFadeOut = 1 - dissolveProgress;
                
                // Shrinking, fading circles
                ctx.fillStyle = `rgba(139, 69, 19, ${dissolveFadeOut * 0.7})`;
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = effect.size * (0.5 + dissolveProgress * 0.5);
                    const size = effect.size * 0.3 * (1 - dissolveProgress);
                    
                    const x = effect.x + Math.cos(angle) * distance;
                    const y = effect.y + Math.sin(angle) * distance;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;

            case 'foodCollection':
                // Food disappearing into hill
                const foodProgress = effect.timer / effect.duration;
                const foodFade = 1 - foodProgress;

                // Shrinking food particle
                ctx.fillStyle = `rgba(210, 180, 140, ${foodFade})`;
                const foodSize = 3 * (1 - foodProgress);

                ctx.beginPath();
                ctx.arc(effect.x, effect.y, foodSize, 0, Math.PI * 2);
                ctx.fill();
                break;

            case 'feeding':
                // Normal feeding effect - small hearts
                const feedProgress = effect.timer / effect.duration;
                const feedOpacity = feedProgress < 0.3 ? feedProgress / 0.3 :
                                   (feedProgress > 0.7 ? (1 - feedProgress) / 0.3 : 1);

                ctx.save();
                ctx.globalAlpha = feedOpacity;
                ctx.fillStyle = '#FF6B9D'; // Pink heart color

                // Draw small heart floating up
                const heartY = effect.y - (feedProgress * 20);
                ctx.font = '14px Arial';
                ctx.fillText('‚ù§', effect.x - 7, heartY);
                ctx.restore();
                break;

            case 'worm-feeding':
                // Worm feeding effect - show worm emoji
                const wormProgress = effect.timer / effect.duration;
                const wormOpacity = wormProgress < 0.3 ? wormProgress / 0.3 :
                                   (wormProgress > 0.7 ? (1 - wormProgress) / 0.3 : 1);

                ctx.save();
                ctx.globalAlpha = wormOpacity;

                // Draw worm emoji floating up with scale animation
                const wormY = effect.y - (wormProgress * 25);
                const wormScale = 1 + Math.sin(wormProgress * Math.PI) * 0.3;
                ctx.font = `${Math.floor(16 * wormScale)}px Arial`;
                ctx.fillText('üêõ', effect.x - 8, wormY);

                // Add sparkle effect around worm
                ctx.fillStyle = `rgba(255, 255, 100, ${wormOpacity * 0.6})`;
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + wormProgress * Math.PI * 4;
                    const sparkX = effect.x + Math.cos(angle) * 12;
                    const sparkY = wormY + Math.sin(angle) * 12;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                break;
        }
    } // <-- This closes the for loop
} // <-- Missing closing brace for the function






// Draw sparkle effects (for scarecrow creation celebration)
function drawSparkleEffect(effect) {
    const progress = effect.timer / effect.duration;
    const opacity = progress < 0.2 ? progress / 0.2 : 
                    (progress > 0.8 ? (1 - progress) / 0.2 : 1);
    
    // Draw a series of sparkles
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    
    for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const radius = 20 + Math.sin(progress * Math.PI * 4 + i) * 10;
        
        const sparkleX = effect.x + Math.cos(angle) * radius;
        const sparkleY = effect.y + Math.sin(angle) * radius;
        const sparkleSize = 2 + Math.sin(progress * Math.PI * 8 + i * 0.7) * 2;
        
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Add some golden sparkles
    ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
    
    for (let i = 0; i < 15; i++) {
        const angle = (i / 15) * Math.PI * 2 + progress * Math.PI;
        const radius = 15 + Math.cos(progress * Math.PI * 3 + i) * 15;
        
        const sparkleX = effect.x + Math.cos(angle) * radius;
        const sparkleY = effect.y + Math.sin(angle) * radius;
        const sparkleSize = 1.5 + Math.cos(progress * Math.PI * 6 + i * 0.5) * 1.5;
        
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Check if conditions are right for a rainbow
function checkForRainbow() {
    // If rain just stopped, wasRaining is true, and we have butterflies, show a rainbow
    if (wasRaining && !isRaining && butterflies.length >= 3 && !rainbowVisible) {
        createRainbow();
        debugLog("Rainbow appears after the rain!");
    }
}

class Owl {
    constructor(x, y) {
        this.id = Math.random().toString(36).substr(2, 9); // Unique ID for naming
        this.x = x || (Math.random() < 0.5 ? -30 : canvas.width + 30);
        this.y = y || (canvas.height * 0.3 + Math.random() * 100);
        this.direction = this.x < canvas.width / 2 ? 1 : -1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.baseSpeed = 1.5; // Faster than birds, slower than crows
        this.state = 'hunting'; // hunting, swooping, perching, leaving
        this.stateTimer = 0;
        this.wingFlap = Math.random() * Math.PI * 2;
        this.target = null;
        this.swoopingY = 0; // For swooping animation
        this.hasKilled = false; // Track if owl killed something this visit
        this.perchTree = null; // Tree to perch in during day
        this.perchPosition = null; // Position in tree
        
        // Owl size and appearance
        this.size = 1.3; // Larger than birds
        this.bodyColor = '#8B4513'; // Brown
        this.wingColor = '#A0522D'; // Darker brown
        this.eyeColor = '#FFA500'; // Orange eyes
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    findTarget() {
        // First priority: Rat Kings (main target!)
        for (const rat of rats) {
            if (rat.isRatKing) {
                this.target = {
                    type: 'ratKing',
                    rat: rat,
                    x: rat.x,
                    y: rat.y
                };
                this.state = 'hunting';
                this.stateTimer = 0;
                debugLog(`Owl targeting rat king at (${rat.x}, ${rat.y})`);
                return true;
            }
        }
        
        // Second priority: Regular rats
        if (rats.length > 0) {
            const randomIndex = Math.floor(Math.random() * rats.length);
            const rat = rats[randomIndex];
            this.target = {
                type: 'rat',
                rat: rat,
                x: rat.x,
                y: rat.y
            };
            this.state = 'hunting';
            this.stateTimer = 0;
            debugLog(`Owl targeting regular rat at (${rat.x}, ${rat.y})`);
            return true;
        }
        
        // Nothing found
        return false;
    }
    
    update(deltaTime) {
        let dx, dy, dist; // Declare once up here
        this.stateTimer += deltaTime;
        this.wingFlap += 0.15 * deltaTime / 16; // Slower wing flap than birds
        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        // Check day/night transition
        const isNight = timeOfDay >= 1;
        
        if (!isNight && this.state !== 'perching' && this.state !== 'leaving') {
            // Daytime - find a tree to perch in or leave
            if (trees.length > 0 && Math.random() < 0.7) {
                this.findPerchTree();
            } else {
                this.state = 'leaving';
                this.stateTimer = 0;
                debugLog("Owl leaving as day breaks");
            }
        }
        
        // State machine
        switch (this.state) {
            case 'hunting':
                // Check if target is still valid
                if (this.target) {
                    if ((this.target.type === 'rat' || this.target.type === 'ratKing') && 
                        rats.indexOf(this.target.rat) === -1) {
                        // Target is gone
                        this.target = null;
                    } else {
                        // Update target position
                        this.target.x = this.target.rat.x;
                        this.target.y = this.target.rat.y;
                    }
                }
                
                // Find new target if needed
                if (!this.target && isNight) {
                    if (!this.findTarget()) {
                        // Nothing to hunt - patrol
                        this.state = 'patrolling';
                        this.stateTimer = 0;
                    }
                }
                
                // Move toward target
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 80) {
                        // Close enough to swoop down
                        this.state = 'swooping';
                        this.stateTimer = 0;
                        this.swoopingY = this.y; // Remember starting height
                    } else {
                        // Move toward target
                        const dir = normalize(dx, dy);
                        this.applyForce({ 
                            x: dir.x * 0.015, 
                            y: dir.y * 0.01 
                        });
                        
                        // Face direction of movement
                        if (Math.abs(dx) > 2) {
                            this.direction = dx > 0 ? 1 : -1;
                        }
                    }
                }
                
                // Add slight gravity
                this.applyForce({ x: 0, y: GRAVITY * 0.5 });
                
                // Check for timeout
                if (this.stateTimer > 15000) {
                    this.state = 'patrolling';
                    this.stateTimer = 0;
                    this.target = null;
                }
                break;
                
            case 'swooping':
                if (!this.target) {
                    this.state = 'patrolling';
                    this.stateTimer = 0;
                    break;
                }
                
                // Update target position
                if ((this.target.type === 'rat' || this.target.type === 'ratKing') && 
                    rats.indexOf(this.target.rat) !== -1) {
                    this.target.x = this.target.rat.x;
                    this.target.y = this.target.rat.y;
                }
                
                // Calculate swoop progress (0 to 1 and back to 0)
                const totalSwoopTime = 1500; // 1.5 seconds for a swoop
                const swoopProgress = this.stateTimer / totalSwoopTime;
                
                if (swoopProgress <= 0.5) {
                    // First half: diving down
                    const diveProgress = swoopProgress * 2; // 0 to 1
                    const targetY = this.target.y;
                    this.y = this.swoopingY + (targetY - this.swoopingY) * diveProgress;
                    
                    // Move toward target horizontally
                    const moveAmount = diveProgress * 1.5; // Accelerating approach
                    this.x = this.x + (this.target.x - this.x) * moveAmount * (deltaTime / 500);
                } else if (swoopProgress <= 1.0) {
                    // Second half: rising back up
                    const riseProgress = (swoopProgress - 0.5) * 2; // 0 to 1
                    this.y = this.target.y + (this.swoopingY - this.target.y) * riseProgress;
                    
                    // At the lowest point, check if we caught the target
                    if (swoopProgress >= 0.49 && swoopProgress <= 0.51 && !this.hasKilled) {
                        this.hasKilled = true;
                        
                        // Check if we're close enough to the target
                        const dist = distance(this.x, this.y, this.target.x, this.target.y);
                        if (dist < 30) {
                            // Caught the target!
                            if (this.target.type === 'rat' || this.target.type === 'ratKing') {
                                const ratIndex = rats.indexOf(this.target.rat);
                                if (ratIndex !== -1) {
                                    rats.splice(ratIndex, 1);
                                    
                                    // Play a sound if enabled
                                    if (windChimeEnabled && audioContext) {
                                        // Play a quick owl hoot
                                        const notes = ['G3', 'C4'];
                                        for (let i = 0; i < notes.length; i++) {
                                            setTimeout(() => {
                                                playNote(notes[i], 0.3);
                                            }, i * 100);
                                        }
                                    }
                                    
                                    // Add a special effect
                                    addSpecialEffect({
                                        type: 'sparkle',
                                        x: this.target.x,
                                        y: this.target.y,
                                        duration: 1000,
                                        intensity: 0.5
                                    });
                                    
                                    debugLog(`Owl caught ${this.target.type === 'ratKing' ? 'rat king' : 'rat'} at (${this.target.x}, ${this.target.y})`);
                                }
                            }
                        }
                    }
                } else {
                    // Swoop complete
                    this.state = this.hasKilled ? 'leaving' : 'hunting';
                    this.stateTimer = 0;
                    this.target = null;
                    this.hasKilled = false;
                }
                break;
                
            case 'patrolling':
                // Fly in large circles, looking for prey
                const patrolTime = this.stateTimer / 5000;
                const centerX = canvas.width / 2;
                const centerY = canvas.height * 0.3;
                const radius = canvas.width * 0.25;

                // Calculate desired position
                const targetX = centerX + Math.cos(patrolTime) * radius;
                const targetY = centerY + Math.sin(patrolTime * 0.5) * 50;

              // Move toward that position
dx = targetX - this.x;         // Just assignment, no const
dy = targetY - this.y;         // Just assignment, no const
const dir = normalize(dx, dy); // Keep const for dir - it's only declared once

                this.applyForce({
                    x: dir.x * 0.01,
                    y: dir.y * 0.01
                });

                // Face direction of movement
                if (Math.abs(dx) > 2) {
                    this.direction = dx > 0 ? 1 : -1;
                }

                // FIX: Occasionally play wing flap sound while patrolling
                if (Math.random() < 0.005 && windChimeEnabled && audioContext) { // 0.5% chance per frame (~1-2 times per patrol)
                    // Play soft wing flap sound (whoosh)
                    try {
                        const now = audioContext.currentTime;
                        const osc = audioContext.createOscillator();
                        osc.type = 'triangle';
                        osc.frequency.value = 100; // Low whoosh

                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 0;

                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 400;

                        osc.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        osc.start(now);
                        gainNode.gain.setValueAtTime(0, now);
                        gainNode.gain.linearRampToValueAtTime(0.04, now + 0.03); // Very quiet
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                        osc.stop(now + 0.2);
                    } catch (e) {
                        // Silent fail for wing flap sound
                    }
                }

                // Occasionally look for a new target
                if (Math.random() < 0.02 && isNight) {
                    this.findTarget();
                }
                
                // Leave after a while of no activity or if day comes
                if (this.stateTimer > 30000 || !isNight) {
                    this.state = 'leaving';
                    this.stateTimer = 0;
                }
                break;
                
            case 'perching':
                if (!this.perchTree || !this.perchPosition || trees.indexOf(this.perchTree) === -1) {
                    // Tree is gone, find another or leave
                    if (trees.length > 0 && isNight) {
                        this.findPerchTree();
                    } else {
                        this.state = 'leaving';
                        this.stateTimer = 0;
                    }
                    break;
                }
                
                // Stay at perch position
                this.x = this.perchPosition.x;
                this.y = this.perchPosition.y;
                
                // No velocity while perched
                this.velocity = { x: 0, y: 0 };
                
                // Leave if night comes - time to hunt!
                if (isNight && this.stateTimer > 5000) {
                    this.state = 'hunting';
                    this.stateTimer = 0;
                    this.perchTree = null;
                    this.perchPosition = null;
                    debugLog("Owl leaves perch to hunt at night");
                }
                
                // Occasionally rotate direction
                if (Math.random() < 0.01) {
                    this.direction *= -1;
                }
                break;
                
            case 'leaving':
                // Pick a random edge to exit
                if (!this.target) {
                    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                    const exitX = edge === 1 ? canvas.width + 50 : (edge === 3 ? -50 : this.x);
                    const exitY = edge === 0 ? -50 : (edge === 2 ? canvas.height + 50 : this.y);
                    
                    this.target = { x: exitX, y: exitY };
                    
                    // Always face exit direction
                    this.direction = this.target.x > this.x ? 1 : -1;
                }
                
                // Move toward exit
                // Move toward exit
dx = this.target.x - this.x;         // Just assignment, no const
dy = this.target.y - this.y;         // Just assignment, no const
dist = Math.sqrt(dx * dx + dy * dy); // Also remove const here since dist is declared at the top
                
                this.applyForce({ 
                    x: dx / dist * 0.02, 
                    y: dy / dist * 0.02 
                });
                
                // Check if off-screen
                if (this.x < -50 || this.x > canvas.width + 50 || 
                    this.y < -50 || this.y > canvas.height + 50) {
                    debugLog("Owl has left the garden");
                    return true; // Remove owl
                }
                break;
        }

        
        
        // Update position with velocity
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.baseSpeed) {
            this.velocity.x = (this.velocity.x / speed) * this.baseSpeed;
            this.velocity.y = (this.velocity.y / speed) * this.baseSpeed;
        }
        
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Apply position constraints
        validatePosition(this);
        
        return false; // Don't remove by default
    }
    
    findPerchTree() {
        if (trees.length === 0) return false;
        
        // Find a tall tree
        const tallTrees = trees.filter(tree => tree.trunkHeight > 120);
        
        if (tallTrees.length > 0) {
            // Pick a random tall tree
            this.perchTree = tallTrees[Math.floor(Math.random() * tallTrees.length)];
            
            // Get a perch position near the top
            this.perchPosition = {
                x: this.perchTree.x,
                y: this.perchTree.y - this.perchTree.trunkHeight * 0.9 * this.perchTree.scale
            };
            
            this.state = 'perching';
            this.stateTimer = 0;
            debugLog(`Owl found perch in tree at (${this.perchTree.x})`);
            return true;
        }
        
        // No suitable trees
        return false;
    }
    
    draw() {
    // Save current context
    ctx.save();
    
    // Translate to owl position
    ctx.translate(this.x, this.y);
    
    // Apply direction
    ctx.scale(this.direction, 1);
    
    // EXTREMELY REDUCED BOBBING: almost eliminated
    const bobAmount = Math.sin(this.wingFlap * 0.05) * 0.5; // Drastically reduced speed and amplitude
    
    // IMPORTANT: Fixed position for fur with NO bobbing
    const staticPosition = 0; // This is used for fur instead of bobAmount
    
    // Body - rounder, more cartoonish
    ctx.fillStyle = '#8B4513'; // Brown body
    ctx.beginPath();
    ctx.ellipse(0, bobAmount, 15, 18, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Belly/chest - cream colored like reference
    ctx.fillStyle = '#F5DEB3'; // Wheat color for belly
    ctx.beginPath();
    ctx.ellipse(0, bobAmount + 2, 10, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw the face (moved up slightly for cuter proportions)
    ctx.fillStyle = '#F5DEB3'; // Cream face
    ctx.beginPath();
    ctx.arc(0, bobAmount - 10, 13, 0, Math.PI * 2);
    ctx.fill();
    
    // Big round eyes with black pupils and white highlights
    // Left eye
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(-5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Right eye
    ctx.beginPath();
    ctx.arc(5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Orange eye rings like in reference
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = '#FFA500'; // Orange
    ctx.beginPath();
    ctx.arc(-5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.stroke();
    
    // Black pupils
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(-5, bobAmount - 10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(5, bobAmount - 10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // White highlights in eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(-6, bobAmount - 11, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(4, bobAmount - 11, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Cute small beak
    ctx.fillStyle = '#FFD700'; // Gold
    ctx.beginPath();
    ctx.moveTo(-2, bobAmount - 8);
    ctx.lineTo(2, bobAmount - 8);
    ctx.lineTo(0, bobAmount - 6);
    ctx.fill();
    
    // Ear tufts (simplified and more stylized)
    ctx.fillStyle = '#8B4513'; // Brown
    
    // Left ear
    ctx.beginPath();
    ctx.moveTo(-10, bobAmount - 18);
    ctx.lineTo(-8, bobAmount - 25);
    ctx.lineTo(-5, bobAmount - 18);
    ctx.fill();
    
    // Right ear
    ctx.beginPath();
    ctx.moveTo(5, bobAmount - 18);
    ctx.lineTo(8, bobAmount - 25);
    ctx.lineTo(10, bobAmount - 18);
    ctx.fill();
    
    // Draw feet when perched
    if (this.state === 'perching') {
        ctx.fillStyle = '#FFD700'; // Gold
        
        // Left foot
        ctx.beginPath();
        ctx.ellipse(-5, bobAmount + 18, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Right foot
        ctx.beginPath();
        ctx.ellipse(5, bobAmount + 18, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (this.state === 'swooping' && this.stateTimer / 1500 > 0.4 && this.stateTimer / 1500 < 0.6) {
        // Talons during swooping
        ctx.fillStyle = '#FFD700'; // Gold
        ctx.lineWidth = 1.5;
        
        // Spread talons
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 4, bobAmount + 15);
            ctx.lineTo(i * 6, bobAmount + 22);
            ctx.stroke();
        }
    }
    
    // STATIC FUR: Using fixed position with no bobbing or movement
    ctx.fillStyle = '#A0522D'; // Darker brown
    
    // Draw many more specks for a fluffy feathered look - WITH FIXED POSITION
    for (let i = 0; i < 40; i++) { // Increased to 40 for fuller appearance
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 9; // Varied distances for fuller appearance
        const speckX = Math.cos(angle) * distance;
        
        // IMPORTANT: Using staticPosition (0) instead of bobAmount for completely static fur
        const speckY = staticPosition + 5 + Math.sin(angle) * 10;
        
        // Vary the size and shape more for a natural fur look
        const speckWidth = 0.5 + Math.random();
        const speckHeight = 1 + Math.random() * 2;
        
        
    }
    
    // Add subtle fuzzy outline for fluffier appearance - WITH FIXED POSITION
    ctx.strokeStyle = 'rgba(160, 82, 45, 0.3)'; // Transparent brown
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 20; i++) { // Increased from 15 to 20 for more fur
        const fuzz_angle = (i / 20) * Math.PI * 2;
        const fuzz_x = Math.cos(fuzz_angle) * 12;
        
        // IMPORTANT: Using staticPosition (0) instead of bobAmount for completely static fur
        const fuzz_y = staticPosition + Math.sin(fuzz_angle) * 16;
        const fuzz_length = 2 + Math.random() * 3;
        
        ctx.beginPath();
        ctx.moveTo(fuzz_x, fuzz_y);
        ctx.lineTo(
            fuzz_x + Math.cos(fuzz_angle) * fuzz_length,
            fuzz_y + Math.sin(fuzz_angle) * fuzz_length
        );
        ctx.stroke();
    }
    
    // Restore context
    ctx.restore();
    
    // Draw debug info if needed
    if (debugVisuals) {
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText(this.state, this.x - 15, this.y - 30);
    }
}

}

// Create the rainbow
function createRainbow() {
    rainbowVisible = true;
    rainbowOpacity = 0;
    rainbowTimer = 0;
    rainbowsShown++; // Increment the counter each time a rainbow is created

     // ADD THIS LINE:
     hadRainbow = true;

     // 1% chance for double rainbow!
     isDoubleRainbow = Math.random() < 0.01;

     // Add diary entry
     if (isDoubleRainbow) {
         addDiaryEntry("A rare double rainbow appears! What does it mean?!", 'special');
         debugLog("DOUBLE RAINBOW created!");
     } else {
         addDiaryEntry("A beautiful rainbow arcs across the sky!", 'special');
     }
    
    // Play a magical sound if wind chimes are enabled
    if (windChimeEnabled && audioContext) {
        // Play an ascending scale for rainbow appearance
        const notes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
        for (let i = 0; i < notes.length; i++) {
            setTimeout(() => {
                playNote(notes[i], 1.5);
            }, i * 200);
        }
    }
    
    // Make butterflies dance more energetically
    for (const butterfly of butterflies) {
        butterfly.dancingAmplitude *= 1.5;
        butterfly.dancingFrequency *= 1.2;
    }
}

// Update the rainbow
function updateRainbow(deltaTime) {
    if (!rainbowVisible) return;
    
    rainbowTimer += deltaTime;
    
    // Fade in over 5 seconds
    if (rainbowTimer < 5000) {
        rainbowOpacity = Math.min(1, rainbowTimer / 5000);
    } 
    // Stay visible for most of duration
    else if (rainbowTimer < rainbowDuration - 10000) {
        rainbowOpacity = 1;
    } 
    // Fade out over last 10 seconds
    else if (rainbowTimer < rainbowDuration) {
        rainbowOpacity = Math.max(0, 1 - (rainbowTimer - (rainbowDuration - 10000)) / 10000);
    } 
    // End rainbow
    else {
        rainbowVisible = false;
        isDoubleRainbow = false; // Reset for next rainbow
        
        // Return butterflies to normal behavior
        for (const butterfly of butterflies) {
            butterfly.dancingAmplitude /= 1.5;
            butterfly.dancingFrequency /= 1.2;
        }
    }
}

// Draw the rainbow
function drawRainbow() {
    if (!rainbowVisible || rainbowOpacity <= 0) return;
    
    const canvasCenter = canvas.width / 2;
    const groundY = canvas.height * GROUND_HEIGHT_RATIO;
    const rainbowHeight = canvas.height * 1.2; // Increased from 0.8 (50% taller)
    const rainbowWidth = canvas.width * 0.95; // Increased from 0.8 (wider)
    
    // Create a smooth pulsing effect
    const pulseAmount = Math.sin(rainbowTimer / 1000) * 0.05 + 0.95;
    
    // Rainbow colors with transparency
    const rainbowColors = [
        `rgba(255, 0, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,    // Red
        `rgba(255, 127, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,  // Orange
        `rgba(255, 255, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,  // Yellow
        `rgba(0, 255, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,    // Green
        `rgba(0, 0, 255, ${rainbowOpacity * 0.7 * pulseAmount})`,    // Blue
        `rgba(75, 0, 130, ${rainbowOpacity * 0.7 * pulseAmount})`,   // Indigo
        `rgba(148, 0, 211, ${rainbowOpacity * 0.7 * pulseAmount})`   // Violet
    ];
    
    // Draw the rainbow as a series of colored arcs
    const arcWidth = 10; // Width of each color band
    const startY = groundY - rainbowHeight * 0.5;
    
    // Save context for transformation
    ctx.save();
    ctx.globalCompositeOperation = 'lighter'; // Makes colors blend nicely
    
    // Draw each color band
    for (let i = 0; i < rainbowColors.length; i++) {
        const radius = rainbowWidth / 2 - i * arcWidth;

        ctx.beginPath();
        ctx.strokeStyle = rainbowColors[i];
        ctx.lineWidth = arcWidth - 1; // Slight gap between colors

        // Draw arc centered on screen
        ctx.arc(
            canvasCenter,
            startY + rainbowHeight,
            radius,
            Math.PI,
            Math.PI * 2
        );

        ctx.stroke();
    }

    // Draw second rainbow if this is a double rainbow
    if (isDoubleRainbow) {
        const secondRainbowOffset = 100; // Distance above first rainbow
        const secondRainbowOpacity = rainbowOpacity * 0.5; // Fainter than first

        // Reverse the colors for the second rainbow (real double rainbows have reversed order)
        const reversedColors = [
            `rgba(148, 0, 211, ${secondRainbowOpacity * 0.7 * pulseAmount})`,   // Violet
            `rgba(75, 0, 130, ${secondRainbowOpacity * 0.7 * pulseAmount})`,    // Indigo
            `rgba(0, 0, 255, ${secondRainbowOpacity * 0.7 * pulseAmount})`,     // Blue
            `rgba(0, 255, 0, ${secondRainbowOpacity * 0.7 * pulseAmount})`,     // Green
            `rgba(255, 255, 0, ${secondRainbowOpacity * 0.7 * pulseAmount})`,   // Yellow
            `rgba(255, 127, 0, ${secondRainbowOpacity * 0.7 * pulseAmount})`,   // Orange
            `rgba(255, 0, 0, ${secondRainbowOpacity * 0.7 * pulseAmount})`      // Red
        ];

        for (let i = 0; i < reversedColors.length; i++) {
            const radius = (rainbowWidth / 2 + secondRainbowOffset) - i * arcWidth;

            ctx.beginPath();
            ctx.strokeStyle = reversedColors[i];
            ctx.lineWidth = arcWidth - 1;

            ctx.arc(
                canvasCenter,
                startY + rainbowHeight,
                radius,
                Math.PI,
                Math.PI * 2
            );

            ctx.stroke();
        }
    }
    
    if (rainbowOpacity > 0.5 && Math.random() < 0.05) { // Reduced from 0.3 to 0.05 - much slower shimmer
    const shimmerCount = 2 + Math.floor(Math.random() * 2); // Reduced count from 3+3 to 2+2
    
    for (let i = 0; i < shimmerCount; i++) {
        const shimmerX = canvasCenter - rainbowWidth / 2 + Math.random() * rainbowWidth;
        const shimmerY = groundY - Math.random() * 10;



            const shimmerSize = 2 + Math.random() * 4;
            
            const shimmerGradient = ctx.createRadialGradient(
                shimmerX, shimmerY, 0,
                shimmerX, shimmerY, shimmerSize
            );
            
            shimmerGradient.addColorStop(0, `rgba(255, 255, 255, ${rainbowOpacity})`);
            shimmerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = shimmerGradient;
            ctx.beginPath();
            ctx.arc(shimmerX, shimmerY, shimmerSize, 0, Math.PI * 2);
            ctx.fill();
        } // End of shimmer for loop
    } // End of rainbowOpacity > 0.5 condition
    
    // Create occasional butterflies that briefly follow the rainbow arc
    if (rainbowOpacity > 0.7 && Math.random() < 0.01) {
        const butterflyX = canvasCenter - rainbowWidth / 2 + Math.random() * rainbowWidth;
        const arcPosition = (butterflyX - (canvasCenter - rainbowWidth / 2)) / rainbowWidth;
        const arcHeight = Math.sin(arcPosition * Math.PI) * rainbowHeight;
        const butterflyY = groundY - arcHeight;
        
        // Create a special effect rather than an actual butterfly
        specialEffects.push({
            type: 'rainbowButterfly',
            x: butterflyX,
            y: butterflyY,
            size: 5 + Math.random() * 5,
            color: rainbowColors[Math.floor(Math.random() * rainbowColors.length)],
            duration: 3000,
            timer: 0
        });
    }
    
    // Reset composite operation and restore context
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
} // End of drawRainbow function







// Check if we should create a scarecrow (with new requirements)
function checkForScarecrow() {
    // Count completed birdhouses
    const completedBirdhouses = birdhouses.filter(bh => bh.isComplete).length;
    
    // New requirements: 1 birdhouse, seen 1 rainbow, and 10 flowers
    if (completedBirdhouses >= 1 && rainbowsShown >= 1 && flowers.length >= 10 && !scarecrowCreated) {
        createScarecrow();
    }
}

// Create the scarecrow
function createScarecrow() {
    // Find position between two birdhouses
    const completedBirdhouses = birdhouses.filter(bh => bh.isComplete);
    
    // Need at least 2 birdhouses
    if (completedBirdhouses.length < 2) return;
    
    // Choose two random birdhouses
    const bh1 = completedBirdhouses[0];
    const bh2 = completedBirdhouses[1];
    
    // Position between them
    const scarecrowX = (bh1.x + bh2.x) / 2;
    const scarecrowY = canvas.height * GROUND_HEIGHT_RATIO; // On ground
    
    // Create scarecrow object
    scarecrow = {
        x: scarecrowX,
        y: scarecrowY,
        armWave: 0,
        hatWobble: 0,
        headTilt: 0,
        // Random gender - determines appearance
        isFemale: Math.random() < 0.5
    };
    
    // Mark as created
    scarecrowCreated = true;
    
    // Make any existing crows leave immediately
    makeCrowsLeave();
    
    // Show celebration effect
    addSpecialEffect({
        type: 'sparkle',
        x: scarecrowX,
        y: scarecrowY - 50,
        duration: 3000,
        intensity: 1.0
    });
    
    debugLog(`Scarecrow ${scarecrow.isFemale ? 'woman' : 'man'} created to protect the garden!`);
    
    // Play a celebratory sound if wind chimes are enabled
    if (windChimeEnabled && audioContext) {
        // Play a fanfare
        const notes = ['C4', 'E4', 'G4', 'C5'];
        for (let i = 0; i < notes.length; i++) {
            setTimeout(() => {
                playNote(notes[i], 1);
            }, i * 150);
        }
    }
}

// Update the scarecrow animations
function updateScarecrow(deltaTime) {
    if (!scarecrow) return;
    
    // Update animation values
    scarecrow.armWave += 0.01 * deltaTime;
    scarecrow.hatWobble += 0.005 * deltaTime;
    scarecrow.headTilt = Math.sin(scarecrow.armWave * 0.3) * 0.1;

    if (mushroomMode) {
        scarecrow.armWave += 0.005 * deltaTime; // Slower, more psychedelic movement
        scarecrow.hatWobble += 0.01 * deltaTime; // More subtle wobble
    }
    
    // The scarecrow prevents crows from visiting
    // Make sure no new crow visits happen
    if (crowVisitInProgress) {
        // Immediately send crows away if they appear
        makeCrowsLeave();
        crowVisitInProgress = false;
        crowVisitTimer = 0;
    }
}

function drawMushroomScarecrow() {
    if (!scarecrow) return;
    
    ctx.save();
    
    // Rainbow color cycling for psychedelic effect
    const primaryColor = `hsl(${(colorCycleTimer / 50) % 360}, 100%, 70%)`;
    const secondaryColor = `hsl(${((colorCycleTimer / 50) + 120) % 360}, 100%, 70%)`;
    
    // Animation properties
    const wingFlap = Math.sin(scarecrow.armWave * 0.05) * 0.3; // Smooth wing flapping
    const bodyBob = Math.sin(scarecrow.hatWobble * 0.07) * 5; // Gentle bobbing motion
    
    // BIRD BODY - large oval
    ctx.fillStyle = primaryColor;
    ctx.beginPath();
    ctx.ellipse(
        scarecrow.x, 
        scarecrow.y - 120 + bodyBob, 
        80, 
        120, 
        Math.sin(colorCycleTimer / 2000) * 0.001, // Slight body wobble
        0, Math.PI * 2
    );
    ctx.fill();
    
    // RAINBOW FEATHER PATTERNS - replace mushroom spots
    const featherColors = [
        `hsl(${(colorCycleTimer / 50) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 60) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 120) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 180) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 240) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 300) % 360}, 100%, 70%)`
    ];
    
    // Feather patterns on body
    for (let i = 0; i < 50; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const radius = 70 + Math.sin(colorCycleTimer / 800 + i) * 10;
        const featherColor = featherColors[i % featherColors.length];
        
        ctx.fillStyle = featherColor;
        ctx.beginPath();
        
        // Feather shape - elongated oval
        const featherX = scarecrow.x + Math.cos(angle) * radius;
        const featherY = scarecrow.y - 120 + bodyBob + Math.sin(angle) * radius * 0.5;
        const featherSize = 15 + Math.sin(colorCycleTimer / 600 + i) * 5;
        
        ctx.ellipse(
            featherX,
            featherY,
            featherSize,
            featherSize * 2,
            angle,
            0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // BIRD FACE
    // Face/head area - slightly lighter
    ctx.fillStyle = secondaryColor;
    ctx.beginPath();
    ctx.arc(
        scarecrow.x, 
        scarecrow.y - 170 + bodyBob, 
        50, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Large bird eyes
    ctx.fillStyle = 'white';
    const eyeSize = 18;
    const eyeSpacing = 20;
    
    // Left eye
    ctx.beginPath();
    ctx.arc(
        scarecrow.x - eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Right eye
    ctx.beginPath();
    ctx.arc(
        scarecrow.x + eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Pupils - large and black
    ctx.fillStyle = 'black';
    
    // Left pupil
    ctx.beginPath();
    ctx.arc(
        scarecrow.x - eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize * 0.6, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Right pupil
    ctx.beginPath();
    ctx.arc(
        scarecrow.x + eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize * 0.6, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Eye highlights
    ctx.fillStyle = 'white';
    
    // Left eye highlight
    ctx.beginPath();
    ctx.arc(
        scarecrow.x - eyeSpacing + 5, 
        scarecrow.y - 178 + bodyBob, 
        5, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Right eye highlight
    ctx.beginPath();
    ctx.arc(
        scarecrow.x + eyeSpacing + 5, 
        scarecrow.y - 178 + bodyBob, 
        5, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Rainbow beak
    const beakColor = `hsl(${((colorCycleTimer / 100) + 30) % 360}, 100%, 60%)`;
    ctx.fillStyle = beakColor;
    ctx.beginPath();
    ctx.moveTo(scarecrow.x - 15, scarecrow.y - 155 + bodyBob);
    ctx.lineTo(scarecrow.x, scarecrow.y - 135 + bodyBob);
    ctx.lineTo(scarecrow.x + 15, scarecrow.y - 155 + bodyBob);
    ctx.closePath();
    ctx.fill();
    
    const baseAngle = -Math.PI/2.5; // Base angle for both wings
drawRainbowWing(scarecrow.x - 50, scarecrow.y + 13 + bodyBob, baseAngle - wingFlap, false);
drawRainbowWing(scarecrow.x + 30, scarecrow.y + 13 + bodyBob, baseAngle + wingFlap, true);

    
    // FEET - bird feet at the bottom
    ctx.fillStyle = beakColor;
    
    // Left foot
    ctx.beginPath();
    ctx.ellipse(
        scarecrow.x - 30,
        scarecrow.y - 10,
        20,
        10,
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Left toes
    for (let i = 0; i < 3; i++) {
        const angle = -Math.PI/4 + (i * Math.PI/8);
        const length = 15;
        
        ctx.beginPath();
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.strokeStyle = beakColor;
        ctx.moveTo(scarecrow.x - 40, scarecrow.y - 10);
        ctx.lineTo(
            scarecrow.x - 40 + Math.cos(angle) * length,
            scarecrow.y - 10 + Math.sin(angle) * length
        );
        ctx.stroke();
    }
    
    // Right foot
    ctx.beginPath();
    ctx.ellipse(
        scarecrow.x + 30,
        scarecrow.y - 10,
        20,
        10,
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Right toes
    for (let i = 0; i < 3; i++) {
        const angle = -Math.PI + Math.PI/4 - (i * Math.PI/8);
        const length = 15;
        
        ctx.beginPath();
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.strokeStyle = beakColor;
        ctx.moveTo(scarecrow.x + 40, scarecrow.y - 10);
        ctx.lineTo(
            scarecrow.x + 40 + Math.cos(angle) * length,
            scarecrow.y - 10 + Math.sin(angle) * length
        );
        ctx.stroke();
    }
    
    // RAINBOW TAIL FEATHERS
    for (let i = 0; i < 7; i++) {
        const tailColor = featherColors[i % featherColors.length];
        const angle = Math.PI/2 - Math.PI/6 + (i * Math.PI/18);
        const tailLength = 100 + (i % 2) * 20;
        
        ctx.fillStyle = tailColor;
        ctx.beginPath();
        ctx.ellipse(
            scarecrow.x + Math.cos(angle) * tailLength * 0.5,
            scarecrow.y + 10 + Math.sin(angle) * tailLength * 0.5,
            15,
            tailLength,
            angle + Math.PI/2,
            0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // RAINBOW AURA/GLOW
    const gradient = ctx.createRadialGradient(
        scarecrow.x, scarecrow.y - 100 + bodyBob, 10,
        scarecrow.x, scarecrow.y - 100 + bodyBob, 200
    );
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
    gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0)');
    gradient.addColorStop(1, `hsla(${(colorCycleTimer / 100) % 360}, 100%, 70%, 0.1)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(scarecrow.x, scarecrow.y - 100 + bodyBob, 200, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    // Helper function to draw improved rainbow wings
    function drawRainbowWing(x, y, angle, isRight) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        // IMPROVED: Larger wings with more dramatic shape
        const wingLength = 150; // Increased from 120
        const wingWidth = 90;   // Increased from 50
        
        // IMPROVED: Add a glowing outline around the entire wing
        // Create a base glow effect
        const glowColor = `hsla(${(colorCycleTimer / 100) % 360}, 100%, 70%, 0.4)`;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 15;
        
        // IMPROVED: Create a more feathered wing shape using multiple overlapping shapes
        // Draw main wing shape first as base
        ctx.fillStyle = `hsla(${(colorCycleTimer / 80) % 360}, 100%, 65%, 0.9)`;
        ctx.beginPath();
        ctx.moveTo(0, 0); // Wing base connects to body
        
        // Create a more elegant curve for the wing
        ctx.bezierCurveTo(
            wingLength * 0.3, -wingWidth * 0.5,
            wingLength * 0.7, -wingWidth * 0.7,
            wingLength, -wingWidth * 0.3
        );
        ctx.bezierCurveTo(
            wingLength * 0.8, wingWidth * 0.2,
            wingLength * 0.6, wingWidth * 0.5,
            0, 0
        );
        ctx.fill();
        
        // IMPROVED: Add rainbow-colored feather layers that overlap
        for (let i = 0; i < 7; i++) { // Added one more layer
            // Cycle through rainbow colors with offset based on position
            const hue = ((colorCycleTimer / 50) + i * 30) % 360;
            ctx.fillStyle = `hsla(${hue}, 100%, 65%, 0.8)`;
            
            // Each feather layer is positioned along the wing
            const layerPosition = (i / 7) * wingLength * 0.9;
            const featherLength = wingLength * 0.6 - (i * 5);
            const featherWidth = wingWidth * 0.4 - (i * 3);
            
            // Draw feather with a curved tip
            ctx.beginPath();
            ctx.ellipse(
                layerPosition, 
                -featherWidth,        // Position feathers along curved path
                featherWidth,         // Width of feather
                featherLength,        // Length of feather
                -Math.PI/8,           // Angle for feather direction
                0, Math.PI * 2
            );
            ctx.fill();
            
            // Add a second row of feathers for fullness
            ctx.beginPath();
            ctx.ellipse(
                layerPosition + 10,
                featherWidth * 0.5,
                featherWidth * 0.8,
                featherLength * 0.7,
                Math.PI/6,
                0, Math.PI * 2
            );
            ctx.fill();
        }
        
        // IMPROVED: Add white highlight along leading edge of wing
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(
            wingLength * 0.3, -wingWidth * 0.5,
            wingLength * 0.7, -wingWidth * 0.7,
            wingLength, -wingWidth * 0.3
        );
        ctx.stroke();
        
        // IMPROVED: More dramatic, pulsing sparkles
        const sparkleCount = 5; // Increased from 8
        for (let i = 0; i < sparkleCount; i++) {
            // Distribute sparkles more evenly across wing
            const sparkleX = (i / sparkleCount) * wingLength;
            const sparkleY = Math.sin(i / 2) * wingWidth * 0.6;
            
            // Pulsing size based on time
            const pulse = Math.sin((colorCycleTimer / 300) + i) * 0.5 + 1;
            const sparkleSize = (3 + Math.random() * 4) * pulse;
            
            // Changing colors for sparkles
            const sparkleHue = (colorCycleTimer / 30 + i * 20) % 360;
            ctx.fillStyle = `hsla(${sparkleHue}, 100%, 80%, 0.9)`;
            
            // Draw star-shaped sparkles
            drawStar(sparkleX, sparkleY, 5, sparkleSize, sparkleSize/2);
        }
        
        // Reset shadow effects
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        ctx.restore();
    }
    
    // Helper function to draw star-shaped sparkles
    function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fill();
    }
}


// Draw the scarecrow
function drawScarecrow() {
    if (!scarecrow) return;

    // Don't draw if beamed up by UFO
    if (scarecrow.beamedUp) return;

    // Draw glow effect if glowing (returned by UFO)
    if (scarecrow.glowing) {
        if (!scarecrow.glowPhase) scarecrow.glowPhase = 0;
        scarecrow.glowPhase += 0.02;
        const glowIntensity = (Math.sin(scarecrow.glowPhase) + 1) / 2;

        ctx.save();
        const glowGradient = ctx.createRadialGradient(
            scarecrow.x, scarecrow.y - 60, 0,
            scarecrow.x, scarecrow.y - 60, 80
        );
        glowGradient.addColorStop(0, `rgba(100, 255, 100, ${0.4 * glowIntensity})`);
        glowGradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(scarecrow.x, scarecrow.y - 60, 80, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    const armWave = Math.sin(scarecrow.armWave);
    const hatWobble = Math.sin(scarecrow.hatWobble) * 0.1;
    
    // Calculate scarecrow measurements
    const headRadius = 15;
    const bodyHeight = 60;
    const armLength = 40;
    const legLength = 40;
    
    // Save context for transformations
    ctx.save();
    
    // Draw the supporting pole
    ctx.fillStyle = '#8B4513'; // Brown
    ctx.fillRect(scarecrow.x - 4, scarecrow.y - bodyHeight - headRadius * 2 - 10, 8, bodyHeight + headRadius * 2 + 10);
    
    // Position scarecrow on the pole
    const scarecrowCenterY = scarecrow.y - bodyHeight - headRadius;
    
    // Draw body (different shapes for male/female)
    if (scarecrow.isFemale) {
        // Female - dress shape
        ctx.fillStyle = '#E74C3C'; // Red dress
        
        // Dress (trapezoid shape)
        ctx.beginPath();
        ctx.moveTo(scarecrow.x - 15, scarecrowCenterY);
        ctx.lineTo(scarecrow.x + 15, scarecrowCenterY);
        ctx.lineTo(scarecrow.x + 25, scarecrowCenterY + bodyHeight);
        ctx.lineTo(scarecrow.x - 25, scarecrowCenterY + bodyHeight);
        ctx.closePath();
        ctx.fill();
        
        // Belt/waist
        ctx.fillStyle = '#2C3E50'; // Dark belt
        ctx.fillRect(scarecrow.x - 17, scarecrowCenterY + 10, 34, 5);
    } else {
        // Male - shirt and pants
        
        // Shirt
        ctx.fillStyle = '#3498DB'; // Blue shirt
        ctx.fillRect(scarecrow.x - 20, scarecrowCenterY, 40, bodyHeight / 2);
        
        // Pants
        ctx.fillStyle = '#2C3E50'; // Dark pants
        ctx.fillRect(scarecrow.x - 18, scarecrowCenterY + bodyHeight / 2, 36, bodyHeight / 2);
        
        // Add buttons
        ctx.fillStyle = '#ECF0F1';
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(
                scarecrow.x, 
                scarecrowCenterY + 5 + i * 10, 
                2, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }
    
    // Draw head
    ctx.save();
    ctx.translate(scarecrow.x, scarecrowCenterY - headRadius);
    ctx.rotate(scarecrow.headTilt); // Head tilt animation
    
    // Draw face - burlap texture
    ctx.fillStyle = '#D4B483'; // Burlap color
    ctx.beginPath();
    ctx.arc(0, 0, headRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes - different styles based on gender
    if (scarecrow.isFemale) {
        // Female - eyelashes
        ctx.fillStyle = 'black';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(-5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyelashes
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const angle = (Math.PI / 2) + (i - 1) * (Math.PI / 8);
            ctx.moveTo(-5 + Math.cos(angle) * 3, -2 + Math.sin(angle) * 3);
            ctx.lineTo(-5 + Math.cos(angle) * 6, -2 + Math.sin(angle) * 6);
        }
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyelashes
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const angle = (Math.PI / 2) + (i - 1) * (Math.PI / 8);
            ctx.moveTo(5 + Math.cos(angle) * 3, -2 + Math.sin(angle) * 3);
            ctx.lineTo(5 + Math.cos(angle) * 6, -2 + Math.sin(angle) * 6);
        }
        ctx.stroke();
        
        // Pink rosy cheeks
        ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
        ctx.beginPath();
        ctx.arc(-8, 3, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(8, 3, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Smile with lipstick
        ctx.strokeStyle = '#C0392B';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 2, 6, 0.2, Math.PI - 0.2);
        ctx.stroke();
    } else {
        // Male - button eyes
        ctx.fillStyle = 'black';
        
        // Left eye - button with cross stitch
        ctx.beginPath();
        ctx.arc(-5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#D4B483';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-7, -4);
        ctx.lineTo(-3, 0);
        ctx.moveTo(-7, 0);
        ctx.lineTo(-3, -4);
        ctx.stroke();
        
        // Right eye - button with cross stitch
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#D4B483';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3, -4);
        ctx.lineTo(7, 0);
        ctx.moveTo(3, 0);
        ctx.lineTo(7, -4);
        ctx.stroke();
        
        // Simple smile
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 3, 5, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }
    
    // Draw Hat - different hats based on gender
    if (scarecrow.isFemale) {
        // Straw sunhat for female
        ctx.fillStyle = '#F5DEB3'; // Wheat color
        
        // Wide brim
        ctx.beginPath();
        ctx.ellipse(0, -headRadius - 3, 30, 10, hatWobble, 0, Math.PI * 2);
        ctx.fill();
        
        // Hat crown
        ctx.fillStyle = '#F0E68C'; // Khaki
        ctx.beginPath();
        ctx.ellipse(0, -headRadius - 8, 12, 8, hatWobble, 0, Math.PI * 2);
        ctx.fill();
        
        // Hat band
        ctx.fillStyle = '#E74C3C'; // Red
        ctx.beginPath();
        ctx.ellipse(0, -headRadius - 6, 12.5, 2, hatWobble, 0, Math.PI * 2);
        ctx.fill();
        
        // Flower on hat
        const flowerX = 15 * Math.cos(hatWobble);
        const flowerY = -headRadius - 4 + 5 * Math.sin(hatWobble);
        
        // Flower petals
        ctx.fillStyle = '#F1C40F'; // Yellow
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            ctx.beginPath();
            ctx.ellipse(
                flowerX + Math.cos(angle) * 4,
                flowerY + Math.sin(angle) * 4,
                3, 3, 0, 0, Math.PI * 2
            );
            ctx.fill();
        }
        
        // Flower center
        ctx.fillStyle = '#E67E22'; // Orange
        ctx.beginPath();
        ctx.arc(flowerX, flowerY, 2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Farmer hat for male
        ctx.fillStyle = '#8B4513'; // Brown
        
        // Hat body
        ctx.save();
        ctx.rotate(hatWobble);
        ctx.fillRect(-15, -headRadius - 15, 30, 10);
        
        // Hat top
        ctx.fillRect(-10, -headRadius - 25, 20, 10);
        ctx.restore();
    }
    
    // Restore head context
    ctx.restore();
    
    // Draw arms
    const shoulderY = scarecrowCenterY + 5;
    
    // Left arm
    ctx.save();
    ctx.translate(scarecrow.x - 20, shoulderY);
    ctx.rotate(Math.PI * 0.2 + armWave * 0.3); // Waving motion
    
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#3498DB'; // Match body color
    ctx.fillRect(-5, 0, 10, armLength);
    
    // Left hand
    ctx.fillStyle = '#D4B483'; // Burlap/straw color
    ctx.beginPath();
    ctx.arc(-2, armLength + 5, 7, 0, Math.PI * 2);
    ctx.fill();
    
    // Straw bits sticking out
    ctx.strokeStyle = '#F5DEB3';
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(-2, armLength + 5);
        ctx.lineTo(
            -2 + Math.cos(angle) * 10,
            armLength + 5 + Math.sin(angle) * 10
        );
        ctx.stroke();
    }
    ctx.restore();
    
    // Right arm
    ctx.save();
    ctx.translate(scarecrow.x + 20, shoulderY);
    ctx.rotate(Math.PI * 0.8 - armWave * 0.3); // Opposite wave
    
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#3498DB'; // Match body color
    ctx.fillRect(-5, 0, 10, armLength);
    
    // Right hand
    ctx.fillStyle = '#D4B483'; // Burlap/straw color
    ctx.beginPath();
    ctx.arc(2, armLength + 5, 7, 0, Math.PI * 2);
    ctx.fill();
    
    // Straw bits sticking out
    ctx.strokeStyle = '#F5DEB3';
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(2, armLength + 5);
        ctx.lineTo(
            2 + Math.cos(angle) * 10,
            armLength + 5 + Math.sin(angle) * 10
        );
        ctx.stroke();
    }
    ctx.restore();
    
    // Draw legs
    const hipY = scarecrowCenterY + bodyHeight;
    
    // Left leg
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#2C3E50'; // Match outfit
    ctx.fillRect(scarecrow.x - 15, hipY, 10, legLength);
    
    // Left foot/boot
    ctx.fillStyle = '#8B4513'; // Brown boot
    ctx.fillRect(scarecrow.x - 18, hipY + legLength, 16, 5);
    
    // Right leg
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#2C3E50'; // Match outfit
    ctx.fillRect(scarecrow.x + 5, hipY, 10, legLength);
    
    // Right foot/boot
    ctx.fillStyle = '#8B4513'; // Brown boot
    ctx.fillRect(scarecrow.x + 2, hipY + legLength, 16, 5);
    
    // Restore context
    ctx.restore();
    
    // For debugging - show protection radius
    if (debugVisuals) {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(scarecrow.x, scarecrow.y, 500, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText('Crow Protection Zone', scarecrow.x - 70, scarecrow.y - 100);
    }
}


// Check for conditions to create an ant hill
function checkForAntHill() {
    // Don't create during rain
    if (isRaining) return;
    
    // Don't create if one already exists
    if (antHill) return;
    
    // Only check periodically
    if (Math.random() > 0.01) return;
    
    // Requirements: daytime, food on ground, some flowers
    const isDaytime = timeOfDay < 1;
    const hasFoodOnGround = foodItems.length >= 4;
    const hasFlowers = flowers.length >= 5;
    
    if (isDaytime && hasFoodOnGround && hasFlowers && dayNightCycleCount >= 2) {
        // Find a good location near food
        const location = findFoodConcentration();
        if (location) {
            createAntHill(location);
        }
   // ADD THIS LINE:
   hadAnts = true;

    }
}

// Find where food is concentrated
function findFoodConcentration() {
    if (foodItems.length < 4) return null;
    
    // Grid-based approach to find food clusters
    const gridSize = 80;
    const grid = {};
    
    // Count food items in each grid cell
    for (const food of foodItems) {
        const gridX = Math.floor(food.x / gridSize);
        const gridY = Math.floor(food.y / gridSize);
        const key = `${gridX},${gridY}`;
        
        grid[key] = (grid[key] || 0) + 1;
    }
    
    // Find grid cell with most food
    let bestCell = null;
    let maxCount = 2; // Need at least 3 items to be considered a concentration
    
    for (const key in grid) {
        if (grid[key] > maxCount) {
            maxCount = grid[key];
            bestCell = key;
        }
    }
    
    if (bestCell) {
        const [gridX, gridY] = bestCell.split(',').map(Number);
        return {
            x: (gridX + 0.5) * gridSize,
            y: canvas.height * GROUND_HEIGHT_RATIO
        };
    }
    
    return null;
}

// Create a new ant hill
function createAntHill(location) {
    antHill = {
        x: location.x,
        y: location.y,
        size: 15, // Hill size
        foodCollected: 0,
        createdAt: simulationTime,
        lastAntSpawnTime: 0,
        entranceY: location.y - 3 // Slightly above ground level
    };
    
    // Spawn initial ants
    for (let i = 0; i < 5; i++) {
        spawnAnt();
    }
    
    debugLog(`Ant hill created at (${location.x}, ${location.y})`);
}

// Spawn a new ant
function spawnAnt() {
    if (!antHill) return;
    if (ants.length >= MAX_ANTS) return;
    
    // Cooldown on ant spawning (every 5-10 seconds)
    const now = simulationTime;
    if (now - antHill.lastAntSpawnTime < 5000 + Math.random() * 5000) return;
    
    antHill.lastAntSpawnTime = now;
    
    // Create ant with randomized position around hill
    const angle = Math.random() * Math.PI * 2;
    const distance = antHill.size * 0.8;
    
    ants.push({
        id: Math.random().toString(36).substr(2, 9), // Unique ID for naming
        x: antHill.x + Math.cos(angle) * distance,
        y: antHill.y + Math.sin(angle) * distance,
        angle: Math.random() * Math.PI * 2, // Random direction
        speed: ANT_SPEED,
        state: 'exploring', // exploring, returningWithFood
        carryingFood: null, // Reference to food being carried
        wanderTimer: 0,
        wiggle: Math.random() * Math.PI * 2, // For animation
        bounce: 0, // For cute bouncy movement
        targetX: null,
        targetY: null,
        foodX: 0, // Food position relative to ant
        foodY: -2 // Food held above ant
    });
}

// Update ant hill and ants
function updateAnts(deltaTime) {
    // Check if ant hill should disappear due to rain
    if (isRaining && antHill) {
        debugLog("Rain is dissolving the ant hill...");
        removeAntHill();
        return;
    }
    
    // Possibly create a new ant hill if conditions are right
    if (!antHill) {
        checkForAntHill();
    }
    
    // No ant hill, nothing to update
    if (!antHill) return;
    
    // Spawn new ants periodically
    if (Math.random() < 0.01 && ants.length < MAX_ANTS) {
        spawnAnt();
    }
    
    // Update each ant
    for (let i = ants.length - 1; i >= 0; i--) {
        const ant = ants[i];
        
        // Update animation timers
        ant.wiggle += 0.1 * deltaTime / 16;
        ant.bounce += 0.15 * deltaTime / 16;
        
        // Update behavior based on state
        switch (ant.state) {
            case 'exploring':
                updateExploringAnt(ant, deltaTime);
                break;
                
            case 'returningWithFood':
                updateReturningAnt(ant, deltaTime);
                break;
        }
        
        // Make sure ants stay on the ground
        ant.y = Math.min(ant.y, canvas.height * GROUND_HEIGHT_RATIO + 3);
        ant.y = Math.max(ant.y, canvas.height * GROUND_HEIGHT_RATIO - 3);
        
        // Enforce maximum distance from hill
        const distToHill = distance(ant.x, ant.y, antHill.x, antHill.y);
        if (distToHill > MAX_ANT_DISTANCE) {
            // Too far - head back to hill
            ant.state = 'returningWithFood';
            ant.carryingFood = null; // Drop food if too far
        }
    }
}

function updateExploringAnt(ant, deltaTime) {
    // Update wander timer
    ant.wanderTimer += deltaTime;
    
    // Check for nearby food
    if (!ant.carryingFood) {
        const nearbyFood = findNearbyFood(ant);
        if (nearbyFood) {
            // Found food - pick it up
            ant.carryingFood = nearbyFood;
            ant.state = 'returningWithFood';
            ant.speed = FOOD_CARRY_SPEED; // Slower when carrying
            
            // Remove food from the garden
            const foodIndex = foodItems.indexOf(nearbyFood);
            if (foodIndex !== -1) {
                foodItems.splice(foodIndex, 1);
            }
            return;
        }
    }
    
    // Change direction randomly
    if (ant.wanderTimer > 1000 + Math.random() * 2000) {
        ant.wanderTimer = 0;
        ant.angle += (Math.random() - 0.5) * Math.PI / 2; // ¬±45¬∞ turn
    }
    
    // Move in current direction with some wiggle
    const wiggle = Math.sin(ant.wiggle) * 0.2;
    ant.x += Math.cos(ant.angle + wiggle) * ant.speed * (deltaTime / 16);
    ant.y += Math.sin(ant.angle + wiggle) * ant.speed * 0.3 * (deltaTime / 16); // Less vertical movement
}

function updateReturningAnt(ant, deltaTime) {
    // Calculate direction to ant hill entrance
    const dx = antHill.x - ant.x;
    const dy = antHill.entranceY - ant.y; // Go to entrance, not center
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // Update angle to face hill
    ant.angle = Math.atan2(dy, dx);
    
    // Move toward hill
    ant.x += Math.cos(ant.angle) * ant.speed * (deltaTime / 16);
    ant.y += Math.sin(ant.angle) * ant.speed * (deltaTime / 16);
    
    // Check if reached hill entrance
    if (dist < 6) { // Close to entrance
        if (ant.carryingFood) {
            // Add food collection animation
            addSpecialEffect({
                type: 'foodCollection',
                x: antHill.x,
                y: antHill.entranceY,
                duration: 800,
                color: '#D2B48C'
            });
            
            antHill.foodCollected++;
            ant.carryingFood = null;
            
            // Grow hill slightly with more food
            antHill.size = Math.min(30, antHill.size + 0.1);
        }
        
        // Reset to exploring
        ant.state = 'exploring';
        ant.speed = ANT_SPEED;
        ant.angle = Math.random() * Math.PI * 2; // Pick new direction
    }
}

function findNearbyFood(ant) {
    const searchRadius = 30; // How far ants can detect food
    
    for (const food of foodItems) {
        const dist = distance(ant.x, ant.y, food.x, food.y);
        if (dist < searchRadius) {
            return food;
        }
    }
    
    return null;
}

// Remove ant hill (when rained on)
function removeAntHill() {
    // Create a "dissolving" visual effect
    if (antHill) {
        addSpecialEffect({
            type: 'dissolve',
            x: antHill.x,
            y: antHill.y,
            size: antHill.size,
            duration: 2000,
            color: '#8B4513'
        });
    }
    
    // Clear ants and ant hill
    antHill = null;
    ants = [];
    
    debugLog("Ant hill dissolved by rain");
}

// Draw ant hill and ants
function drawAnts() {
    // Nothing to draw if no ant hill
    if (!antHill) return;
    
    // Draw the ant hill
    ctx.fillStyle = mushroomMode ? getMushroomColor('#8B4513') : '#8B4513'; // Brown
    ctx.beginPath();
    ctx.ellipse(
        antHill.x,
        antHill.y,
        antHill.size,
        antHill.size * 0.6,
        0, 0, Math.PI * 2
    );
    ctx.fill();

    // Draw ant hill entrance
    ctx.fillStyle = mushroomMode ? getMushroomColor('#3D1C02') : '#3D1C02'; // Darker brown
    ctx.beginPath();
    ctx.ellipse(
        antHill.x, 
        antHill.entranceY, 
        antHill.size * 0.3, 
        antHill.size * 0.15, 
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Draw each ant
    for (const ant of ants) {
        // Check if giant ant should revert to normal size
        if (ant.isGiant && ant.giantUntil && Date.now() >= ant.giantUntil) {
            ant.isGiant = false;
            ant.size = undefined; // Remove custom size
            debugLog('Giant ant reverted to normal size but remains glowing');
        }

        // Determine ant scale
        const antScale = ant.size ? ant.size / 4 : 1; // Normal size is ~4 units

        // Cute bouncy effect
        const bounceOffset = Math.sin(ant.bounce) * 0.5 * antScale;

        // Save context for rotation
        ctx.save();
        ctx.translate(ant.x, ant.y + bounceOffset);
        ctx.rotate(ant.angle);
        ctx.scale(antScale, antScale);

        // Draw glow if glowing
        if (ant.glowing) {
            if (!ant.glowPhase) ant.glowPhase = 0;
            ant.glowPhase += 0.02;
            const glowIntensity = (Math.sin(ant.glowPhase) + 1) / 2;

            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
            glowGradient.addColorStop(0, `rgba(100, 255, 100, ${0.5 * glowIntensity})`);
            glowGradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw food if carrying (underneath ant when drawn)
        if (ant.carryingFood) {
            ctx.fillStyle = mushroomMode ? getMushroomColor('#D2B48C') : '#D2B48C'; // Tan color for food
            ctx.beginPath();
            ctx.arc(ant.foodX, ant.foodY, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Cute ant body - lighter brown (or glowing green if glowing)
        let antColor = '#654321'; // Medium brown
        if (ant.glowing) {
            antColor = '#90EE90'; // Light green for glowing ants
        }
        ctx.fillStyle = mushroomMode ? getMushroomColor(antColor) : antColor;
        
        // Draw rounded body segments
        // Head
        ctx.beginPath();
        ctx.arc(3, 0, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Middle segment
        ctx.beginPath();
        ctx.arc(0, 0, 2.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Back segment
        ctx.beginPath();
        ctx.arc(-3, 0, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes (small white dots)
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(4, -0.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(4, 0.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Antennae
        ctx.strokeStyle = mushroomMode ? getMushroomColor('#654321') : '#654321';
        ctx.lineWidth = 0.5;
        
        ctx.beginPath();
        ctx.moveTo(3.5, -1);
        ctx.lineTo(5, -3);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(3.5, 1);
        ctx.lineTo(5, 3);
        ctx.stroke();
        
        // Legs (3 pairs)
        ctx.lineWidth = 0.7;
        
        for (let i = -1; i <= 1; i++) {
            const segmentY = i * 0.8;
            const segmentX = i * 1.5;
            
            // Left legs
            ctx.beginPath();
            ctx.moveTo(segmentX, -1.2);
            ctx.lineTo(segmentX - 1, -3);
            ctx.stroke();
            
            // Right legs
            ctx.beginPath();
            ctx.moveTo(segmentX, 1.2);
            ctx.lineTo(segmentX - 1, 3);
            ctx.stroke();
        }
        
        // Restore context
        ctx.restore();
    }
    
    
    
    // Debug information if enabled
    if (debugVisuals) {
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText(`Ants: ${ants.length}`, antHill.x - 15, antHill.y - antHill.size - 15);
        ctx.fillText(`Food: ${antHill.foodCollected}`, antHill.x - 15, antHill.y - antHill.size - 5);
    }
}


        // V26: Reduced squirrel spawn rate
        // Core gameplay loop: More branches attract more squirrels
        function spawnSquirrels() {
            if (squirrels.length >= MAX_SQUIRRELS) return;

            // Count total branches across all trees
            let totalBranches = 0;
            trees.forEach(tree => {
                totalBranches += tree.branches ? tree.branches.length : 0;
            });

            // Base spawn chance, increased by branch count
            let spawnChance = 0.007; // Base: 0.7% (reduced to make squirrels more rare)
            const branchMultiplier = Math.min(totalBranches / 10, 2); // Up to 2x multiplier (caps at 20 branches)
            spawnChance = spawnChance * (1 + branchMultiplier);

            if (Math.random() < spawnChance) { // Reduced from 0.02 to dial back squirrel spawns
                let x, y, spawnSource = 'edge';

                // 40% chance to spawn from a bush if bushes exist
                if (bushes.length > 0 && Math.random() < 0.4) {
                    const bush = bushes[Math.floor(Math.random() * bushes.length)];
                    x = bush.x;
                    y = bush.y;
                    spawnSource = 'bush';
                } else {
                    // Spawn from edge
                    x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                    y = canvas.height * GROUND_HEIGHT_RATIO - 5;
                }

                const squirrel = new Squirrel(x, y);
                // Set initial direction based on entry point
                squirrel.direction = x < 50 ? 1 : (x > canvas.width - 50 ? -1 : (Math.random() < 0.5 ? 1 : -1));

                squirrels.push(squirrel);

                if (spawnSource === 'bush') {
                    debugLog(`Squirrel emerged from bush at (${x}, ${y})`);
                } else if (totalBranches > 10) {
                    debugLog(`Squirrel attracted by ${totalBranches} branches!`);
                } else {
                    debugLog(`Squirrel spawned at (${x}, ${y})`);
                }
            }
        }

        // FIXED: Reduced rat spawn rate for slower, screensaver-like pacing
        // Core gameplay loop: More poop attracts more rats
        function spawnRats() {
            if (rats.length >= MAX_RATS) return;

            // Base spawn chance, increased by poop count and maxed food
            let spawnChance = 0.015; // REDUCED from 0.04 (4%) to 1.5% for slower pacing
            const poopMultiplier = Math.min(birdPoops.length / 5, 2); // Up to 2x multiplier (caps at 10 poops)

            // If food has been maxed out for a while, attract rats strongly
            const foodMaxMultiplier = foodMaxedOutTimer > FOOD_MAX_RAT_ATTRACTION_TIME ? 2.5 : 1; // Reduced from 3x

            spawnChance = spawnChance * (1 + poopMultiplier) * foodMaxMultiplier;

            if (Math.random() < spawnChance) {
                let x, y, spawnSource = 'edge';

                // 50% chance to spawn from a bush if bushes exist (rats love bushes!)
                if (bushes.length > 0 && Math.random() < 0.5) {
                    const bush = bushes[Math.floor(Math.random() * bushes.length)];
                    x = bush.x;
                    y = bush.y;
                    spawnSource = 'bush';
                } else {
                    // Spawn from edge
                    x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                    y = canvas.height * GROUND_HEIGHT_RATIO;
                }

                // FIXED: Rat king only spawns if there are 2+ rats close together (overlapping)
                let isRatKing = false;
                if (rats.length >= 2 && Math.random() < RAT_KING_FORMATION_CHANCE) {
                    // Check if any 2 rats are overlapping (within 50px of each other)
                    let foundOverlap = false;
                    for (let i = 0; i < rats.length && !foundOverlap; i++) {
                        for (let j = i + 1; j < rats.length; j++) {
                            const dist = Math.sqrt(
                                Math.pow(rats[i].x - rats[j].x, 2) +
                                Math.pow(rats[i].y - rats[j].y, 2)
                            );
                            if (dist < 50) {
                                foundOverlap = true;
                                break;
                            }
                        }
                    }
                    isRatKing = foundOverlap;
                }

                // Create rat
                const rat = new Rat(x, y, isRatKing);
                rats.push(rat);

                if (spawnSource === 'bush') {
                    debugLog(`${isRatKing ? 'Rat king' : 'Rat'} emerged from bush at (${x}, ${y})`);
                } else if (birdPoops.length > 5) {
                    debugLog(`${isRatKing ? 'Rat king' : 'Rat'} attracted by ${birdPoops.length} poops!`);
                } else {
                    debugLog(`${isRatKing ? 'Rat king' : 'Rat'} spawned at (${x}, ${y})`);
                }
            }
        }

        // Spawn worms with some clustering
        function spawnWorms() {
    // FIXED: Auto-cleanup oldest worms when at capacity
    if (worms.length >= MAX_WORMS) {
        // Remove oldest 20% when at cap to make room
        const removeCount = Math.floor(MAX_WORMS * 0.2);
        worms.splice(0, removeCount);
        debugLog(`Auto-removed ${removeCount} oldest worms (at capacity)`);
    }

    if (Math.random() < 0.02) {
        const clusterSize = Math.floor(Math.random() * 3) + 1; // 1-3 worms in cluster
        const baseX = Math.random() * canvas.width;
        // Spawn worms deeper in grass (20-70px below ground) to encourage birds to land
        const baseY = canvas.height * GROUND_HEIGHT_RATIO + 20 + Math.random() * 50;

        for (let i = 0; i < clusterSize; i++) {
            if (worms.length < MAX_WORMS) {
                const x = baseX + (Math.random() - 0.5) * 30;
                // Ensure worms stay below ground level with Math.max
                const y = Math.max(canvas.height * GROUND_HEIGHT_RATIO, baseY + (Math.random() * 10));

                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 5 + Math.random() * 5,
                    spawnTime: Date.now() // Track age for cleanup
                });
            }
        }
    }
}

function spawnNightWorms() {
    if (worms.length >= MAX_WORMS) return;
    
    // Higher chance to spawn worms at night (5% instead of 2%)
    if (Math.random() < 0.05) {
        // Spawn slightly larger clusters at night (2-4 worms)
        const clusterSize = Math.floor(Math.random() * 3) + 2;
        const baseX = Math.random() * canvas.width;
        const baseY = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 20;
        
        // Create cluster with slightly larger worms at night
        for (let i = 0; i < clusterSize; i++) {
            if (worms.length < MAX_WORMS) {
                const x = baseX + (Math.random() - 0.5) * 40; // More spread out
                const y = Math.max(canvas.height * GROUND_HEIGHT_RATIO, baseY + (Math.random() - 0.5) * 15); // Keep worms at or below ground level
                
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 6 + Math.random() * 5, // Slightly larger worms at night
                    isNightWorm: true // Track that this is a night worm
                });
            }
        }
        
        debugLog(`Night-time worm cluster spawned (${clusterSize} worms)`);
    }
}

// Add your spawnButterflies function here
function spawnButterflies() {
    try {
        // Make sure all required variables exist
        if (typeof butterflies === 'undefined' || !Array.isArray(butterflies)) {
            console.error("butterflies array is not defined");
            return;
        }
        
        if (typeof flowers === 'undefined' || !Array.isArray(flowers)) {
            console.error("flowers array is not defined");
            return;
        }
        
        if (typeof MAX_BUTTERFLIES === 'undefined') {
            console.warn("MAX_BUTTERFLIES not defined, using default value of 10");
        }
        
        const maxButterflies = typeof MAX_BUTTERFLIES !== 'undefined' ? MAX_BUTTERFLIES : 10;
        
        // Only spawn butterflies if there are 5 or more flowers
        if (flowers.length >= 5) {
            if (butterflies.length < maxButterflies && Math.random() < 0.3) {  // Reduced chance for more stability
                // Choose a random flower to spawn butterfly near
                const targetFlower = flowers[Math.floor(Math.random() * flowers.length)];
                
                // Create butterfly near but not exactly on the flower
                const x = targetFlower.x + (Math.random() - 0.5) * 50;
                const y = targetFlower.y - 50 - Math.random() * 50; // Above the flower
                
                const butterfly = new Butterfly(x, y);
                butterflies.push(butterfly);
                
                if (typeof debugLog === 'function') {
                    debugLog(`Butterfly spawned at (${x}, ${y}) near flower`);
                } else {
                    console.log(`Butterfly spawned at (${x}, ${y}) near flower`);
                }
            }
        } else if (butterflies.length > 0) {
            // If flowers drop below 3, make butterflies gradually leave
            if (Math.random() < 0.1) {
                const randomIndex = Math.floor(Math.random() * butterflies.length);
                butterflies[randomIndex].state = 'leaving';
                butterflies[randomIndex].stateTimer = 0;
                
                if (typeof debugLog === 'function') {
                    debugLog(`Butterfly leaving due to lack of flowers`);
                } else {
                    console.log(`Butterfly leaving due to lack of flowers`);
                }
            }
        }
    } catch (e) {
        console.error("Error in spawnButterflies:", e);
    }
}


function checkForMagicMushroom() {
    // If mushroom already exists or has been activated, don't create another
    if (magicMushroomAppeared || magicMushroom || mushroomMode) return;
    
    // Check if all conditions are met
    const hasFlower = flowers.length >= 1;
    const hasBirdhouse = birdhouses.length >= 1;
    
    if (hasFlower && hasBirdhouse && hadRainbow && hadAnts) {
        // Create the magic mushroom
        const groundY = canvas.height * GROUND_HEIGHT_RATIO;
        
        // Find a nice open spot away from trees
        let mushroomX = canvas.width / 2;
        let validPosition = false;
        let attempts = 0;
        
        while (!validPosition && attempts < 20) {
            mushroomX = 100 + Math.random() * (canvas.width - 200);
            validPosition = trees.every(tree => Math.abs(tree.x - mushroomX) > 80);
            attempts++;
        }
        
        magicMushroom = {
            x: mushroomX,
            y: groundY,
            size: 25,
            glowSize: 0,
            glowOpacity: 0,
            pulseTimer: 0,
            clicked: false
        };
        
        magicMushroomAppeared = true;
        debugLog("A magic mushroom has appeared in the garden!");
    }
}


// Add owl spawning functionality
function spawnOwls() {
    // Don't spawn if at max
    if (owls.length >= MAX_OWLS) return;
    
    // Check if it's night time
    const isNight = timeOfDay >= 1;
    
    // Only spawn at night
    if (!isNight) return;
    
    // Check for rat kings - they attract owls
    const ratKingPresent = rats.some(rat => rat.isRatKing);
    let spawnChance = OWL_SPAWN_CHANCE;
    
    if (ratKingPresent) {
        spawnChance += RAT_KING_OWL_ATTRACTION;
        debugLog("Rat king is attracting owls!");
    }
    
    if (Math.random() < spawnChance) {
        // Create new owl
        const owl = new Owl();
        owls.push(owl);
        const owlName = getOwlName(owl);

        // Play owl hoot sound
        playOwlHoot();

        debugLog(`Owl ${owlName} spawned at (${owl.x}, ${owl.y})${ratKingPresent ? ' attracted by rat king' : ''}`);

        // Add diary entry for owl arrival
        if (ratKingPresent) {
            addDiaryEntry(`${owlName} the owl sensed the Rat King and swooped in to hunt.`, 'visitor');
        } else {
            addDiaryEntry(`Under the cover of night, ${owlName} the owl arrived on silent wings.`, 'visitor');
        }
    }
}

        // Spawn twigs - occasionally special twigs
        function spawnTwigs() {
            // FIXED: Auto-cleanup oldest twigs when at capacity
            if (twigs.length >= MAX_TWIGS) {
                const removeCount = Math.floor(MAX_TWIGS * 0.2);
                twigs.splice(0, removeCount);
                debugLog(`Auto-removed ${removeCount} oldest twigs (at capacity)`);
            }

            if (Math.random() < 0.1) {
                // Find a spot near a tree if possible
                let x, y;

                if (trees.length > 0 && Math.random() < 0.7) {
                    // Pick a random tree
                    const randomTree = trees[Math.floor(Math.random() * trees.length)];
                    x = randomTree.x + (Math.random() - 0.5) * 100;
                    y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 5;
                } else {
                    // Random spot on ground
                    x = Math.random() * canvas.width;
                    y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10;
                }

                // Small chance of special twig
                const isSpecial = Math.random() < 0.05;

                if (twigs.length < MAX_TWIGS) {
                    twigs.push({
                        x: x,
                        y: y,
                        size: 10 + Math.random() * 8,
                        angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                        isSpecial: isSpecial,
                        offshoots: [],
                        spawnTime: Date.now() // Track age for cleanup
                    });

                    if (isSpecial) {
                        debugLog(`Special twig spawned at (${x}, ${y})`);
                    }
                }
            }
        }

        // Draw rain
        function drawRain(deltaTime) {
            if (isRaining) {
                // Add new raindrops at the top of the screen
                for (let i = 0; i < 5; i++) {
                    raindrops.push({
                        x: Math.random() * canvas.width,
                        y: -20,
                        length: 10 + Math.random() * 20,
                        speed: 5 + Math.random() * 10
                    });
                }
                
                // Update and draw existing raindrops
                ctx.strokeStyle = isThundering ? 'rgba(200, 210, 255, 0.7)' : 'rgba(200, 210, 255, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = raindrops.length - 1; i >= 0; i--) {
                    const drop = raindrops[i];
                    
                    // Update position
                    drop.y += drop.speed * (deltaTime / 16);
                    
                    // Draw raindrop
                    ctx.beginPath();
                    ctx.moveTo(drop.x, drop.y);
                    ctx.lineTo(drop.x, drop.y + drop.length);
                    ctx.stroke();
                    
                    // Remove raindrops that have fallen beyond the ground
                    if (drop.y > canvas.height * GROUND_HEIGHT_RATIO) {
                        // Occasionally create a ripple on a puddle
                        const nearbyPuddle = puddles.find(puddle => 
                            Math.abs(puddle.x - drop.x) < 30
                        );
                        
                        if (nearbyPuddle && Math.random() < 0.1) {
                            nearbyPuddle.ripples.push({
                                size: 2,
                                maxSize: 5 + Math.random() * 5,
                                speed: 0.05 + Math.random() * 0.05
                            });
                        }
                        
                        raindrops.splice(i, 1);
                    }
                }
                
                // Add fogging/mist effect
                ctx.fillStyle = isThundering ? 
                    'rgba(210, 220, 255, 0.05)' : 
                    'rgba(220, 230, 255, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height * GROUND_HEIGHT_RATIO);
            } else {
                // Clear raindrops if not raining
                raindrops = [];
            }
        }

        // V26: Improved wind chime system with more balanced volume and timing
        function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Define wind chime frequencies based on pentatonic scale - OCTAVE HIGHER for brighter sound
                windChimeSounds = {
                    'C': 523.25, // C5 (was C4 261.63)
                    'D': 587.33, // D5 (was D4 293.66)
                    'E': 659.25, // E5 (was E4 329.63)
                    'G': 783.99, // G5 (was G4 392.00)
                    'A': 880.00  // A5 (was A4 440.00)
                };
                
                debugLog("Audio context initialized");
            } catch (e) {
                console.error("Error initializing audio:", e);
                windChimeEnabled = false;
            }
        }

        // V26: Wind chime playback with reduced volume
        // Simple test function to verify audio is working (call from console)
        window.testAudio = function() {
            console.log("Testing basic audio...");
            if (!audioContext) {
                initializeAudio();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            console.log("Audio context state:", audioContext ? audioContext.state : "null");

            if (!audioContext) {
                console.error("Cannot initialize audio context");
                return;
            }

            // Play a simple tone
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.frequency.value = 440; // A4
            osc.type = 'sine';

            gain.gain.value = 0;

            osc.connect(gain);
            gain.connect(audioContext.destination);

            const now = audioContext.currentTime;
            osc.start(now);
            gain.gain.linearRampToValueAtTime(0.3, now + 0.01);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.stop(now + 0.5);

            console.log("Test tone should play now (440Hz for 0.5s)");
        };

        // Hidden console command: playthehits
        // Makes birds chirp melodic patterns inspired by popular songs
        window.playthehits = function() {
            console.log("üéµ Playing the hits! Birds will chirp popular melodies...");

            if (!audioContext) {
                initializeAudio();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (!audioContext) {
                console.error("Cannot initialize audio context");
                return;
            }

            // Check if muted
            if (isMuted) {
                console.log("Audio is muted, unmute to hear the hits!");
                return;
            }

            // Check if already playing
            if (playingTheHits) {
                console.log("Already playing the hits! Wait for the current song to finish.");
                return;
            }

            // Melodic patterns (rhythm and note patterns inspired by songs)
            const melodies = [
                // "Call Me Maybe" pattern - upbeat and catchy
                { name: "Call Me Maybe", notes: [659, 587, 523, 587, 659, 698, 783], durations: [0.15, 0.15, 0.2, 0.15, 0.15, 0.2, 0.3] },
                // "Who Let the Dogs Out" pattern - rhythmic and repetitive
                { name: "Who Let the Dogs Out", notes: [523, 523, 587, 659, 523, 523, 587, 659], durations: [0.12, 0.12, 0.12, 0.25, 0.12, 0.12, 0.12, 0.25] },
                // "Sittin' On The Dock of the Bay" pattern - relaxed whistling
                { name: "Sittin' On The Dock of the Bay", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                // "Me and Julio" pattern - playful and light
                { name: "Me and Julio Down by the Schoolyard", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.25] },
                // "Young Folks" pattern - whistling melody
                { name: "Young Folks", notes: [880, 783, 698, 783, 880, 987, 880], durations: [0.2, 0.15, 0.15, 0.2, 0.2, 0.25, 0.3] },
                // "Pumped Up Kicks" pattern - mellow whistle
                { name: "Pumped Up Kicks", notes: [659, 698, 783, 698, 659, 587, 659], durations: [0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3] },
                // "Don't Worry Be Happy" pattern - cheerful whistling
                { name: "Don't Worry Be Happy", notes: [523, 659, 783, 880, 783, 659, 523], durations: [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.3] },
                // "Walk Like an Egyptian" pattern - quirky melody
                { name: "Walk Like an Egyptian", notes: [587, 523, 587, 698, 783, 698, 587], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.3] },
                // "Whistle While You Work" pattern - classic Disney whistle
                { name: "Whistle While You Work", notes: [523, 587, 659, 698, 783, 698, 659, 587, 523], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.15, 0.3] },
                // "Happy" by Pharrell - upbeat and cheerful
                { name: "Happy", notes: [659, 659, 698, 783, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.2, 0.3, 0.2, 0.3] },
                // "Somewhere Over the Rainbow" - classic dreamy melody
                { name: "Somewhere Over the Rainbow", notes: [523, 659, 783, 880, 987, 880, 783, 659], durations: [0.2, 0.2, 0.25, 0.3, 0.3, 0.25, 0.2, 0.3] },
                // "Lean on Me" - soulful and warm
                { name: "Lean on Me", notes: [587, 659, 698, 659, 587, 523], durations: [0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                // "Three Little Birds" - reggae feel
                { name: "Three Little Birds", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.2, 0.2, 0.2, 0.25, 0.2, 0.2, 0.3] },
                // "What a Wonderful World" - gentle and sweet
                { name: "What a Wonderful World", notes: [523, 587, 659, 783, 880, 783, 659], durations: [0.25, 0.2, 0.25, 0.3, 0.3, 0.25, 0.3] },
                // 1980s and 90s classics
                { name: "Livin' On A Prayer", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.15, 0.15, 0.2, 0.3, 0.2, 0.15, 0.3] },
                { name: "Don't Stop Believin'", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] },
                { name: "Sweet Child O' Mine", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Take On Me", notes: [783, 880, 987, 1046, 987, 880, 783], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Africa", notes: [587, 659, 698, 783, 698, 659, 587, 523], durations: [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3] },
                { name: "Every Breath You Take", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "I Wanna Dance with Somebody", notes: [698, 783, 880, 987, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Girls Just Want to Have Fun", notes: [659, 698, 783, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Purple Rain", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Under Pressure", notes: [587, 659, 698, 659, 587, 523, 587], durations: [0.15, 0.15, 0.25, 0.2, 0.15, 0.15, 0.3] },
                { name: "Billie Jean", notes: [659, 698, 783, 698, 659, 587, 659], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Beat It", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Faith", notes: [587, 659, 698, 783, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.2, 0.25, 0.2, 0.3] },
                { name: "Wonderwall", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] }
            ];

            // Pick ONE random melody
            const melody = melodies[Math.floor(Math.random() * melodies.length)];
            console.log(`üé∂ Playing: "${melody.name}"`);

            // Disable random chirping during performance
            playingTheHits = true;

            if (birds.length === 0) {
                console.log("No birds in the garden to sing!");
                playingTheHits = false;
                return;
            }

            // Divide the melody among available birds
            const availableBirds = birds.slice(0, Math.min(birds.length, melody.notes.length));
            const notesPerBird = Math.ceil(melody.notes.length / availableBirds.length);

            console.log(`üê¶ ${availableBirds.length} birds will share the melody (${melody.notes.length} notes)`);

            let currentTime = audioContext.currentTime + 0.2; // Small delay to start
            let totalDuration = 0;

            // Each bird gets a portion of the melody
            availableBirds.forEach((bird, birdIndex) => {
                const startNote = birdIndex * notesPerBird;
                const endNote = Math.min(startNote + notesPerBird, melody.notes.length);

                for (let i = startNote; i < endNote; i++) {
                    const freq = melody.notes[i];
                    const duration = melody.durations[i];

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 3;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);

                    gain.gain.value = 0;
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.18, currentTime + 0.01);
                    gain.gain.linearRampToValueAtTime(0, currentTime + duration);

                    osc.start(currentTime);
                    osc.stop(currentTime + duration + 0.01);

                    currentTime += duration + 0.08; // Small gap between notes
                    totalDuration = currentTime - audioContext.currentTime;
                }
            });

            // Re-enable chirping after the song finishes
            setTimeout(() => {
                playingTheHits = false;
                console.log("üéµ Song finished! Regular chirping resumed.");
            }, totalDuration * 1000 + 500);
        };

        // Get all 24 melodies for hourly chimes - 1980s and 90s classics
        function getAllMelodies() {
            return [
                { name: "Sweet Child O' Mine", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Take On Me", notes: [783, 880, 987, 1046, 987, 880, 783], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Livin' On A Prayer", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.15, 0.15, 0.2, 0.3, 0.2, 0.15, 0.3] },
                { name: "Don't Stop Believin'", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] },
                { name: "Africa", notes: [587, 659, 698, 783, 698, 659, 587, 523], durations: [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3] },
                { name: "Every Breath You Take", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "I Wanna Dance with Somebody", notes: [698, 783, 880, 987, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Girls Just Want to Have Fun", notes: [659, 698, 783, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Purple Rain", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Under Pressure", notes: [587, 659, 698, 659, 587, 523, 587], durations: [0.15, 0.15, 0.25, 0.2, 0.15, 0.15, 0.3] },
                { name: "Walk Like an Egyptian", notes: [587, 523, 587, 698, 783, 698, 587], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.3] },
                { name: "Billie Jean", notes: [659, 698, 783, 698, 659, 587, 659], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Beat It", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Faith", notes: [587, 659, 698, 783, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.2, 0.25, 0.2, 0.3] },
                { name: "Careless Whisper", notes: [659, 698, 783, 880, 987, 880, 783], durations: [0.2, 0.2, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Nothing Compares 2 U", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Wonderwall", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "Smells Like Teen Spirit", notes: [523, 587, 523, 659, 698, 659, 587], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.3] },
                { name: "Mr. Brightside", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Don't You (Forget About Me)", notes: [587, 659, 698, 783, 880, 783, 698], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] },
                { name: "Everybody Wants to Rule the World", notes: [523, 587, 659, 698, 783, 698, 659, 587], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "The Power of Love", notes: [523, 659, 783, 880, 987, 880, 783, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.25, 0.3] },
                { name: "Time After Time", notes: [659, 698, 783, 880, 783, 698, 659, 587], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.2, 0.3] },
                { name: "Don't Stop Believin'", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] }
            ];
        }

        // Shuffle array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Initialize hourly melody playlist
        function initializeHourlyPlaylist() {
            hourlyMelodyPlaylist = shuffleArray(getAllMelodies());
            melodyPlaylistIndex = 0;
            debugLog("Hourly melody playlist initialized and shuffled");
        }

        // RARE: Birds spontaneously perform a melody (after music conversations)
        function playBirdMelody(bird1, bird2) {
            if (!audioContext || playingTheHits || isMuted) return;

            // Pick a random melody from all 24
            const allMelodies = getAllMelodies();
            const melody = allMelodies[Math.floor(Math.random() * allMelodies.length)];

            debugLog(`üéµ Birds performing "${melody.name}" as a duet/solo!`);

            // Disable random chirping during performance
            playingTheHits = true;

            // Determine if solo or duet
            const isSolo = !bird2 || Math.random() < 0.3; // 30% chance of solo even with two birds
            const performingBirds = isSolo ? [bird1] : [bird1, bird2];

            let currentTime = audioContext.currentTime + 0.2;
            let totalDuration = 0;

            if (isSolo) {
                // Solo performance - one bird sings entire melody
                debugLog(`Solo performance by ${getBirdName(bird1)}`);
                melody.notes.forEach((freq, i) => {
                    const duration = melody.durations[i] * 1.2; // Slightly longer, more expressive

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq * 1.5; // Higher pitch for bird voice

                    filter.type = 'bandpass';
                    filter.frequency.value = freq * 1.5;
                    filter.Q.value = 4; // More bird-like

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);

                    gain.gain.value = 0;
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.12, currentTime + 0.02);
                    gain.gain.linearRampToValueAtTime(0, currentTime + duration);

                    osc.start(currentTime);
                    osc.stop(currentTime + duration + 0.01);

                    currentTime += duration + 0.1; // Slight pause between notes
                    totalDuration = currentTime - audioContext.currentTime;
                });
            } else {
                // Duet - birds alternate notes
                debugLog(`Duet between ${getBirdName(bird1)} and ${getBirdName(bird2)}`);
                melody.notes.forEach((freq, i) => {
                    const currentBird = i % 2 === 0 ? bird1 : bird2;
                    const duration = melody.durations[i] * 1.1;

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();

                    // Slightly different pitch for each bird
                    const pitchVariation = currentBird === bird1 ? 1.5 : 1.6;
                    osc.type = 'sine';
                    osc.frequency.value = freq * pitchVariation;

                    filter.type = 'bandpass';
                    filter.frequency.value = freq * pitchVariation;
                    filter.Q.value = 4;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);

                    gain.gain.value = 0;
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.11, currentTime + 0.02);
                    gain.gain.linearRampToValueAtTime(0, currentTime + duration);

                    osc.start(currentTime);
                    osc.stop(currentTime + duration + 0.01);

                    currentTime += duration + 0.08;
                    totalDuration = currentTime - audioContext.currentTime;
                });
            }

            // Add diary entry for this special event
            addDiaryEntry(`üéµ ${isSolo ? getBirdName(bird1) + ' performed a solo' : 'Two birds sang a duet'} - "${melody.name}"!`, 'special');

            // Re-enable chirping after performance
            setTimeout(() => {
                playingTheHits = false;
            }, totalDuration * 1000 + 500);
        }

        // Play hourly chime melody
        function playHourlyChime() {
            if (!clockEnabled || !audioContext || playingTheHits) return;
            if (isMuted) return;

            // Get next melody from playlist
            const melody = hourlyMelodyPlaylist[melodyPlaylistIndex];
            melodyPlaylistIndex = (melodyPlaylistIndex + 1) % hourlyMelodyPlaylist.length;

            // If we've cycled through all 24, reshuffle
            if (melodyPlaylistIndex === 0) {
                hourlyMelodyPlaylist = shuffleArray(getAllMelodies());
                debugLog("Reshuffled hourly melody playlist");
            }

            debugLog(`üïê Hourly chime: "${melody.name}"`);

            // Disable random chirping during chime
            playingTheHits = true;

            if (birds.length === 0) {
                playingTheHits = false;
                return;
            }

            // Use available birds to play the melody
            const availableBirds = birds.slice(0, Math.min(birds.length, melody.notes.length));
            const notesPerBird = Math.ceil(melody.notes.length / availableBirds.length);

            let currentTime = audioContext.currentTime + 0.1;
            let totalDuration = 0;

            availableBirds.forEach((bird, birdIndex) => {
                const startNote = birdIndex * notesPerBird;
                const endNote = Math.min(startNote + notesPerBird, melody.notes.length);

                for (let i = startNote; i < endNote; i++) {
                    const freq = melody.notes[i];
                    const duration = melody.durations[i];

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 3;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);

                    gain.gain.value = 0;
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.15, currentTime + 0.01); // Slightly quieter than manual playthehits
                    gain.gain.linearRampToValueAtTime(0, currentTime + duration);

                    osc.start(currentTime);
                    osc.stop(currentTime + duration + 0.01);

                    currentTime += duration + 0.08;
                    totalDuration = currentTime - audioContext.currentTime;
                }
            });

            // Re-enable chirping after chime
            setTimeout(() => {
                playingTheHits = false;
            }, totalDuration * 1000 + 300);
        }

        // Check for hour change and play chime
        function checkHourlyChime() {
            if (!clockEnabled) return;

            const now = new Date();
            const currentHour = now.getHours();

            if (currentHour !== lastHourChimed) {
                lastHourChimed = currentHour;
                playHourlyChime();
            }
        }

        // Musical scales for bird chirps (frequencies in Hz)
        const BIRD_SCALES = {
            // Pentatonic scale (very melodic, used in many bird songs)
            pentatonic: [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51], // C5-E6
            // Major scale (bright and cheerful)
            major: [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77, 1046.50], // C5-C6
            // Minor pentatonic (more exotic)
            minorPentatonic: [440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50], // A4-C6
            // High melodic (like a songbird)
            highMelodic: [783.99, 880.00, 987.77, 1046.50, 1174.66, 1318.51, 1396.91, 1567.98] // G5-G6
        };

        // Musical bird chirp synthesis with different voices per bird
        function synthBirdChirp(volume = 0.3, birdId = null) {
            console.log("synthBirdChirp called - volume:", volume, "birdId:", birdId);

            // Check if muted first
            if (isMuted) {
                console.log("Audio is muted, skipping chirp");
                return;
            }

            // Initialize audio context if needed
            if (!audioContext) {
                console.log("Initializing audio context...");
                initializeAudio();
            }

            // Resume audio context if suspended (required by browsers)
            if (audioContext && audioContext.state === 'suspended') {
                console.log("Resuming suspended audio context...");
                audioContext.resume();
            }

            if (!audioContext) {
                console.error("Audio context not available for bird chirp");
                return;
            }

            console.log("Audio context state:", audioContext.state);

            try {
                // Determine bird's unique voice based on ID
                let scale, oscType, pitchVariation;

                if (birdId !== null && birdId !== undefined && typeof birdId === 'number') {
                    // Give each bird a consistent voice based on their ID
                    const voiceIndex = birdId % 4;
                    const voiceTypes = [
                        { scale: BIRD_SCALES.pentatonic, type: 'sine', variation: 1.0, name: 'Melodic' },
                        { scale: BIRD_SCALES.major, type: 'triangle', variation: 1.05, name: 'Bright' },
                        { scale: BIRD_SCALES.minorPentatonic, type: 'sine', variation: 0.98, name: 'Exotic' },
                        { scale: BIRD_SCALES.highMelodic, type: 'sine', variation: 1.02, name: 'Songbird' }
                    ];

                    const voice = voiceTypes[voiceIndex];
                    scale = voice.scale;
                    oscType = voice.type;
                    pitchVariation = voice.variation;
                    console.log("Using bird voice:", voice.name, "for bird ID:", birdId);
                } else {
                    // Random voice if no bird ID provided
                    console.log("Using random voice (birdId was:", birdId, ")");
                    const scaleKeys = Object.keys(BIRD_SCALES);
                    scale = BIRD_SCALES[scaleKeys[Math.floor(Math.random() * scaleKeys.length)]];
                    oscType = Math.random() < 0.7 ? 'sine' : 'triangle';
                    pitchVariation = 0.98 + Math.random() * 0.04;
                }

                // Pick random notes from the bird's scale
                const noteIndex = Math.floor(Math.random() * scale.length);
                const baseFreq = scale[noteIndex] * pitchVariation;

                // Chirp pattern: pick 1-3 notes for variety
                const chirpPattern = Math.floor(Math.random() * 3) + 1;
                const chirpLength = 0.08 + Math.random() * 0.12;

                // Create oscillator
                const osc = audioContext.createOscillator();
                osc.type = oscType;
                osc.frequency.value = baseFreq;

                // Create gain node
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;

                // Filter to shape the sound
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 3;

                // Connect nodes
                osc.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Start sound
                const now = audioContext.currentTime;
                console.log("Starting oscillator - baseFreq:", baseFreq, "type:", oscType, "pattern:", chirpPattern);
                osc.start(now);

                // Create musical chirp envelope with scale-based pitch changes
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                console.log("Chirp playing - volume:", volume, "length:", chirpLength);

                // ENHANCED: Musical frequency modulation with 6 different melodic patterns
                const pattern = chirpPattern % 6;
                switch(pattern) {
                    case 0:
                        // Single note with vibrato
                        osc.frequency.setValueAtTime(baseFreq, now);
                        osc.frequency.linearRampToValueAtTime(baseFreq * 1.05, now + chirpLength * 0.3);
                        osc.frequency.linearRampToValueAtTime(baseFreq, now + chirpLength);
                        break;
                    case 1:
                        // Two note pattern (interval jump up)
                        const nextNoteIndex = Math.min(noteIndex + 2, scale.length - 1);
                        const nextFreq = scale[nextNoteIndex] * pitchVariation;
                        osc.frequency.setValueAtTime(baseFreq, now);
                        osc.frequency.linearRampToValueAtTime(nextFreq, now + chirpLength * 0.5);
                        osc.frequency.linearRampToValueAtTime(nextFreq * 0.95, now + chirpLength);
                        break;
                    case 2:
                        // Three note trill (up-up-down)
                        const nextNote1 = scale[Math.min(noteIndex + 1, scale.length - 1)] * pitchVariation;
                        const nextNote2 = scale[Math.min(noteIndex + 3, scale.length - 1)] * pitchVariation;
                        osc.frequency.setValueAtTime(baseFreq, now);
                        osc.frequency.linearRampToValueAtTime(nextNote1, now + chirpLength * 0.3);
                        osc.frequency.linearRampToValueAtTime(nextNote2, now + chirpLength * 0.6);
                        osc.frequency.linearRampToValueAtTime(baseFreq, now + chirpLength);
                        break;
                    case 3:
                        // Descending pattern (songbird style)
                        const lowerNote1 = scale[Math.max(noteIndex - 1, 0)] * pitchVariation;
                        const lowerNote2 = scale[Math.max(noteIndex - 2, 0)] * pitchVariation;
                        osc.frequency.setValueAtTime(baseFreq, now);
                        osc.frequency.linearRampToValueAtTime(lowerNote1, now + chirpLength * 0.4);
                        osc.frequency.linearRampToValueAtTime(lowerNote2, now + chirpLength * 0.8);
                        osc.frequency.setValueAtTime(lowerNote2, now + chirpLength);
                        break;
                    case 4:
                        // Warble (up and down quickly)
                        const warbleUp = scale[Math.min(noteIndex + 2, scale.length - 1)] * pitchVariation;
                        osc.frequency.setValueAtTime(baseFreq, now);
                        osc.frequency.linearRampToValueAtTime(warbleUp, now + chirpLength * 0.25);
                        osc.frequency.linearRampToValueAtTime(baseFreq, now + chirpLength * 0.5);
                        osc.frequency.linearRampToValueAtTime(warbleUp, now + chirpLength * 0.75);
                        osc.frequency.linearRampToValueAtTime(baseFreq, now + chirpLength);
                        break;
                    case 5:
                        // Four note cascade (melodic)
                        const n1 = scale[Math.min(noteIndex + 1, scale.length - 1)] * pitchVariation;
                        const n2 = scale[Math.min(noteIndex + 2, scale.length - 1)] * pitchVariation;
                        const n3 = scale[Math.min(noteIndex + 4, scale.length - 1)] * pitchVariation;
                        osc.frequency.setValueAtTime(baseFreq, now);
                        osc.frequency.linearRampToValueAtTime(n1, now + chirpLength * 0.25);
                        osc.frequency.linearRampToValueAtTime(n2, now + chirpLength * 0.5);
                        osc.frequency.linearRampToValueAtTime(n3, now + chirpLength * 0.75);
                        osc.frequency.setValueAtTime(n3 * 0.95, now + chirpLength);
                        break;
                }

                // End the chirp
                gainNode.gain.linearRampToValueAtTime(0, now + chirpLength);
                osc.stop(now + chirpLength + 0.01);

                // Continue with a sequence of chirps (30% chance)
                if (Math.random() < 0.3) {
                    setTimeout(() => {
                        synthBirdChirp(volume * 0.85, birdId);
                    }, (chirpLength + 0.08 + Math.random() * 0.15) * 1000);
                }
            } catch (e) {
                console.error("Error playing bird chirp:", e);
            }
        }

        // Owl hoot sound synthesis
        function playOwlHoot() {
            // Check if muted first
            if (isMuted) return;

            // Initialize audio context if needed
            if (!audioContext) {
                initializeAudio();
            }

            // Resume audio context if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (!audioContext) return;

            try {
                // Classic owl "hoo-hoo" pattern
                const hootTimes = [0, 0.5]; // Two hoots
                const baseFreq = 200; // Low frequency for owl

                hootTimes.forEach((startTime) => {
                    const now = audioContext.currentTime + startTime;

                    // Create oscillator for the hoot
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq;

                    // Create gain node for volume envelope
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0;

                    // Create filter for that hollow owl sound
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 500;
                    filter.Q.value = 5;

                    // Connect nodes
                    osc.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Start oscillator
                    osc.start(now);

                    // FIX: Reduced hoot volume - was too loud
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.08, now + 0.05); // Quick attack - reduced from 0.15
                    gainNode.gain.setValueAtTime(0.08, now + 0.2); // Sustain - reduced from 0.15
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.35); // Release

                    // Frequency modulation for realistic hoot
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(baseFreq * 0.95, now + 0.15); // Slight drop
                    osc.frequency.linearRampToValueAtTime(baseFreq * 0.9, now + 0.35); // Further drop at end

                    // Stop oscillator
                    osc.stop(now + 0.4);
                });

                debugLog("Owl hoot played");
            } catch (e) {
                console.error("Error playing owl hoot:", e);
            }
        }

        function playNote(note, duration = 4) {
            if (!audioContext) return;

            // CRITICAL: Safety check - ensure windChimeSounds exists and note is valid
            if (!windChimeSounds || !windChimeSounds[note]) {
                console.warn(`Wind chime note "${note}" not found in windChimeSounds`);
                return;
            }

            // Verify frequency is a valid number
            const frequency = windChimeSounds[note];
            if (!isFinite(frequency) || frequency <= 0) {
                console.error(`Invalid frequency for note "${note}": ${frequency}`);
                return;
            }

            try {
                // Create main oscillator with slight detuning for shimmer
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                // Create multiple harmonic overtones for metallic wind chime quality - REDUCED VOLUME
                const harmonics = [
                    { mult: 2.76, gain: 0.025 },  // Inharmonic overtone (metallic) - reduced from 0.08
                    { mult: 5.4, gain: 0.012 },   // Higher metallic overtone - reduced from 0.04
                    { mult: 8.93, gain: 0.006 }   // Shimmer overtone - reduced from 0.02
                ];

                const harmonicOscillators = harmonics.map(h => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.type = 'sine';
                    // Add slight detuning for shimmer effect
                    osc.frequency.setValueAtTime(frequency * h.mult + (Math.random() - 0.5) * 2, audioContext.currentTime);

                    // Quick attack, long decay for metallic ring
                    gain.gain.setValueAtTime(0, audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(h.gain, audioContext.currentTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration * 0.9);
                    gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    return { osc, gain };
                });

                // Connect main oscillator
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Bright, fast attack with long sustain for wind chime character - REDUCED VOLUME
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.01); // Very fast attack - reduced from 0.18
                gainNode.gain.exponentialRampToValueAtTime(0.002, audioContext.currentTime + duration * 0.85); // Long shimmer - reduced from 0.006
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

                // Start all oscillators
                oscillator.start();
                harmonicOscillators.forEach(h => h.osc.start());

                // Stop all oscillators
                oscillator.stop(audioContext.currentTime + duration);
                harmonicOscillators.forEach(h => h.osc.stop(audioContext.currentTime + duration));
            } catch (e) {
                console.error("Error playing note:", e);
            }
        }

        // V39: Wind chime playback - ONLY plays when wind chimes are visible on screen
        function playWindChimes() {
    if (!windChimeEnabled) return;

    // CRITICAL FIX: Only play wind chimes if at least one is visible on screen
    const hasVisibleChime = windChimes.some(chime =>
        chime.x >= -100 && chime.x <= canvas.width + 100
    );

    if (!hasVisibleChime) {
        debugLog("No wind chimes visible on screen - not playing audio");
        return;
    }

    if (audioContext && audioContext.state === 'suspended') audioContext.resume();

    // Initialize audio context if needed
    if (!audioContext) initializeAudio();

    // IMPORTANT FIX: Check if audio context is suspended and resume it
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            debugLog("Audio context resumed");
        }).catch(err => {
            console.error("Error resuming audio context:", err);
        });
    }

    // Update wind chime state
    const now = Date.now();

    // TIMING: One chime every 30-45 seconds normally, more frequent during rain (15-25 seconds)
    const baseDelay = isRaining ? 15000 : 30000;
    const randomDelay = isRaining ? 10000 : 15000;
    if (now - lastWindChimeTime > baseDelay + Math.random() * randomDelay) {
        // ENHANCED: Multiple wind chime melodies for more variety
        const melodies = [
            ['C', 'D', 'E', 'G', 'A'],      // Pentatonic (original)
            ['C', 'E', 'F', 'G', 'A', 'C'], // Major pentatonic with octave
            ['A', 'C', 'D', 'E', 'G'],      // Minor pentatonic
            ['C', 'D', 'F', 'G', 'A'],      // Suspended pentatonic
            ['G', 'A', 'C', 'D', 'E'],      // Shifted pentatonic
            ['E', 'G', 'A', 'C', 'D']       // Another variation
        ];

        // Randomly select a melody
        const notes = melodies[Math.floor(Math.random() * melodies.length)];

        // WIND PASSING THROUGH: Play 2-5 notes in sequence as if wind passes through the chimes
        const numNotes = 2 + Math.floor(Math.random() * 4); // 2-5 notes (was 2-4)
        const startIdx = Math.floor(Math.random() * (notes.length - numNotes + 1));
        const direction = Math.random() < 0.5 ? 1 : -1; // Ascending or descending

        // Build sequence of notes
        const sequence = [];
        for (let i = 0; i < numNotes; i++) {
            const noteIdx = direction > 0 ? startIdx + i : startIdx + numNotes - 1 - i;
            sequence.push(notes[noteIdx]);
        }

        debugLog(`Wind passing through chimes: ${sequence.join('-')}`);

        // Play notes in sequence with natural timing
        sequence.forEach((note, i) => {
            setTimeout(() => {
                playNote(note, 5 + Math.random() * 1);
            }, i * (100 + Math.random() * 50)); // 100-150ms between notes
        });
        
        lastWindChimeTime = now;

        // Schedule next chime with a simple timeout
        if (windChimeTimeout) {
            clearTimeout(windChimeTimeout);
        }

        // ENHANCED: Calculate delay based on weather (more frequent during rain)
        // Rain: 3-10 seconds, Normal: 8-20 seconds
        const baseNextDelay = isRaining ? 3000 : 8000;
        const randomNextDelay = isRaining ? 7000 : 12000;
        const nextChimeDelay = baseNextDelay + Math.random() * randomNextDelay;
        debugLog(`Scheduling next wind chime in ${Math.round(nextChimeDelay/1000)} seconds ${isRaining ? '(raining)' : ''}`);

        windChimeTimeout = setTimeout(() => {
            // Recursively call playWindChimes to play next sound and schedule the next one
            playWindChimes();
        }, nextChimeDelay);
    } else {
        // Not time to play yet, check again soon
        if (windChimeTimeout) {
            clearTimeout(windChimeTimeout);
        }
        windChimeTimeout = setTimeout(() => {
            playWindChimes();
        }, 5000); // Check again in 5 seconds
    }
}

        // ENHANCED EMOJI CONVERSATION SYSTEM
        function startEmojiConversation() {
            const now = Date.now();

            // Only start new conversation once or twice a day (rare!)
            // Game day is ~4 minutes, so check every 2-4 minutes (120000-240000ms)
            if (now - lastEmojiConversationTime < 120000 + Math.random() * 120000) {
                return;
            }

            // Need at least 2 birds
            if (birds.length < 2) return;

            // Find two birds close to each other (but not the same bird)
            const bird1 = birds[Math.floor(Math.random() * birds.length)];
            const nearbyBirds = birds.filter(b =>
                b !== bird1 &&
                distance(bird1.x, bird1.y, b.x, b.y) < 200
            );

            if (nearbyBirds.length === 0) return;

            const bird2 = nearbyBirds[Math.floor(Math.random() * nearbyBirds.length)];

            // ENHANCED: Choose conversation type with more variety and mixing
            let conversationType = 'RANDOM';
            let primarySet = EMOJI_SETS.RANDOM;
            let secondarySet = null;
            let triggerMelody = false;

            const typeRoll = Math.random();

            // VERY RARE: Music conversation (~once every 10 game days)
            // Game day is ~4 min (240s), so 10 days = 2400s = 2,400,000ms
            // With conversations checking every 2-4min, this gives ~0.5% chance per conversation
            if (typeRoll < 0.005) {
                conversationType = 'MUSIC';
                primarySet = ['üéµ', 'üé∂', 'üé§', 'üéº', 'üéπ', 'üé∏', 'üé∫'];
                secondarySet = EMOJI_SETS.EXCITEMENT;
                triggerMelody = true; // Birds will sing a melody!
                debugLog('üéµ RARE: Birds are having a music conversation and will sing!');
            }
            // Context-based conversation selection
            else if (isRaining && typeRoll < 0.3) {
                conversationType = 'WEATHER_COMPLAINT';
                primarySet = EMOJI_SETS.WEATHER;
                secondarySet = EMOJI_SETS.COMPLAINT;
            } else if (foodItems.length > 10 && typeRoll < 0.4) {
                conversationType = 'FOOD_EXCITEMENT';
                primarySet = EMOJI_SETS.FOOD;
                secondarySet = EMOJI_SETS.EXCITEMENT;
            } else if (timeOfDay >= 1 && typeRoll < 0.2) {
                conversationType = 'NIGHT_MYSTERY';
                primarySet = EMOJI_SETS.MYSTERY;
                secondarySet = EMOJI_SETS.PHILOSOPHY;
            } else if (typeRoll < 0.15) {
                conversationType = 'GOSSIP';
                primarySet = EMOJI_SETS.GOSSIP;
                secondarySet = EMOJI_SETS.REACTIONS;
            } else if (typeRoll < 0.25) {
                conversationType = 'PHILOSOPHY';
                primarySet = EMOJI_SETS.PHILOSOPHY;
                secondarySet = EMOJI_SETS.RANDOM;
            } else if (typeRoll < 0.35) {
                conversationType = 'FRIENDSHIP';
                primarySet = EMOJI_SETS.FRIENDSHIP;
                secondarySet = EMOJI_SETS.STATES;
            } else if (typeRoll < 0.5) {
                conversationType = 'NATURE';
                primarySet = EMOJI_SETS.NATURE;
                secondarySet = EMOJI_SETS.STATES;
            } else {
                // Truly random "show about nothing"
                conversationType = 'ABSURD';
                const allSets = Object.values(EMOJI_SETS);
                primarySet = allSets[Math.floor(Math.random() * allSets.length)];
                secondarySet = allSets[Math.floor(Math.random() * allSets.length)];
            }

            // ENHANCED: Longer conversations with better structure (4-7 exchanges)
            const numExchanges = 4 + Math.floor(Math.random() * 4);
            const exchanges = [];

            // Pick 1-2 shared emojis that both birds might repeat (thematic agreement)
            const sharedEmoji1 = primarySet[Math.floor(Math.random() * primarySet.length)];
            const sharedEmoji2 = primarySet[Math.floor(Math.random() * primarySet.length)];

            // Create exchanges with better pacing and variety
            for (let i = 0; i < numExchanges; i++) {
                const currentBird = i % 2 === 0 ? bird1 : bird2;
                let emoji;

                // ENHANCED: Better conversation flow
                if (i === 0) {
                    // First exchange: introduce topic
                    emoji = sharedEmoji1;
                } else if (i === 1) {
                    // Second exchange: respond or question
                    if (Math.random() < 0.4) {
                        emoji = EMOJI_SETS.REACTIONS[Math.floor(Math.random() * EMOJI_SETS.REACTIONS.length)];
                    } else {
                        emoji = primarySet[Math.floor(Math.random() * primarySet.length)];
                    }
                } else if (i === numExchanges - 1) {
                    // Last exchange: conclusion or agreement
                    if (Math.random() < 0.5) {
                        emoji = sharedEmoji1; // Callback to original topic
                    } else {
                        emoji = EMOJI_SETS.REACTIONS[Math.floor(Math.random() * EMOJI_SETS.REACTIONS.length)];
                    }
                } else {
                    // Middle exchanges: mix of primary, secondary, reactions, and repetition
                    const roll = Math.random();
                    if (roll < 0.25 && i > 1) {
                        // Repeat for emphasis
                        emoji = sharedEmoji2;
                    } else if (roll < 0.4 && secondarySet) {
                        // Mix in secondary topic
                        emoji = secondarySet[Math.floor(Math.random() * secondarySet.length)];
                    } else if (roll < 0.6) {
                        // React
                        emoji = EMOJI_SETS.REACTIONS[Math.floor(Math.random() * EMOJI_SETS.REACTIONS.length)];
                    } else {
                        // Primary topic
                        emoji = primarySet[Math.floor(Math.random() * primarySet.length)];
                    }
                }

                exchanges.push({
                    bird: currentBird,
                    emoji: emoji,
                    timestamp: now + (i * 1500) // 1.5 seconds between each exchange
                });
            }

            emojiConversations.push({
                bird1: bird1,
                bird2: bird2,
                exchanges: exchanges,
                startTime: now,
                currentExchange: 0,
                type: conversationType
            });

            lastEmojiConversationTime = now;
            debugLog(`${conversationType} emoji conversation started between ${getBirdName(bird1)} and ${getBirdName(bird2)}!`);

            // RARE: After music conversation, birds perform a melody!
            if (triggerMelody) {
                const conversationDuration = numExchanges * 1500; // 1.5s per exchange
                setTimeout(() => {
                    playBirdMelody(bird1, bird2);
                }, conversationDuration + 500); // Wait for conversation to finish, then pause 0.5s
            }
        }

        // Get emoji based on bird's current state
        function getStateEmoji(bird) {
            // Check weather first
            if (isRaining) {
                return ['‚òî', 'üåßÔ∏è', 'üíß'][Math.floor(Math.random() * 3)];
            }

            // Check bird state
            switch(bird.state) {
                case BIRD_STATES.FEEDING:
                case BIRD_STATES.PECKING:
                    return ['üòã', 'üçΩÔ∏è', 'üåΩ'][Math.floor(Math.random() * 3)];
                case BIRD_STATES.SLEEPING:
                    return ['üò¥', 'üí§', 'ü•±'][Math.floor(Math.random() * 3)];
                case BIRD_STATES.FLEEING:
                    return ['üò∞', 'üò±', 'üí®'][Math.floor(Math.random() * 3)];
                case BIRD_STATES.BATHING:
                    return ['üí¶', 'üõÅ', '‚ú®'][Math.floor(Math.random() * 3)];
                case BIRD_STATES.DRINKING:
                    return ['üíß', 'ü•§', 'üí¶'][Math.floor(Math.random() * 3)];
                case BIRD_STATES.BUILDING:
                    return ['üèóÔ∏è', 'ü™π', 'üåø'][Math.floor(Math.random() * 3)];
                case BIRD_STATES.PERCHED:
                    return ['üéµ', 'üòä', 'üëÄ'][Math.floor(Math.random() * 3)];
                default:
                    return ['üòä', 'ü§î', 'üëç'][Math.floor(Math.random() * 3)];
            }
        }

        // Update and draw emoji conversations
        function updateEmojiConversations(now) {
            // Remove finished conversations
            emojiConversations = emojiConversations.filter(convo => {
                const lastExchange = convo.exchanges[convo.exchanges.length - 1];
                return now - lastExchange.timestamp < 2000; // Keep for 2 seconds after last exchange
            });

            // Draw active emoji exchanges
            emojiConversations.forEach(convo => {
                convo.exchanges.forEach(exchange => {
                    // Only show if it's time for this exchange
                    if (now >= exchange.timestamp && now - exchange.timestamp < 2000) {
                        const age = now - exchange.timestamp;
                        const progress = age / 2000;
                        const opacity = 1 - progress;
                        const floatUp = progress * 30;

                        ctx.save();
                        ctx.globalAlpha = opacity;

                        // Draw with white border (speech bubble style)
                        ctx.font = 'bold 28px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        const x = exchange.bird.x;
                        const y = exchange.bird.y - 20 - floatUp;

                        // White border/outline (thicker for speech bubble effect)
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 4;
                        ctx.strokeText(exchange.emoji, x, y);

                        // Draw emoji
                        ctx.fillText(exchange.emoji, x, y);

                        ctx.restore();
                    }
                });
            });

            // BONUS: Birds sometimes show state-based emojis (rare, individual expressions)
            // This is separate from conversations - just a bird expressing itself
            birds.forEach(bird => {
                if (!bird.lastEmojiTime) bird.lastEmojiTime = 0;

                // Very rare chance for a bird to show a state emoji (0.005% per frame)
                if (Math.random() < 0.00005 && now - bird.lastEmojiTime > 30000) {
                    const stateEmoji = getStateEmoji(bird);
                    bird.currentEmoji = stateEmoji;
                    bird.emojiTimestamp = now;
                    bird.lastEmojiTime = now;
                }

                // Draw bird's state emoji if active
                if (bird.currentEmoji && now - bird.emojiTimestamp < 2000) {
                    const age = now - bird.emojiTimestamp;
                    const progress = age / 2000;
                    const opacity = 1 - progress;
                    const floatUp = progress * 30;

                    ctx.save();
                    ctx.globalAlpha = opacity;

                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const x = bird.x;
                    const y = bird.y - 20 - floatUp;

                    // White border
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 4;
                    ctx.strokeText(bird.currentEmoji, x, y);

                    // Draw emoji
                    ctx.fillText(bird.currentEmoji, x, y);

                    ctx.restore();
                }
            });
        }

        // Draw visual music notes for chirps (accessibility feature for hearing impaired)
        function drawChirpMusicNotes(now) {
            activeChirps.forEach(chirp => {
                const age = now - chirp.timestamp;
                const maxAge = 2000;
                const progress = age / maxAge;

                // Fade out and float up
                const opacity = 1 - progress;
                const floatUp = progress * (mushroomMode ? 60 : 30); // Float higher in mushroom mode

                // Different note styles based on chirp type
                let noteSymbol = '‚ô™';
                let noteColor = '#000000';
                let noteSize = 20; // Increased by 25% from 16

                switch(chirp.type) {
                    case CHIRP_TYPES.SOCIAL:
                        noteSymbol = '‚ô™';
                        noteColor = '#4CAF50'; // Green
                        noteSize = 17.5; // Increased by 25% from 14
                        break;
                    case CHIRP_TYPES.FOOD_CALL:
                        noteSymbol = '‚ô´';
                        noteColor = '#FF9800'; // Orange
                        noteSize = 22.5; // Increased by 25% from 18
                        break;
                    case CHIRP_TYPES.CONTACT_CALL:
                        noteSymbol = '‚ô™';
                        noteColor = '#2196F3'; // Blue
                        noteSize = 15; // Increased by 25% from 12
                        break;
                    case CHIRP_TYPES.ALERT:
                        noteSymbol = '‚ô¨';
                        noteColor = '#F44336'; // Red
                        noteSize = 25; // Increased by 25% from 20
                        break;
                    case CHIRP_TYPES.TERRITORIAL:
                        noteSymbol = '‚ô©';
                        noteColor = '#9C27B0'; // Purple
                        noteSize = 20; // Increased by 25% from 16
                        break;
                    case CHIRP_TYPES.VICTORY:
                        noteSymbol = '‚ô´‚ô™';
                        noteColor = '#FFD700'; // Gold
                        noteSize = 25; // Increased by 25% from 20
                        break;
                }

                // Mushroom mode: MUCH larger notes with dynamic expansion
                if (mushroomMode) {
                    // Start at 2x size and expand to 4x, then shrink back
                    const expansionCurve = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
                    const sizeMultiplier = 2 + (expansionCurve * 2); // 2x to 4x to 2x
                    noteSize = noteSize * sizeMultiplier;

                    // Rainbow cycling color
                    const hue = (colorCycleTimer / 50 + chirp.timestamp / 100) % 360;
                    noteColor = `hsl(${hue}, 100%, 60%)`;
                }

                // Draw music note
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.font = `bold ${noteSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add wobble (more dramatic in mushroom mode)
                const wobbleAmount = mushroomMode ? 10 : 3;
                const wobble = Math.sin(age / 100) * wobbleAmount;

                // Rotation in mushroom mode
                if (mushroomMode) {
                    ctx.translate(chirp.x + wobble, chirp.y - 20 - floatUp);
                    ctx.rotate((progress * 360 * Math.PI) / 180); // Full rotation

                    // Draw white outline for better visibility
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeText(noteSymbol, 0, 0);

                    // Draw colored fill
                    ctx.fillStyle = noteColor;
                    ctx.fillText(noteSymbol, 0, 0);
                } else {
                    // Draw white outline for better visibility
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeText(noteSymbol, chirp.x + wobble, chirp.y - 20 - floatUp);

                    // Draw colored fill
                    ctx.fillStyle = noteColor;
                    ctx.fillText(noteSymbol, chirp.x + wobble, chirp.y - 20 - floatUp);
                }

                // Add glow effect (enhanced in mushroom mode)
                const glowIntensity = mushroomMode ? 15 : 5;
                if (chirp.intensity > 1 || mushroomMode) {
                    ctx.shadowColor = noteColor;
                    ctx.shadowBlur = glowIntensity * (chirp.intensity || 1);
                    if (mushroomMode) {
                        ctx.fillText(noteSymbol, 0, 0);
                    } else {
                        ctx.fillText(noteSymbol, chirp.x + wobble, chirp.y - 20 - floatUp);
                    }
                }

                ctx.restore();
            });
        }

        // Update and draw all elements
        // Weather Forecast System - ACCURATE minute-by-minute
        function generateWeatherForecast() {
            const currentTime = Date.now();

            nextWeatherEvents = [];

            // FIRST EMOJI: Current weather state (now)
            // Enhanced: Show moon at night, sun during day
            const isNightTime = timeOfDay >= 1; // Night is when timeOfDay >= 1
            if (isRaining) {
                nextWeatherEvents.push({
                    type: isThundering ? 'thunder' : 'rain',
                    icon: isThundering ? '‚õàÔ∏è' : 'üåßÔ∏è',
                    time: currentTime,
                    label: 'Now'
                });
            } else {
                nextWeatherEvents.push({
                    type: 'clear',
                    icon: isNightTime ? 'üåô' : '‚òÄÔ∏è', // Moon at night, sun during day
                    time: currentTime,
                    label: 'Now'
                });
            }

            // SECOND EMOJI: Weather in next 1 minute (+1 min)
            const oneMinuteFromNow = currentTime + 60000;
            // Calculate future time of day (+1 minute = 0.5 units in timeOfDay scale)
            const futureTimeOfDay1Min = (timeOfDay + 0.5) % 2;
            const isNightTime1Min = futureTimeOfDay1Min >= 1;

            if (window.nextScheduledRainTime && window.nextScheduledRainTime <= oneMinuteFromNow) {
                // Rain will start within next minute
                const willThunder = window.nextRainWillThunder || false;
                nextWeatherEvents.push({
                    type: willThunder ? 'thunder' : 'rain',
                    icon: willThunder ? '‚õàÔ∏è' : 'üåßÔ∏è',
                    time: oneMinuteFromNow,
                    label: '+1 min'
                });
            } else if (isRaining) {
                // Currently raining, check if it will continue
                if (window.rainStopTime && window.rainStopTime > oneMinuteFromNow) {
                    // Rain continues
                    nextWeatherEvents.push({
                        type: isThundering ? 'thunder' : 'rain',
                        icon: isThundering ? '‚õàÔ∏è' : 'üåßÔ∏è',
                        time: oneMinuteFromNow,
                        label: '+1 min'
                    });
                } else {
                    // Rain might stop - check future day/night
                    nextWeatherEvents.push({
                        type: 'clear',
                        icon: isNightTime1Min ? 'üåô' : '‚òÄÔ∏è',
                        time: oneMinuteFromNow,
                        label: '+1 min'
                    });
                }
            } else {
                // Clear weather continues - check future day/night for appropriate icon
                nextWeatherEvents.push({
                    type: 'clear',
                    icon: isNightTime1Min ? 'üåô' : '‚òÄÔ∏è',
                    time: oneMinuteFromNow,
                    label: '+1 min'
                });
            }

            // THIRD EMOJI: Weather in following minute (+2 min)
            const twoMinutesFromNow = currentTime + 120000;
            // Calculate future time of day (+2 minutes = 1.0 units in timeOfDay scale)
            const futureTimeOfDay2Min = (timeOfDay + 1.0) % 2;
            const isNightTime2Min = futureTimeOfDay2Min >= 1;

            if (window.nextScheduledRainTime && window.nextScheduledRainTime <= twoMinutesFromNow) {
                // Rain will start within next 2 minutes
                const willThunder = window.nextRainWillThunder || false;
                nextWeatherEvents.push({
                    type: willThunder ? 'thunder' : 'rain',
                    icon: willThunder ? '‚õàÔ∏è' : 'üåßÔ∏è',
                    time: twoMinutesFromNow,
                    label: '+2 min'
                });
            } else if (isRaining) {
                // Currently raining, check if it will continue
                if (window.rainStopTime && window.rainStopTime > twoMinutesFromNow) {
                    // Rain continues
                    nextWeatherEvents.push({
                        type: isThundering ? 'thunder' : 'rain',
                        icon: isThundering ? '‚õàÔ∏è' : 'üåßÔ∏è',
                        time: twoMinutesFromNow,
                        label: '+2 min'
                    });
                } else {
                    // Rain might stop - check future day/night
                    nextWeatherEvents.push({
                        type: 'clear',
                        icon: isNightTime2Min ? 'üåô' : '‚òÄÔ∏è',
                        time: twoMinutesFromNow,
                        label: '+2 min'
                    });
                }
            } else {
                // Clear weather continues - check future day/night
                nextWeatherEvents.push({
                    type: 'clear',
                    icon: isNightTime2Min ? 'üåô' : '‚òÄÔ∏è',
                    time: twoMinutesFromNow,
                    label: '+2 min'
                });
            }
        }

        // Draw large transparent clock in sky with forecast
        function drawClock() {
            if (!clockEnabled) return;

            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();

            // Format time (24-hour format)
            const hourStr = hours.toString().padStart(2, '0');
            const minuteStr = minutes.toString().padStart(2, '0');

            // Large transparent clock in upper sky - DOUBLED SIZE
            const clockY = canvas.height * 0.2;
            const clockCenterX = canvas.width / 2;

            // Subtle shadow for visibility
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Base opacity for clock
            const timeOpacity = mushroomMode ? 0.25 : 0.2;

            // Draw time - now MUCH LARGER (280px instead of 140px)
            const fontSize = 280;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Build the time string and draw each character individually
            const timeText = `${hourStr}:${minuteStr}`;

            // FIXED: Equal spacing between all characters for better alignment
            // Measure the widest character to ensure no overlap
            const singleDigitWidth = ctx.measureText('8').width; // '8' is typically widest digit
            const colonWidth = ctx.measureText(':').width;

            // Use consistent spacing for all characters based on the widest
            const maxCharWidth = Math.max(singleDigitWidth, colonWidth);
            const charSpacing = maxCharWidth * 1.6; // 60% extra space to prevent overlap

            // Total width of the clock display
            const totalWidth = charSpacing * (timeText.length - 1);

            // Start X position to center the entire time display
            const startTextX = clockCenterX - (totalWidth / 2);

            // Check which birds are perched on clock numbers
            const birdsOnClock = [];
            if (window.clockNumberPositions) {
                birds.forEach(bird => {
                    if (bird.perchTarget && bird.perchTarget.isClock) {
                        birdsOnClock.push({
                            birdX: bird.x,
                            birdY: bird.y
                        });
                    }
                });
            }

            // Store clock number positions for bird landing
            window.clockNumberPositions = [];

            // Store previous time for spook detection
            if (!window.previousClockTime) {
                window.previousClockTime = timeText;
            }

            // Draw each character with individual opacity based on bird presence
            for (let i = 0; i < timeText.length; i++) {
                const char = timeText[i];

                // FIXED: Equal spacing for all characters
                const charX = startTextX + (i * charSpacing);
                const charY = clockY;

                // Check if a bird is near this character
                let birdNearby = false;

                // Store position for perching (including colon!)
                window.clockNumberPositions.push({
                    x: charX,
                    y: clockY - fontSize * 0.35, // perch on top of numbers (35% above center for proper positioning)
                    width: charSpacing,
                    charIndex: i,
                    char: char,
                    isColon: char === ':'
                });

                // Check if any bird is perched on this character
                birdNearby = birdsOnClock.some(birdPos => {
                    const dist = Math.sqrt(
                        Math.pow(birdPos.birdX - charX, 2) +
                        Math.pow(birdPos.birdY - (clockY - fontSize * 0.35), 2)
                    );
                    return dist < charSpacing;
                });

                // Increase opacity if bird is nearby
                const charOpacity = birdNearby ? timeOpacity * 3 : timeOpacity; // 3x more opaque with bird
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(charOpacity, 0.7)})`; // cap at 0.7

                // Draw this character
                ctx.fillText(char, charX, charY);
            }

            // Detect time change and spook birds
            if (window.previousClockTime !== timeText) {
                // Time has changed! Spook any birds on the clock
                birds.forEach(bird => {
                    if (bird.perchTarget && bird.perchTarget.isClock) {
                        // Bird is on clock - get spooked!
                        bird.state = BIRD_STATES.FLEEING;
                        bird.stateTimer = 0;
                        bird.perchTarget = null;

                        // Fly away in random direction
                        const fleeX = bird.x + (Math.random() - 0.5) * 400;
                        const fleeY = bird.y - 100 - Math.random() * 100;
                        bird.generatePath(fleeX, fleeY);

                        debugLog(`Bird spooked by clock change! ${window.previousClockTime} -> ${timeText}`);
                    }
                });
                window.previousClockTime = timeText;
            }

            // Draw weather forecast icons below clock - CENTERED
            const forecastY = clockY + 180;
            const iconSpacing = 120; // Spacing between icons
            // Center 3 icons: place middle icon at center, others at ¬±iconSpacing
            const startX = clockCenterX - iconSpacing; // First icon left of center

            ctx.font = '60px Arial'; // Slightly larger icons
            ctx.shadowBlur = 5;

            for (let i = 0; i < Math.min(3, nextWeatherEvents.length); i++) {
                const event = nextWeatherEvents[i];
                const x = startX + (i * iconSpacing);

                // Draw icon with slight transparency
                ctx.fillStyle = `rgba(255, 255, 255, ${timeOpacity * 1.2})`;
                ctx.fillText(event.icon, x, forecastY);
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        // Update forecast periodically
        let lastForecastUpdate = 0;
        function updateWeatherForecast() {
            const now = Date.now();
            if (now - lastForecastUpdate > 60000) { // Update every minute
                generateWeatherForecast();
                lastForecastUpdate = now;
            }
        }

        // ===== GARDEN DIARY SYSTEM =====

        // Add a diary entry
        function addDiaryEntry(event, type = 'general') {
            const entry = {
                day: dayNightCycleCount,
                event: event,
                timestamp: Date.now(),
                type: type
            };
            diaryEntries.push(entry);

            // Keep only last 50 entries
            if (diaryEntries.length > 50) {
                diaryEntries.shift();
            }

            updateDiaryDisplay();
            debugLog(`Diary: ${event}`);
        }

        // Get or assign a name to a bird
        function getBirdName(bird) {
            if (!birdFamilies.has(bird.id)) {
                // This is a new bird, assign a name
                const baseName = BIRD_NAME_POOL[Math.floor(Math.random() * BIRD_NAME_POOL.length)];

                // Check if name is already used, add suffix if needed
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(birdFamilies.values()).map(f => f.name);

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                birdFamilies.set(bird.id, {
                    name: finalName,
                    generation: 1,
                    parents: null,
                    birdType: bird.birdType.name
                });
            }

            // FIXED: Defensive property access to prevent undefined errors
            const entry = birdFamilies.get(bird.id);
            return entry ? entry.name : 'Unknown Bird';
        }

        // Get or assign a name to a squirrel
        function getSquirrelName(squirrel) {
            if (!squirrelFamilies.has(squirrel.id)) {
                // This is a new squirrel, assign a name
                const baseName = SQUIRREL_NAME_POOL[Math.floor(Math.random() * SQUIRREL_NAME_POOL.length)];

                // Check if name is already used, add suffix if needed
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(squirrelFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                squirrelFamilies.set(squirrel.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return squirrelFamilies.get(squirrel.id) || 'Unknown Squirrel';
        }

        // Get or assign a name to a rat
        function getRatName(rat) {
            if (!ratFamilies.has(rat.id)) {
                // This is a new rat, assign a name
                const baseName = RAT_NAME_POOL[Math.floor(Math.random() * RAT_NAME_POOL.length)];

                // Check if name is already used, add suffix if needed
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(ratFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                // Rat Kings get a crown prefix
                if (rat.isRatKing) {
                    finalName = `King ${finalName}`;
                }

                ratFamilies.set(rat.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return ratFamilies.get(rat.id) || 'Unknown Rat';
        }

        // Get or assign a name to a crow
        function getCrowName(crow) {
            if (!crowFamilies.has(crow.id)) {
                const baseName = CROW_NAME_POOL[Math.floor(Math.random() * CROW_NAME_POOL.length)];
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(crowFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                crowFamilies.set(crow.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return crowFamilies.get(crow.id) || 'Unknown Crow';
        }

        // Get or assign a name to an owl
        function getOwlName(owl) {
            if (!owlFamilies.has(owl.id)) {
                const baseName = OWL_NAME_POOL[Math.floor(Math.random() * OWL_NAME_POOL.length)];
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(owlFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                owlFamilies.set(owl.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return owlFamilies.get(owl.id) || 'Unknown Owl';
        }

        // Get or assign a name to a tree
        function getTreeName(tree) {
            if (!treeFamilies.has(tree.id)) {
                const baseName = TREE_NAME_POOL[Math.floor(Math.random() * TREE_NAME_POOL.length)];
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(treeFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                treeFamilies.set(tree.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return treeFamilies.get(tree.id) || 'Unknown Tree';
        }

        // Get name for a frog
        function getFrogName(frog) {
            if (!frogFamilies.has(frog.id)) {
                const baseName = FROG_NAME_POOL[Math.floor(Math.random() * FROG_NAME_POOL.length)];
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(frogFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                frogFamilies.set(frog.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return frogFamilies.get(frog.id) || 'Unknown Frog';
        }

        // Get name for a koi
        function getKoiName(koiFish) {
            if (!koiFamilies.has(koiFish.id)) {
                const baseName = KOI_NAME_POOL[Math.floor(Math.random() * KOI_NAME_POOL.length)];
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(koiFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                koiFamilies.set(koiFish.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return koiFamilies.get(koiFish.id) || 'Unknown Koi';
        }

        // Get name for an ant
        function getAntName(ant) {
            if (!antFamilies.has(ant.id)) {
                const baseName = ANT_NAME_POOL[Math.floor(Math.random() * ANT_NAME_POOL.length)];
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(antFamilies.values());

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                antFamilies.set(ant.id, finalName);
            }

            // FIXED: Defensive property access to prevent undefined errors
            return antFamilies.get(ant.id) || 'Unknown Ant';
        }

        // General function to get name for any animal type
        function getAnimalName(animal, type) {
            if (type === 'bird') return getBirdName(animal);
            if (type === 'squirrel') return getSquirrelName(animal);
            if (type === 'rat') return getRatName(animal);
            if (type === 'crow') return getCrowName(animal);
            if (type === 'owl') return getOwlName(animal);
            if (type === 'tree') return getTreeName(animal);
            if (type === 'frog') return getFrogName(animal);
            if (type === 'koi') return getKoiName(animal);
            if (type === 'ant') return getAntName(animal);
            return 'Unknown';
        }

        // Convert state to readable action text
        function getReadableAction(state, entityType) {
            if (!state) return "Resting";

            // Handle tree special case
            if (entityType === 'tree') {
                return "Growing";
            }

            // State to readable action mapping
            const actionMap = {
                'idle': 'Resting',
                'perched': 'Perching',
                'hunting': 'Hunting',
                'collecting': 'Collecting',
                'building': 'Building',
                'feeding': 'Feeding',
                'fleeing': 'Fleeing',
                'sheltering': 'Sheltering',
                'resting': 'Resting',
                'bathing': 'Bathing',
                'flying': 'Flying',
                'building_birdhouse': 'Building a Home',
                'hopping': 'Hopping',
                'sentinel': 'Standing Guard',
                'mobbing': 'Mobbing',
                'pecking': 'Pecking',
                'territorial_display': 'Showing Dominance',
                'fleeing_ground': 'Escaping',
                'preening': 'Preening',
                'sunbathing': 'Sunbathing',
                'dust_bathing': 'Dust Bathing',
                'stretching': 'Stretching',
                'scratching': 'Scratching',
                'head_bobbing': 'Bobbing Head',
                'tail_wagging': 'Wagging Tail',
                'wing_flapping': 'Flapping Wings',
                'courtship_display': 'Courting',
                'nest_sitting': 'Sitting on Nest',
                'foraging': 'Foraging',
                'caching': 'Hiding Food',
                'anting': 'Anting',
                'investigating': 'Investigating',
                'socializing': 'Socializing',
                'singing': 'Singing',
                // Squirrel states
                'climbing': 'Climbing',
                'wandering': 'Wandering',
                'eating': 'Eating',
                // Rat states
                'scavenging': 'Scavenging',
                // Crow states
                'leaving': 'Leaving',
                // Owl states
                'roosting': 'Roosting',
                'watching': 'Watching'
            };

            return actionMap[state] || state.charAt(0).toUpperCase() + state.slice(1);
        }

        // Register a baby bird with parents
        function registerBabyBird(baby, parent) {
            if (!baby || !parent) return;

            const parentInfo = birdFamilies.get(parent.id);
            if (!parentInfo) {
                // Parent doesn't have a name yet, give them one
                getBirdName(parent);
            }

            const parentData = birdFamilies.get(parent.id);
            const baseName = parentData.name.split(' ')[0]; // Get base name without suffix
            const generation = parentData.generation + 1;

            // Create generational name
            let babyName = baseName;
            if (generation === 2) {
                babyName = `${baseName} Jr.`;
            } else if (generation > 2) {
                // Use roman numerals for generation 3+
                const romanNumerals = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];
                babyName = `${baseName} ${romanNumerals[Math.min(generation, 10)]}`;
            }

            birdFamilies.set(baby.id, {
                name: babyName,
                generation: generation,
                parents: [parentData.name],
                birdType: baby.birdType.name
            });

            return babyName;
        }

        // Update diary display
        function updateDiaryDisplay() {
            const diaryEntriesDiv = document.getElementById('diaryEntries');
            const birdFamiliesDiv = document.getElementById('birdFamilies');
            const diaryDayCount = document.getElementById('diaryDayCount');

            if (!diaryEntriesDiv) return;

            // Update day count
            if (diaryDayCount) {
                diaryDayCount.textContent = dayNightCycleCount;
            }

            // Update diary entries (newest first)
            if (diaryEntries.length > 0) {
                let entriesHTML = '';
                const sortedEntries = [...diaryEntries].reverse();

                sortedEntries.forEach(entry => {
                    const icon = entry.type === 'birth' ? 'üê£' :
                                entry.type === 'nest' ? 'üè†' :
                                entry.type === 'weather' ? '‚õàÔ∏è' :
                                entry.type === 'visitor' ? 'ü¶Ö' :
                                entry.type === 'special' ? '‚ú®' :
                                entry.type === 'milestone' ? 'üéØ' : 'üìù';

                    entriesHTML += `<p style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                        ${icon} <strong>Day ${entry.day}:</strong> ${entry.event}
                    </p>`;
                });

                diaryEntriesDiv.innerHTML = entriesHTML;
            }

            // Update bird families
            if (birdFamiliesDiv && birdFamilies.size > 0) {
                let familiesHTML = '';
                const familyGroups = new Map();

                // Group birds by base name
                for (const [id, info] of birdFamilies.entries()) {
                    const baseName = info.name.split(' ')[0];
                    if (!familyGroups.has(baseName)) {
                        familyGroups.set(baseName, []);
                    }
                    familyGroups.get(baseName).push(info);
                }

                // Display families and individual birds
                for (const [baseName, members] of familyGroups.entries()) {
                    if (members.length > 1) {
                        // This is a lineage
                        const sorted = members.sort((a, b) => a.generation - b.generation);
                        familiesHTML += `<div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                            <strong>The ${baseName} Family</strong> (${sorted[0].birdType})
                            <ul style="margin: 5px 0; padding-left: 20px; font-size: 0.9em;">`;

                        sorted.forEach(member => {
                            const genText = member.generation === 1 ? '(Founder)' :
                                          member.generation === 2 ? '(Child)' :
                                          `(Gen ${member.generation})`;
                            familiesHTML += `<li>${member.name} ${genText}</li>`;
                        });

                        familiesHTML += `</ul></div>`;
                    } else {
                        // Enhanced: Show individual birds (including starting birds)
                        const bird = members[0];
                        familiesHTML += `<div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                            <strong>${bird.name}</strong> (${bird.birdType}) - Solo Bird
                        </div>`;
                    }
                }

                if (familiesHTML) {
                    birdFamiliesDiv.innerHTML = familiesHTML;
                } else {
                    birdFamiliesDiv.innerHTML = '<p style="color: #999; font-style: italic;">Bird lineages will appear as families grow...</p>';
                }
            }
        }

        function updateAndDraw(timestamp) {
    if (!animationRunning) return;

    // Calculate delta time with a max to prevent large jumps
    const now = Date.now();
    let deltaTime = Math.min(100, now - lastTime);
    lastTime = now;

    // FPS Monitoring - calculate current FPS
    fpsFrames.push(now);
    // Keep only frames from the last second
    fpsFrames = fpsFrames.filter(time => now - time < 1000);
    currentFPS = fpsFrames.length;

    // Performance warning if FPS drops below 25 for more than 2 seconds
    if (currentFPS < 25 && now - lastFPSWarningTime > 5000) {
        console.warn(`Performance warning: FPS dropped to ${currentFPS}. Consider disabling mushroom mode or closing some entities.`);
        lastFPSWarningTime = now;

        // Auto-reduce trail points in mushroom mode if FPS is very low
        if (mushroomMode && currentFPS < 20) {
            // Reduce trail density
            for (const bird of birds) {
                if (bird.trailPoints && bird.trailPoints.length > 20) {
                    bird.trailPoints = bird.trailPoints.slice(-20);
                }
            }
            debugLog("Auto-reduced trail points due to low FPS");
        }
    }

    // Update simulation time
    simulationTime += deltaTime;

// Update color cycling for mushroom mode
if (mushroomMode) {
        colorCycleTimer += deltaTime;
    }

    // Update weather forecast on the minute (every 60 seconds)
    if (!window.lastForecastUpdate) {
        window.lastForecastUpdate = now;
        generateWeatherForecast();
    }
    const timeSinceLastForecastUpdate = now - window.lastForecastUpdate;
    if (timeSinceLastForecastUpdate >= 60000) { // 60 seconds = 1 minute
        generateWeatherForecast();
        window.lastForecastUpdate = now;
        debugLog("Weather forecast updated (on the minute)");
    }

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update day/night cycle
    updateDayNightCycle(deltaTime);

    // Update rainbow if active
    updateRainbow(deltaTime);
    
    // Check for conditions for rainbow
    if (wasRaining && !isRaining) {
        checkForRainbow();
    }
    
    // ADD THIS LINE RIGHT HERE after rainbow checks:
    // Check for magic mushroom spawning
    checkForMagicMushroom();

    // Check for scarecrow creation
    checkForScarecrow();

    // Update scarecrow animation
    updateScarecrow(deltaTime);

    // ===== CAMERA SYSTEM =====
    // Update camera for locked animal with smooth zoom
    // FIXED: Disable zoom when tree is locked to prevent floating/whitespace issues
    const targetZoom = (lockedAnimal && lockedAnimalType !== 'tree') ? 1.5 : 1.0;
    const zoomSpeed = 0.05; // Smooth interpolation
    cameraZoom += (targetZoom - cameraZoom) * zoomSpeed;

    // Calculate camera offset to center on locked animal
    if (lockedAnimal) {
        // Center bird at 40% from top (looks better than exact center)
        const targetOffsetX = canvas.width / 2 - lockedAnimal.x * cameraZoom;
        const targetOffsetY = canvas.height * 0.4 - lockedAnimal.y * cameraZoom;
        const panSpeed = 0.1; // Smooth panning
        cameraOffsetX += (targetOffsetX - cameraOffsetX) * panSpeed;
        cameraOffsetY += (targetOffsetY - cameraOffsetY) * panSpeed;

        // FIXED: Increase vertical limit to allow better centering of low birds
        // Don't let camera pan too far from center to keep ground/sky visible
        const maxOffsetY = canvas.height * 0.5; // Increased from 0.3 for better centering
        cameraOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, cameraOffsetY));
    } else {
        // Return to normal view
        const returnSpeed = 0.05;
        cameraOffsetX += (0 - cameraOffsetX) * returnSpeed;
        cameraOffsetY += (0 - cameraOffsetY) * returnSpeed;
    }

    // ===== BACKGROUND LAYER =====
    // Draw the sky background with day/night changes (unaffected by camera)
    drawSky();

    // FIXED: Draw migration in far background (before camera transform)
    attemptMigrationWave();
    updateMigrationWave(deltaTime);
    drawMigrationWave();

    // Save context and apply camera transformations
    ctx.save();
    ctx.translate(cameraOffsetX, cameraOffsetY);
    ctx.scale(cameraZoom, cameraZoom);

    // Draw ground layer (moves with camera to prevent floating effect)
    drawGround();

    // Draw rainbow if visible (behind most elements)
    if (rainbowVisible) {
        drawRainbow();
    }

    // Draw curtains (if enabled)
    if (showCurtains) {
        drawCurtains();
    }

    // ===== MIDDLE GROUND LAYER =====
    // Draw trees in proper depth order (back to front)
    drawTrees(deltaTime);

    // Update and draw bushes (sorted by depth for proper layering)
    bushes.sort((a, b) => b.depth - a.depth); // Back to front
    bushes.forEach(bush => {
        bush.update();
        bush.draw();
    });

    // Update and draw tall grass patches
    tallGrassPatches.forEach(grass => {
        grass.update(deltaTime, timeOfDay);
        grass.draw();
    });

    // Draw decorative stones/rocks
    stones.forEach(stone => {
        stone.draw();
    });

    // Draw puddles under everything else
    updatePuddles(deltaTime);
    drawPuddles();

    // Update and draw ponds, frogs, and koi
    updatePonds(deltaTime);
    drawPonds();
    updateKoi(deltaTime);
    drawKoi();
    updateFrogs(deltaTime);
    drawFrogs();

    // Draw ground elements
    drawTwigs();
    drawFlowers();
    drawMagicMushroom();
    updateMushroomClusters(deltaTime);
    drawMushroomClusters();
    updateFoodCaches(deltaTime);
    drawFood(deltaTime);
    drawBirdPoops(deltaTime);
    drawWorms();

    // ===== BUILT STRUCTURES LAYER =====
    // Draw birdhouses (they should be behind nests)
    for (const birdhouse of birdhouses) {
        birdhouse.draw();
    }

    // Update and draw nests (they should be on trees but behind birds)
    for (let i = nests.length - 1; i >= 0; i--) {
        const nest = nests[i];
        nest.update(deltaTime);

        // Remove completely degraded nests (condition 0 and very few materials)
        if (nest.condition <= 0 && nest.materialsCollected < 3) {
            debugLog(`Fully degraded nest removed at (${nest.x}, ${nest.y})`);
            nests.splice(i, 1);
            continue;
        }

        nest.draw();
    }

    // Update and draw wind chimes (hang from trees, drawn after nests)
    updateWindChimes(deltaTime);
    drawWindChimes();

    // Draw scarecrow (behind moving animals)
if (mushroomMode) {
    drawMushroomScarecrow();
} else {
    drawScarecrow(); // Original scarecrow drawing
}

    // Update and draw ant hill and ants
updateAnts(deltaTime);
drawAnts();

    // ===== ANIMALS LAYER =====
    // Draw rats (usually on ground level)
    for (let i = rats.length - 1; i >= 0; i--) {
        const remove = rats[i].update(deltaTime);
        if (remove) {
            rats.splice(i, 1);
        } else {
            rats[i].draw();
        }
    }

    // Draw squirrels 
    for (let i = squirrels.length - 1; i >= 0; i--) {
        const remove = squirrels[i].update(deltaTime);
        if (remove) {
            squirrels.splice(i, 1);
        } else {
            squirrels[i].draw();
        }
    }
    
    // NEW: Update and draw eggs (hatch into baby birds after 1-2 days)
    for (let i = eggs.length - 1; i >= 0; i--) {
        const egg = eggs[i];
        const readyToHatch = egg.update(deltaTime);

        if (readyToHatch) {
            // EGG HATCHES! Create baby bird
            const baby = new BabyBird(egg.x, egg.y, egg.birdType, egg.associatedNest);
            babyBirds.push(baby);

            // Remove the egg
            eggs.splice(i, 1);

            debugLog(`Egg hatched into baby bird at (${baby.x}, ${baby.y})!`);
            addDiaryEntry(`An egg has hatched! A new baby bird joins the garden.`, 'birth');

            // Alert birds to feed the new baby
            setTimeout(() => alertBirdsToFeedBaby(baby), 1000);
        } else {
            egg.draw();
        }
    }

    // Update and draw baby birds
    for (let i = babyBirds.length - 1; i >= 0; i--) {
        const remove = babyBirds[i].update(deltaTime);
        if (remove) {
            babyBirds.splice(i, 1);
        } else {
            babyBirds[i].draw();
        }
    }

    // Update stuck birds logic
    resetStuckBirds();
    
    // Update and draw birds (they should be above most elements)
    for (let i = birds.length - 1; i >= 0; i--) {
        const remove = birds[i].update(deltaTime);
        if (remove) {
            // Remove from any occupied birdhouse
            for (const birdhouse of birdhouses) {
                birdhouse.removeOccupant(birds[i]);
            }
            birds.splice(i, 1);
        } else {
            birds[i].draw();
        }
    }


// ADD updateBirdTrails() RIGHT HERE, just after the birds loop üëá
updateBirdTrails();

drawBirdTrails();

    // Update and draw butterflies
    for (let i = butterflies.length - 1; i >= 0; i--) {
        const remove = butterflies[i].update(deltaTime);
        if (remove) {
            butterflies.splice(i, 1);
        } else {
            butterflies[i].draw();
        }
    }

    // Update and draw fireflies (night only)
    updateFireflies(deltaTime);
    drawFireflies();

    // Update and draw UFO encounters
    attemptUFOSpawn();
    updateUFO(deltaTime);
    updateBeamedEntities();
    drawUFO();

    // Update and draw special events
    attemptMeteorShower();
    updateMeteorShower(deltaTime);
    drawMeteorShower();

    attemptEclipse();
    updateEclipse(deltaTime);
    drawEclipse();

    // Migration wave moved to background layer (after drawSky)

// Update and draw gameboy
updateGameboy(deltaTime);



    // Update and draw owls
for (let i = owls.length - 1; i >= 0; i--) {
    const remove = owls[i].update(deltaTime);
    if (remove) {
        owls.splice(i, 1);
    } else {
        owls[i].draw();
    }
}
    
    // Check and update crow visit logic
    checkForCrowVisit(deltaTime);

    // Update and draw crows (they should be on top of birds)
    for (let i = crows.length - 1; i >= 0; i--) {
        const remove = crows[i].update(deltaTime);
        if (remove) {
            crows.splice(i, 1);
        } else {
            crows[i].draw();
        }
    }

    // ===== WEATHER/EFFECTS LAYER (always on top) =====
    // Draw rain if raining
    if (isRaining) {
        drawRain(deltaTime);
    }

    // Draw lightning strikes if present
    updateLightningStrikes(deltaTime);
    drawLightningStrikes();

    // Draw special effects
    drawSpecialEffects(deltaTime);

    // ===== CLOCK AND FORECAST LAYER =====
    // Update and draw clock if enabled
    if (clockEnabled) {
        updateWeatherForecast();
        drawClock();
        checkHourlyChime(); // Check if it's a new hour and play melody
    }

    // ===== DEBUG LAYER (very top) =====
    // Draw off-screen indicators in debug mode
    drawOffscreenIndicators();

    // Draw debug visuals after everything else
    drawDebugVisuals();

    // ===== BIRD INTERACTION UI LAYER (top) =====
    drawBirdInteractionUI();

    // ===== PERIODIC UPDATES =====
    // Do periodic spawning and checks
    if (simulationTime % TWIG_SPAWN_RATE < 16) {
        spawnTwigs();
    }
    
    if (simulationTime % BIRD_SPAWN_RATE < 16) { 
        if (birds.length < MAX_BIRDS && dayNightCycleCount > 0) {
            spawnBird();
            debugLog(`Scheduled bird spawning check - current count: ${birds.length}`);
        }
    }

    if (simulationTime % 15000 < 16) {
        if (timeOfDay >= 1) { // It's night time
            spawnNightWorms();
        }
    }

    if (simulationTime % 15000 < 16) {
    spawnOwls();
}

    if (simulationTime % 30000 < 16) {
        const currentTime = Date.now();
        for (const nest of nests) {
            nest.checkReadyForNewBabies(currentTime);
        }
    }

    if (simulationTime % 3000 < 16) {
        checkAndAlertForHungryBabies();
    }

    if (simulationTime % WILD_BIRD_SPAWN_RATE < 16) {
        spawnWildBird();
    }

    if (simulationTime % WORM_SPAWN_RATE < 16) {
        spawnWorms();
    }

    if (simulationTime % 5000 < 16) {
        spawnSquirrels();
    }

    if (simulationTime % 8000 < 16) {
        spawnRats();
    }

    if (simulationTime % 5000 < 16) {
        spawnButterflies();
    }

    if (simulationTime % TREE_REGROWTH_RATE < 16) {
        regrowTrees();
    }

    // === NEW BEHAVIOR SYSTEM UPDATES ===
    // Process synchronized chirping (reuse 'now' from line 13091)
    activeChirps = activeChirps.filter(chirp => now - chirp.timestamp < 2000); // Keep chirps for 2 seconds

    // EMOJI CONVERSATIONS: Check if we should start a new conversation (very rare!)
    if (Math.random() < 0.0001 && birds.length >= 2) { // 0.01% chance per frame (~once every 2-4 minutes)
        startEmojiConversation();
    }

    // Update and draw emoji conversations
    updateEmojiConversations(now);

    // Draw visual music notes for chirps (accessibility feature)
    drawChirpMusicNotes(now);

    // Synchronized chirping - social chirps trigger nearby birds to chirp
    if (activeChirps.length > 0 && Math.random() < 0.05) {
        const recentChirps = activeChirps.filter(c =>
            c.type === CHIRP_TYPES.SOCIAL && now - c.timestamp < 500
        );

        recentChirps.forEach(chirp => {
            // Find nearby birds to potentially trigger
            const nearbyBirds = birds.filter(b =>
                distance(b.x, b.y, chirp.x, chirp.y) < 150 &&
                b.id !== chirp.birdId &&
                !b.defeatedRecently
            );

            nearbyBirds.forEach(bird => {
                // 10% chance to chirp in response (cascade effect)
                if (Math.random() < 0.1 && now - bird.lastChirp > 2000) {
                    bird.chirp(CHIRP_TYPES.SOCIAL, 0.6);
                }
            });
        });
    }

    // Clean up old danger zones
    dangerZones = dangerZones.filter(d => now - d.timestamp < DANGER_MEMORY_DURATION);

    // Clean up old shared food knowledge
    sharedFoodKnowledge = sharedFoodKnowledge.filter(f => now - f.timestamp < FOOD_KNOWLEDGE_DURATION);

    // Clean up completed mobbings
    activeMobbings = activeMobbings.filter(m => now - m.startTime < MOBBING_DURATION);

    // Clean up old territorial disputes
    territorialDisputes = territorialDisputes.filter(d => now - d.startTime < 10000);

    // MEMORY LEAK PREVENTION: Comprehensive array cleanup to prevent night crashes
    // Clean up old fireflies (should be removed at dawn anyway)
    if (fireflies.length > 100) {
        fireflies = fireflies.slice(0, 100);
        debugLog("MEMORY: Fireflies array capped at 100", DEBUG_LEVELS.WARNING);
    }

    // Clean up old food (prevent accumulation)
    if (foodItems.length > 200) {
        foodItems = foodItems.filter(f => now - f.spawnTime < 60000).slice(0, 200);
        debugLog("MEMORY: Food array cleaned and capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old stars (shouldn't grow but safety check)
    if (stars.length > 300) {
        stars = stars.slice(0, 300);
        debugLog("MEMORY: Stars array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old puddles
    if (puddles.length > 50) {
        puddles = puddles.slice(0, 50);
        debugLog("MEMORY: Puddles array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old worms
    if (worms.length > 100) {
        worms = worms.slice(0, 100);
        debugLog("MEMORY: Worms array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old ants
    if (ants.length > 150) {
        ants = ants.slice(0, 150);
        debugLog("MEMORY: Ants array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old butterflies
    if (butterflies.length > 30) {
        butterflies = butterflies.slice(0, 30);
        debugLog("MEMORY: Butterflies array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old twigs
    if (twigs.length > 80) {
        twigs = twigs.slice(0, 80);
        debugLog("MEMORY: Twigs array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old flowers
    if (flowers.length > 100) {
        flowers = flowers.slice(0, 100);
        debugLog("MEMORY: Flowers array capped", DEBUG_LEVELS.WARNING);
    }

    // Clean up old food caches
    if (foodCaches.length > 50) {
        foodCaches = foodCaches.filter(c => now - c.createdAt < 259200000); // 3 days
        if (foodCaches.length > 50) {
            foodCaches = foodCaches.slice(0, 50);
        }
        debugLog("MEMORY: Food caches cleaned", DEBUG_LEVELS.WARNING);
    }

    // Clean up old mushroom clusters
    if (mushroomClusters.length > 20) {
        mushroomClusters = mushroomClusters.slice(0, 20);
        debugLog("MEMORY: Mushroom clusters capped", DEBUG_LEVELS.WARNING);
    }

    // Safety cap on birds (prevent runaway spawning)
    if (birds.length > 50) {
        birds = birds.slice(0, 50);
        debugLog("MEMORY: Birds array capped at 50", DEBUG_LEVELS.WARNING);
    }

    // Safety cap on rats
    if (rats.length > 30) {
        rats = rats.slice(0, 30);
        debugLog("MEMORY: Rats array capped", DEBUG_LEVELS.WARNING);
    }

    // Safety cap on owls
    if (owls.length > 10) {
        owls = owls.slice(0, 10);
        debugLog("MEMORY: Owls array capped", DEBUG_LEVELS.WARNING);
    }

    if (simulationTime % GUARANTEED_TREE_CHECK_RATE < 16) {
        checkEcosystemHealth();
    }

    if (simulationTime % BRANCH_GROWTH_INTERVAL < 16 && Math.random() < 0.5) {
        // Find a healthy tree to add a branch to
        const healthyTrees = trees.filter(tree => tree.health > 70 && tree.branches.length < 5);
        if (healthyTrees.length > 0) {
            const randomTree = healthyTrees[Math.floor(Math.random() * healthyTrees.length)];
            addBranchToTree(randomTree);
        }
    }

    // Update stats once per second
    if (now - lastStatsUpdate > 1000) {
        updateStats();
        lastStatsUpdate = now;
    }

    // Update advanced debug if enabled
    updateAdvancedDebug(deltaTime);

    // Restore canvas state after camera transformations
    ctx.restore();

    // Request next frame
    requestAnimationFrame(updateAndDraw);
}


// Add this new function for taking screenshots
function takeScreenshot() {
    console.log("Screenshot button clicked - function called");

    try {
        console.log("Starting screenshot process...");

        // Temporarily hide the info panel for the screenshot
        const infoPanel = document.getElementById('infoPanel');
        const wasVisible = infoPanel && infoPanel.style.display !== 'none';
        console.log("Info panel visible:", wasVisible);

        if (wasVisible) infoPanel.style.display = 'none';

        // Hide debug visuals temporarily if they're showing
        const debugActive = debugVisuals;
        if (debugActive) {
            console.log("Temporarily disabling debug visuals");
            debugVisuals = false;
        }

        // Redraw the canvas without these elements
        console.log("Drawing full scene for screenshot...");
        drawFullScene();

        console.log("Converting canvas to data URL...");
        // Convert canvas to data URL
        const dataUrl = canvas.toDataURL('image/png');
        console.log("Data URL created, length:", dataUrl.length);

        // Create a link element and trigger download
        console.log("Creating download link...");
        const link = document.createElement('a');
        const filename = `garden-view-${new Date().toISOString().slice(0,10)}.png`;
        link.download = filename;
        link.href = dataUrl;
        link.style.display = 'none';

        console.log("Appending link and triggering download...");
        document.body.appendChild(link);
        link.click();

        // Use timeout to ensure download starts before cleanup
        setTimeout(() => {
            document.body.removeChild(link);
            console.log("Link removed from DOM");
        }, 100);

        // Show a message
        const message = document.getElementById('screenshotMessage');
        if (message) {
            console.log("Showing screenshot message");
            message.style.display = 'block';
            setTimeout(() => {
                message.style.display = 'none';
            }, 2000);
        } else {
            console.warn("Screenshot message element not found");
        }

        // Restore the info panel if it was visible
        if (wasVisible && infoPanel) {
            infoPanel.style.display = 'block';
        }

        // Restore debug visuals if they were active
        if (debugActive) {
            debugVisuals = true;
        }

        console.log("Screenshot process completed successfully");
        debugLog("Screenshot taken and saved");
    } catch (e) {
        console.error("Error taking screenshot:", e);
        console.error("Error stack:", e.stack);
        alert("Error taking screenshot: " + e.message);
    }
}

// Helper function to draw the full scene for the screenshot
function drawFullScene() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ===== BACKGROUND LAYER =====
    drawSky();

    // Draw migration in far background (before camera transform)
    drawMigrationWave();

    // Save context and apply camera transformations for proper positioning
    ctx.save();
    ctx.translate(cameraOffsetX, cameraOffsetY);
    ctx.scale(cameraZoom, cameraZoom);

    drawGround();

    // Draw rainbow if visible
    if (rainbowVisible) {
        drawRainbow();
    }

    if (showCurtains) {
        drawCurtains();
    }

    // ===== MIDDLE GROUND LAYER =====
    // Draw trees in depth order
    const sortedTrees = [...trees].sort((a, b) => b.depth - a.depth);
    for (const tree of sortedTrees) {
        tree.draw();
    }

    // Draw bushes sorted by depth for proper layering
    const sortedBushes = [...bushes].sort((a, b) => b.depth - a.depth);
    for (const bush of sortedBushes) {
        bush.draw();
    }

    // Draw tall grass patches
    for (const grass of tallGrassPatches) {
        grass.draw();
    }

    // Draw decorative stones
    for (const stone of stones) {
        stone.draw();
    }

    // Draw puddles
    drawPuddles();

    // Draw ponds, frogs, and koi
    drawPonds();
    drawKoi();
    drawFrogs();

    // Draw ground elements
    drawTwigs();
    drawFlowers();
    drawMagicMushroom();
    drawMushroomClusters();
    drawFood(0);
    drawBirdPoops(0);
    drawWorms();

    // ===== BUILT STRUCTURES LAYER =====
    // Draw birdhouses
    for (const birdhouse of birdhouses) {
        birdhouse.draw();
    }

    // Draw nests
    for (const nest of nests) {
        nest.draw();
    }

    // Draw wind chimes
    drawWindChimes();

    // Draw scarecrow
    if (mushroomMode) {
        drawMushroomScarecrow();
    } else {
        drawScarecrow();
    }

    // Draw ant hill and ants
    if (antHill) {
        drawAnts();
    }

    // ===== ANIMALS LAYER =====
    // Draw rats
    for (const rat of rats) {
        rat.draw();
    }

    // Draw squirrels
    for (const squirrel of squirrels) {
        squirrel.draw();
    }

    // Draw baby birds
    for (const baby of babyBirds) {
        baby.draw();
    }

    // Draw birds
    for (const bird of birds) {
        bird.draw();
    }

    // Draw bird trails (mushroom mode)
    if (mushroomMode) {
        drawBirdTrails();
    }

    // Draw butterflies
    for (const butterfly of butterflies) {
        butterfly.draw();
    }

    // Draw fireflies
    drawFireflies();

    // Draw UFO and beamed entities
    drawUFO();

    // Draw special events
    drawMeteorShower();
    drawEclipse();

    // Draw gameboy if present
    if (gameboy) {
        gameboy.draw();
    }

    // Draw owls
    for (const owl of owls) {
        owl.draw();
    }

    // Draw crows
    for (const crow of crows) {
        crow.draw();
    }

    // ===== WEATHER/EFFECTS LAYER =====
    // Draw rain if raining
    if (isRaining) {
        drawRain(0);
    }

    // Draw lightning strikes
    drawLightningStrikes();

    // Draw special effects
    drawSpecialEffects(0);

    // Restore context after camera transformations
    ctx.restore();

    // ===== CLOCK AND FORECAST LAYER (no camera transform) =====
    if (clockEnabled) {
        drawClock();
    }

    // ===== UI LAYER (top, no camera transform) =====
    // Draw chirp music notes and emoji conversations
    const now = Date.now();
    drawChirpMusicNotes(now);

    // Draw emoji conversations (without updating state)
    emojiConversations.forEach(convo => {
        convo.exchanges.forEach(exchange => {
            // Only show if it's time for this exchange
            if (now >= exchange.timestamp && now - exchange.timestamp < 2000) {
                const age = now - exchange.timestamp;
                const progress = age / 2000;
                const opacity = 1 - progress;
                const floatUp = progress * 30;

                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const x = exchange.bird.x;
                const y = exchange.bird.y - 20 - floatUp;

                // White border/outline
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.strokeText(exchange.emoji, x, y);

                // Draw emoji
                ctx.fillText(exchange.emoji, x, y);

                ctx.restore();
            }
        });
    });

    // Draw bird interaction UI
    drawBirdInteractionUI();
}


        // Start animation
        function startAnimation() {
            if (animationRunning) return;
            
            // IMPROVED: Create initial trees with better clustering and responsive count
            // Scale tree count based on screen width (more trees on wider screens)
            const baseTreeCount = 5 + Math.floor(Math.random() * 3);
            const widthFactor = Math.max(1, canvas.width / 1920); // 1920px baseline
            const initialTreeCount = Math.floor(baseTreeCount * widthFactor);

            // Create tree clusters for more natural distribution with MORE VARIETY
            const clusterCount = Math.floor(initialTreeCount / 2.5); // 2-3 trees per cluster
            const clusters = [];

            for (let c = 0; c < clusterCount; c++) {
                // More varied cluster positioning - spread out further
                const clusterX = 100 + (c * (canvas.width - 200) / clusterCount) +
                    (Math.random() - 0.5) * 300; // Increased from 200 to 300 for more spread

                // Random cluster variants: single big tree, small cluster, or large cluster
                const clusterVariant = Math.random();
                let clusterSize, clusterSpacing;

                if (clusterVariant < 0.25) {
                    // 25% chance: Single majestic tree
                    clusterSize = 1;
                    clusterSpacing = 0;
                } else if (clusterVariant < 0.60) {
                    // 35% chance: Small cluster (2-3 trees, close together)
                    clusterSize = 2 + Math.floor(Math.random() * 2);
                    clusterSpacing = 120; // Closer together
                } else {
                    // 40% chance: Large cluster (4-6 trees, more spread)
                    clusterSize = 4 + Math.floor(Math.random() * 3);
                    clusterSpacing = 200; // More spread out
                }

                clusters.push({ x: clusterX, size: clusterSize, spacing: clusterSpacing });
            }

            // Spawn trees in clusters
            for (const cluster of clusters) {
                for (let i = 0; i < cluster.size; i++) {
                    // Use cluster-specific spacing (single tree = no spread, small/large cluster = varied)
                    const x = cluster.x + (Math.random() - 0.5) * cluster.spacing;

                    // Ensure tree stays on screen
                    const clampedX = Math.max(100, Math.min(canvas.width - 100, x));

                    // Varied tree sizes - single trees are BIGGER and more majestic
                    let isTall, trunkHeight, trunkWidth, leafRadius;

                    if (cluster.size === 1) {
                        // Single majestic tree: always tall with larger dimensions
                        isTall = true;
                        trunkHeight = 180 + Math.random() * 80; // Much taller
                        trunkWidth = 25 + Math.random() * 15; // Thicker trunk
                        leafRadius = 60 + Math.random() * 30; // Larger canopy
                    } else {
                        // Clustered trees: varied sizes
                        isTall = Math.random() < 0.2;
                        trunkHeight = isTall ?
                            150 + Math.random() * 60 :
                            100 + Math.random() * 40;
                        trunkWidth = isTall ?
                            20 + Math.random() * 10 :
                            15 + Math.random() * 8;
                        leafRadius = isTall ?
                            50 + Math.random() * 20 :
                            40 + Math.random() * 15;
                    }

                    if (isTall) tallTreeCount++;

                    // Single trees always have branches for that majestic look
                    const hasBranches = cluster.size === 1 ? true : true; // All trees have branches now
                    trees.push(new Tree(
                        clampedX,
                        trunkWidth,
                        trunkHeight,
                        leafRadius,
                        hasBranches // Varied branch density based on cluster type
                    ));
                }
            }

            // Add initial bushes with depth variation (distributed across entire grass area depth)
            const bushCount = 5 + Math.floor(Math.random() * 4); // 5-8 bushes for better coverage
            for (let i = 0; i < bushCount; i++) {
                // Distribute bushes across the ground with some clustering
                const xPos = 100 + (i * (canvas.width - 200) / bushCount) + (Math.random() - 0.5) * 150;
                const clampedX = Math.max(80, Math.min(canvas.width - 80, xPos));
                const depth = Math.random(); // Random depth for 3D layering effect
                bushes.push(new Bush(clampedX, depth));
                debugLog(`Bush spawned at (${clampedX}) with depth ${depth.toFixed(2)}`);
            }

            // Add tall grass patches with depth variation (distributed across entire grass area depth)
            const grassPatchCount = 4 + Math.floor(Math.random() * 4); // 4-7 patches for better coverage
            for (let i = 0; i < grassPatchCount; i++) {
                // Random positions across the ground, avoiding edges
                const xPos = 150 + Math.random() * (canvas.width - 300);
                const patchWidth = 40 + Math.random() * 60; // 40-100px wide (will be scaled by depth in constructor)
                const depth = Math.random(); // Random depth for 3D layering effect
                tallGrassPatches.push(new TallGrass(xPos, patchWidth, depth));
                debugLog(`Tall grass patch spawned at (${xPos}), width: ${patchWidth.toFixed(0)}px, depth: ${depth.toFixed(2)}`);
            }

            // Add decorative stones/rocks with depth variation (distributed across entire grass area depth)
            const stoneCount = 6 + Math.floor(Math.random() * 6); // 6-11 stones for better coverage
            for (let i = 0; i < stoneCount; i++) {
                const xPos = 100 + Math.random() * (canvas.width - 200);
                const depth = Math.random(); // Random depth for 3D layering effect
                stones.push(new Stone(xPos, null, depth)); // Let constructor calculate Y with depth offset
                debugLog(`Stone spawned at (${xPos}) with depth ${depth.toFixed(2)}`);
            }
            debugLog(`${stoneCount} decorative stones added to scene`);

            // Add initial birds with staggered entry
            const initialBirds = 3; // Ensure 3 initial birds
            let delay = 2000; // Start after 2 seconds
            for (let i = 0; i < initialBirds; i++) {
                setTimeout(() => {
                    // Create bird at random edge
                    const bird = new Bird();
                    
                    // Position bird just off-screen
                    const isHorizontal = Math.random() < 0.5;
                    if (isHorizontal) {
                        bird.x = Math.random() < 0.5 ? -20 : canvas.width + 20;
                        bird.y = 100 + Math.random() * 150;
                    } else {
                        bird.x = 100 + Math.random() * (canvas.width - 200);
                        bird.y = -20;
                    }
                    
                    // Give bird a path to fly into the garden
                    bird.state = BIRD_STATES.FLYING;
                    bird.direction = bird.x < 0 ? 1 : -1;
                    
                    // Target middle of screen
                    const targetX = canvas.width / 2 + (Math.random() - 0.5) * 200;
                    const targetY = 100 + Math.random() * 150;
                    bird.generatePath(targetX, targetY);

                    birds.push(bird);

                    // Register bird in family system immediately
                    getBirdName(bird);
                    updateDiaryDisplay(); // Update diary to show starting birds

                    debugLog(`Initial bird ${i+1} added with path`);
                }, delay);
                delay += 5000 + Math.random() * 3000; // 5-8 seconds between birds
            }

            // Initial twigs (increased to help with nest building)
            const initialTwigCount = 10;
            for (let i = 0; i < initialTwigCount; i++) {
                let x, y;
                if (trees.length > 0 && Math.random() < 0.7) {
                    const randomTree = trees[Math.floor(Math.random() * trees.length)];
                    x = randomTree.x + (Math.random() - 0.5) * 100;
                    y = canvas.height * 0.8 + Math.random() * 5; // Ground level
                } else {
                    x = Math.random() * canvas.width;
                    y = canvas.height * 0.8 + Math.random() * 10;
                }
                const size = 10 + Math.random() * 8;
                const angle = Math.PI / 4 + Math.random() * Math.PI / 2;
                const isSpecial = Math.random() < 0.05;
                const offshoots = [];
                for (let j = 0; j < 3; j++) {
                    offshoots.push({
                        position: Math.random() * size,
                        length: 2 + Math.random() * 4,
                        angle: (Math.random() - 0.5) * Math.PI / 2
                    });
                }
                twigs.push({ x, y, size, angle, isSpecial, offshoots });
                if (isSpecial) console.log(`Initial special twig at (${x}, ${y})`);
            }
            
            // Initial food
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 5;
                foodItems.push({
                    x: x,
                    y: y,
                    type: ['seed', 'berry', 'crumb'][Math.floor(Math.random() * 3)],
                    timer: 0
                });
            }
            
            // Initial worms
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 20;
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 5 + Math.random() * 5
                });
            }

            // 10% chance to spawn a pond on initial load
            if (Math.random() < 0.1) {
                const pondWidth = 80 + Math.random() * 40;
                const pondHeight = 50 + Math.random() * 30;
                const pondX = 100 + Math.random() * (canvas.width - 200);
                const pondY = canvas.height * GROUND_HEIGHT_RATIO;

                ponds.push({
                    x: pondX,
                    y: pondY,
                    width: pondWidth,
                    height: pondHeight,
                    ripples: []
                });

                // Add 2 koi to the pond with traditional colors
                const koiColors = ['#FF6B35', '#FFD700', '#FF4500', '#FFA500', '#DC143C', '#FF8C00', '#8B4513', '#708090'];
                for (let i = 0; i < 2; i++) {
                    koi.push({
                        id: Math.random().toString(36).substring(2, 11), // Unique ID for naming
                        x: pondX,
                        y: pondY,
                        color: koiColors[Math.floor(Math.random() * koiColors.length)],
                        swimAngle: Math.random() * Math.PI * 2,
                        pondIndex: ponds.length - 1
                    });
                }

                // Add 1 frog to the pond
                frogs.push({
                    id: Math.random().toString(36).substr(2, 9), // Unique ID for naming
                    x: pondX + (Math.random() - 0.5) * pondWidth * 0.8,
                    y: canvas.height * GROUND_HEIGHT_RATIO,
                    jumping: false,
                    jumpTimer: 0,
                    tongueOut: false,
                    tongueTarget: null
                });

                debugLog(`Initial pond spawned at (${pondX}, ${pondY}) with koi and frog`);
            }

            // 10% chance to spawn a fully built birdhouse on initial load at ground level
            if (Math.random() < 0.1) {
                // Spawn at random X position on ground level
                const birdhouseX = 100 + Math.random() * (canvas.width - 200);
                // FIXED: Base should be AT ground level so pole extends into grass
                const birdhouseY = canvas.height * GROUND_HEIGHT_RATIO + 10; // Base in grass

                const birdhouse = new Birdhouse(birdhouseX, birdhouseY);
                birdhouse.materialsCollected = BIRDHOUSE_MATERIALS_NEEDED; // Fully built
                birdhouse.isComplete = true; // Mark as complete
                birdhouses.push(birdhouse);

                debugLog(`Initial birdhouse spawned fully built at ground level (${birdhouseX}, ${birdhouseY})`);
                addDiaryEntry("A sturdy birdhouse already stands in the garden, waiting for residents.", 'discovery');
            }

            // 10% chance to spawn wind chimes hanging from a tree on initial load
            if (Math.random() < 0.1 && trees.length > 0) {
                const randomTree = trees[Math.floor(Math.random() * trees.length)];
                const windChime = createWindChime(randomTree.x, randomTree.y, randomTree.trunkHeight);
                windChime.treeId = randomTree.id;
                windChimes.push(windChime);

                // Auto-enable wind chime audio if spawned
                windChimeEnabled = true;

                // FIX: Initialize audio and start playing wind chimes
                if (!audioContext) {
                    initializeAudio();
                }
                lastWindChimeTime = 0; // Reset to trigger immediate chime
                playWindChimes(); // Start the wind chime playback loop

                debugLog(`Initial wind chime spawned on tree at (${randomTree.x})`);
                addDiaryEntry("Gentle wind chimes hang from a tree, waiting to sing in the breeze.", 'discovery');
            }

            // Schedule first rain
            scheduleRain();
            
            // Start animation loop
            lastTime = Date.now();
            animationRunning = true;
            requestAnimationFrame(updateAndDraw);
            
            debugLog("Animation started");
        }

        // Event handlers for buttons
        function setupEventHandlers() {
            // Basic control buttons
            const addBirdBtn = document.getElementById('addBirdBtn');
            addBirdBtn.addEventListener('click', () => {
                const bird = new Bird();
                birds.push(bird);
                debugLog("Bird added manually");
            });


             // Add this new handler
    // Screenshot button handler
    const screenshotBtn = document.getElementById('screenshotBtn');
    if (screenshotBtn) {
        console.log("Screenshot button found, adding click listener");
        screenshotBtn.addEventListener('click', takeScreenshot);
        console.log("Screenshot click listener added successfully");
    } else {
        console.error("Screenshot button NOT found in DOM!");
    }

    // Instruction manual toggle
    const manualBtn = document.getElementById('manualBtn');
    const instructionManual = document.getElementById('instructionManual');
    const closeManualBtn = document.getElementById('closeManualBtn');

    if (manualBtn && instructionManual) {
        manualBtn.addEventListener('click', () => {
            instructionManual.style.display = 'block';
            debugLog("Instruction manual opened");
        });
    }

    if (closeManualBtn && instructionManual) {
        closeManualBtn.addEventListener('click', () => {
            instructionManual.style.display = 'none';
            debugLog("Instruction manual closed");
        });
    }

    // Close manual when clicking outside of it
    if (instructionManual) {
        instructionManual.addEventListener('click', (e) => {
            if (e.target === instructionManual) {
                instructionManual.style.display = 'none';
                debugLog("Instruction manual closed (clicked outside)");
            }
        });
    }

    // Mute button toggle
    const muteBtn = document.getElementById('muteBtn');

    if (muteBtn) {
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;

            if (isMuted) {
                // Mute audio by suspending context
                if (audioContext && audioContext.state === 'running') {
                    audioContext.suspend();
                }
                // Also disable wind chimes when muting
                windChimeEnabled = false;
                muteBtn.textContent = 'üîá Unmute';
                muteBtn.classList.add('muted');
                debugLog("Audio muted");
            } else {
                // Unmute audio by resuming context
                if (!audioContext) {
                    initializeAudio();
                }
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                muteBtn.textContent = 'üîä Mute';
                muteBtn.classList.remove('muted');
                debugLog("Audio unmuted");
            }
        });
    }

    // Clock toggle handler
    const clockToggle = document.getElementById('clockToggle');
    if (clockToggle) {
        clockToggle.addEventListener('change', () => {
            clockEnabled = clockToggle.checked;
            if (clockEnabled && !window.clockNumberPositions) {
                window.clockNumberPositions = []; // Initialize array for bird perching
            }
            debugLog(`Clock display ${clockEnabled ? 'enabled' : 'disabled'}`);
        });
    }

    // Garden Diary handlers
    const diaryToggle = document.getElementById('diaryToggle');
    const gardenDiary = document.getElementById('gardenDiary');
    const closeDiaryBtn = document.getElementById('closeDiaryBtn');

    if (diaryToggle && gardenDiary) {
        diaryToggle.addEventListener('change', () => {
            if (diaryToggle.checked) {
                gardenDiary.style.display = 'block';
                updateDiaryDisplay();
                debugLog("Garden diary opened");
            } else {
                gardenDiary.style.display = 'none';
                debugLog("Garden diary closed");
            }
        });
    }

    if (closeDiaryBtn && gardenDiary && diaryToggle) {
        closeDiaryBtn.addEventListener('click', () => {
            gardenDiary.style.display = 'none';
            diaryToggle.checked = false;
            debugLog("Garden diary closed");
        });
    }

    // Debug toggle handler
    const debugToggle = document.getElementById('debugToggle');
    const controlPanel = document.getElementById('controlPanel');

    if (debugToggle && controlPanel) {
        debugToggle.addEventListener('change', () => {
            if (debugToggle.checked) {
                debugVisuals = true;
                controlPanel.style.display = 'block';
                debugLog("Debug mode enabled via wrench toggle");
            } else {
                debugVisuals = false;
                controlPanel.style.display = 'none';
                debugLog("Debug mode disabled via wrench toggle");
            }
            updateDebugVisuals();
        });
    }

    // Close diary when clicking outside
    if (gardenDiary) {
        gardenDiary.addEventListener('click', (e) => {
            if (e.target === gardenDiary) {
                gardenDiary.style.display = 'none';
                debugLog("Garden diary closed (clicked outside)");
            }
        });
    }

            const addFoodBtn = document.getElementById('addFoodBtn');
            addFoodBtn.addEventListener('click', () => {
                scatterFood(canvas.width/2, canvas.height * GROUND_HEIGHT_RATIO, 10);
                debugLog("Food scattered manually");
            });
            
            const toggleRainBtn = document.getElementById('toggleRainBtn');
toggleRainBtn.addEventListener('click', () => {
    // Toggle rain state
    isRaining = !isRaining;
    
    if (!isRaining) {
        // Explicitly set wasRaining to true when rain stops
        wasRaining = true;
        
        // Create puddles
        createPuddles();
        
        // Check for rainbow conditions
        checkForRainbow();
        
        debugLog(`Rain stopped - creating puddles and checking for rainbow`);
    } else {
        // Reset wasRaining when rain starts
        wasRaining = false;
        
        debugLog(`Rain started manually`);
    }
});




            const toggleMushroomModeBtn = document.getElementById('toggleMushroomModeBtn');
if (toggleMushroomModeBtn) {
    toggleMushroomModeBtn.addEventListener('click', () => {
        // Toggle mushroom mode
        mushroomMode = !mushroomMode;
        
        // Update button text and styling
        toggleMushroomModeBtn.textContent = mushroomMode ? 'üçÑ Normal Mode' : 'üçÑ Mushroom Mode';
        toggleMushroomModeBtn.style.backgroundColor = mushroomMode ? '#FF00FF' : '#f8f8f8';
        toggleMushroomModeBtn.style.color = mushroomMode ? '#FFFFFF' : '#000000';
        
        // If activating, trigger special effects
        if (mushroomMode) {
            colorCycleTimer = 0;
            birdTrails = []; // Reset trails when starting
            
            // Add special effects for activation
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    addSpecialEffect({
                        type: 'sparkle',
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        duration: 3000,
                        intensity: 0.8
                    });
                }, i * 300);
            }
            
            // Also update the hidden toggle button state if it exists
            const toggleMushroom = document.getElementById('toggleMushroom');
            if (toggleMushroom) {
                toggleMushroom.style.display = 'block';
                toggleMushroom.textContent = 'üçÑ Normal Mode';
                toggleMushroom.style.backgroundColor = '#FF00FF';
                toggleMushroom.style.color = '#FFFFFF';
            }
        } else {
            // Clean up when deactivating
            birdTrails = []; // Clear trails
            
            // Update the hidden toggle button state if it exists
            const toggleMushroom = document.getElementById('toggleMushroom');
            if (toggleMushroom) {
                toggleMushroom.textContent = 'üçÑ Mushroom Mode';
                toggleMushroom.style.backgroundColor = '#f8f8f8';
                toggleMushroom.style.color = '#000000';
            }
        }
        
        debugLog(`Mushroom mode ${mushroomMode ? 'activated' : 'deactivated'}!`);
    });
}







            const spawnWormBtn = document.getElementById('spawnWormBtn');
    spawnWormBtn.addEventListener('click', () => {
        // Spawn a cluster of worms
        const wormCount = 10; // Spawn 10 worms at once for testing
        const groundY = canvas.height * GROUND_HEIGHT_RATIO;
        
        // Create worms in a small area
        const centerX = canvas.width / 2;
        const spreadX = 100; // Spread across 200px area
        
        for (let i = 0; i < wormCount; i++) {
            // Calculate position with some randomness
            const x = centerX + (Math.random() - 0.5) * spreadX * 2;
            const y = groundY + Math.random() * 20; // Slightly below ground
            
            // Add worm if below max limit
            if (worms.length < MAX_WORMS) {
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 5 + Math.random() * 5
                });
            }
        }
        
        debugLog(`Manually spawned ${wormCount} worms`);
    });

    const spawnAntsBtn = document.getElementById('spawnAntsBtn');
    spawnAntsBtn.addEventListener('click', () => {
        // Create ant hill if it doesn't exist
        if (!antHill) {
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            antHill = {
                x: canvas.width / 2,
                y: groundY + 5,
                entranceY: groundY + 2,
                size: 20,
                ants: [],
                lastAntSpawnTime: 0,
                food: 0
            };
            debugLog(`Ant hill created at (${antHill.x}, ${antHill.y})`);
        }

        // Spawn 10 ants at once for testing
        const antCount = 10;
        for (let i = 0; i < antCount; i++) {
            if (ants.length < 50) { // Reasonable max
                spawnAnt();
            }
        }

        debugLog(`Manually spawned ${antCount} ants`);
    });

    const toggleMushroom = document.getElementById('toggleMushroom');
if (toggleMushroom) {
    toggleMushroom.addEventListener('click', () => {
        // Toggle mushroom mode
        mushroomMode = !mushroomMode;
        
        // Update button text and styling
        toggleMushroom.textContent = mushroomMode ? 'üçÑ Normal Mode' : 'üçÑ Mushroom Mode';
        toggleMushroom.style.backgroundColor = mushroomMode ? '#FF00FF' : '#f8f8f8';
        toggleMushroom.style.color = mushroomMode ? '#FFFFFF' : '#000000';
        
        // Sync the main button state
        const toggleMushroomModeBtn = document.getElementById('toggleMushroomModeBtn');
        if (toggleMushroomModeBtn) {
            toggleMushroomModeBtn.textContent = mushroomMode ? 'üçÑ Normal Mode' : 'üçÑ Mushroom Mode';
            toggleMushroomModeBtn.style.backgroundColor = mushroomMode ? '#FF00FF' : '#f8f8f8';
            toggleMushroomModeBtn.style.color = mushroomMode ? '#FFFFFF' : '#000000';
        }
        
        // Same code for cleanup/setup as in the main button
        if (mushroomMode) {
            colorCycleTimer = 0;
            birdTrails = []; // Reset trails when starting
        } else {
            birdTrails = []; // Clear trails
        }
        
        debugLog(`Mushroom mode ${mushroomMode ? 'activated' : 'deactivated'}!`);
    });
}

            
            // Debug control buttons
            const addBabyBirdBtn = document.getElementById('addBabyBirdBtn');
            addBabyBirdBtn.addEventListener('click', () => {
                // Always create a new nest for the baby bird
                let nestForBaby = null;
                
                // Create nest in a tree if possible
                if (trees.length > 0) {
                    // Find a suitable tree with more relaxed criteria
                    const potentialTrees = trees.filter(tree => 
                        !tree.nest && tree.health > 30
                    );
                    
                    if (potentialTrees.length > 0) {
                        // Sort trees by health to pick healthier trees first
                        potentialTrees.sort((a, b) => b.health - a.health);
                        
                        // Pick one of the healthiest trees
                        const treeIndex = Math.floor(Math.random() * Math.min(3, potentialTrees.length));
                        const tree = potentialTrees[treeIndex];
                        
                        // Create a new nest
                        const nestX = tree.x + (Math.random() * 20 - 10) * tree.scale;
                        const nestY = tree.y - tree.trunkHeight * 0.8 * tree.scale;
                        
                        const newNest = new Nest(tree, nestX, nestY);
                        newNest.materialsCollected = NEST_MATERIALS_NEEDED; // Fully built nest
                        newNest.isComplete = true;
                        newNest.readyForBabies = true;
                        nests.push(newNest);
                        tree.nest = newNest;
                        
                        nestForBaby = newNest;
                        
                        // Create baby bird at nest
                        const babyBird = new BabyBird(nestX, nestY, null, newNest);
                        babyBirds.push(babyBird);
                        
                        // Alert nearby birds to feed the baby
                        alertBirdsToFeedBaby(babyBird);
                        
                        debugLog(`Created complete nest at (${nestX}, ${nestY}) with baby bird`);
                    } else {
                        // No suitable trees - create baby bird in random position
                        const x = 100 + Math.random() * (canvas.width - 200);
                        const y = canvas.height * 0.3 + Math.random() * 100;
                        babyBirds.push(new BabyBird(x, y));
                        debugLog(`Baby bird added at (${x}, ${y}) without nest (no suitable trees)`);
                    }
                } else {
                    // No trees - create baby bird in random position
                    const x = 100 + Math.random() * (canvas.width - 200);
                    const y = canvas.height * 0.3 + Math.random() * 100;
                    babyBirds.push(new BabyBird(x, y));
                    debugLog(`Baby bird added at (${x}, ${y}) without nest (no trees available)`);
                }
            });

            // Hatch all eggs button for testing
            const hatchEggsBtn = document.getElementById('hatchEggsBtn');
            hatchEggsBtn.addEventListener('click', () => {
                if (eggs.length === 0) {
                    debugLog('No eggs to hatch!');
                    return;
                }

                const eggCount = eggs.length;
                // Force all eggs to hatch by setting their creation day to 2+ cycles ago
                eggs.forEach(egg => {
                    egg.createdOnDay = dayNightCycleCount - Math.ceil(egg.cyclesToHatch) - 1;
                });

                debugLog(`Forcing ${eggCount} egg(s) to hatch immediately for testing`);
            });

            const addSquirrelBtn = document.getElementById('addSquirrelBtn');
            addSquirrelBtn.addEventListener('click', () => {
                const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                const y = canvas.height * GROUND_HEIGHT_RATIO - 5;
                
                const squirrel = new Squirrel(x, y);
                // Set initial direction based on entry point
                squirrel.direction = x < 0 ? 1 : -1;
                
                squirrels.push(squirrel);
                debugLog("Squirrel added manually");
            });
            
            const addRatKingBtn = document.getElementById('addRatKingBtn');
            addRatKingBtn.addEventListener('click', () => {
                const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                const y = canvas.height * GROUND_HEIGHT_RATIO;
                
                const ratKing = new Rat(x, y, true); // true = rat king
                rats.push(ratKing);
                debugLog("Rat King added manually");
            });
            
            const addSpecialTwigBtn = document.getElementById('addSpecialTwigBtn');
            addSpecialTwigBtn.addEventListener('click', () => {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10;
                
                twigs.push({
                    x: x,
                    y: y,
                    size: 15 + Math.random() * 10, // Larger special twigs
                    angle: Math.random() * Math.PI,
                    isSpecial: true,
                    offshoots: []
                });
                
                // Generate random offshoots
                const offshootCount = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < offshootCount; j++) {
                    twigs[twigs.length - 1].offshoots.push({
                        position: Math.random() * twigs[twigs.length - 1].size,
                        length: 3 + Math.random() * 5,
                        angle: (Math.random() - 0.5) * Math.PI
                    });
                }
                
                debugLog("Special twig added manually");
            });
            
            const addBirdhouseBtn = document.getElementById('addBirdhouseBtn');
            addBirdhouseBtn.addEventListener('click', () => {
                // Find a valid position
                const validSpaces = [];
                const minDistance = 100; // Minimum distance from other birdhouses
                
                // Find valid placement spots
                for (let x = 100; x < canvas.width - 100; x += 50) {
                    let valid = true;
                    
                    // Check if too close to other birdhouses
                    for (const birdhouse of birdhouses) {
                        if (Math.abs(birdhouse.x - x) < minDistance) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) validSpaces.push(x);
                }
                
                // Pick random valid position
                if (validSpaces.length > 0) {
                    const x = validSpaces[Math.floor(Math.random() * validSpaces.length)];
                    // FIXED: Base should be in grass so pole extends properly
                    const y = canvas.height * GROUND_HEIGHT_RATIO + 10;

                    const newBirdhouse = new Birdhouse(x, y);
                    // CHANGE THIS LINE (make it incomplete so birds can build it):
                    newBirdhouse.isComplete = false; // Was true, now false
                    newBirdhouse.materialsCollected = Math.floor(BIRDHOUSE_MATERIALS_NEEDED / 2); // Half built
                    birdhouses.push(newBirdhouse);
                    
                    // Direct a bird to build it
                    const availableBird = birds.find(bird => !bird.isWild && bird.state !== BIRD_STATES.BUILDING);
                    if (availableBird) {
                        availableBird.buildingBirdhouse = newBirdhouse;
                        availableBird.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                        availableBird.stateTimer = 0;
                        debugLog(`Bird assigned to complete birdhouse at (${x})`);
                    }
                    
                    debugLog(`Birdhouse added at (${x}, ${y})`);
                } else {
                    debugLog("Could not find valid position for birdhouse");
                }
            });
            

            const spawnOwlBtn = document.getElementById('spawnOwlBtn');
spawnOwlBtn.addEventListener('click', () => {
    // Create new owl at a random edge
    const side = Math.random() < 0.5 ? 'left' : 'right';
    const x = side === 'left' ? -30 : canvas.width + 30;
    const y = canvas.height * 0.3 + Math.random() * 100;
    
    const owl = new Owl(x, y);
    owls.push(owl);
    
    // If daytime, set to hunting mode immediately
    if (timeOfDay < 1) {
        owl.state = 'hunting';
    }
    
    debugLog("Owl manually spawned");
});

const spawnScarecrowBtn = document.getElementById('spawnScarecrowBtn');
spawnScarecrowBtn.addEventListener('click', () => {
    // If scarecrow already exists, remove it first
    if (scarecrow) {
        scarecrow = null;
        scarecrowCreated = false;
    }
    
    // Find position for scarecrow
    let scarecrowX = canvas.width / 2;
    
    // If birdhouses exist, place between them
    if (birdhouses.length >= 2) {
        const bh1 = birdhouses[0];
        const bh2 = birdhouses[1];
        scarecrowX = (bh1.x + bh2.x) / 2;
    }
    
    const scarecrowY = canvas.height * GROUND_HEIGHT_RATIO;
    
    // Create scarecrow object
    scarecrow = {
        x: scarecrowX,
        y: scarecrowY,
        armWave: 0,
        hatWobble: 0,
        headTilt: 0,
        isFemale: Math.random() < 0.5
    };
    
    // Mark as created
    scarecrowCreated = true;
    
    // Make any existing crows leave immediately
    if (typeof makeCrowsLeave === 'function') {
        makeCrowsLeave();
    }
    
    // Show celebration effect
    if (typeof addSpecialEffect === 'function') {
        addSpecialEffect({
            type: 'sparkle',
            x: scarecrowX,
            y: scarecrowY - 50,
            duration: 3000,
            intensity: 1.0
        });
    }
    
    debugLog(`Scarecrow ${scarecrow.isFemale ? 'woman' : 'man'} manually created!`);
});

const spawnGameboyBtn = document.getElementById('spawnGameboyBtn');
spawnGameboyBtn.addEventListener('click', () => {
    // Only spawn if one doesn't already exist
    if (!gameboy) {
        spawnGameboy();
    } else {
        debugLog("Gameboy already exists in the garden");
    }
});

// Trigger pecking behavior for testing
const triggerPeckingBtn = document.getElementById('triggerPeckingBtn');
triggerPeckingBtn.addEventListener('click', () => {
    if (birds.length > 0) {
        const bird = birds[Math.floor(Math.random() * birds.length)];
        bird.startPecking();
        debugLog(`Triggered pecking for bird at (${bird.x.toFixed(0)}, ${bird.y.toFixed(0)})`);
    } else {
        debugLog("No birds available to trigger pecking");
    }
});

// Test all chirp types
const testChirpBtn = document.getElementById('testChirpBtn');
testChirpBtn.addEventListener('click', () => {
    if (birds.length > 0) {
        const bird = birds[0];
        const chirpTypes = [
            CHIRP_TYPES.SOCIAL,
            CHIRP_TYPES.FOOD_CALL,
            CHIRP_TYPES.CONTACT_CALL,
            CHIRP_TYPES.ALERT,
            CHIRP_TYPES.TERRITORIAL,
            CHIRP_TYPES.VICTORY
        ];

        chirpTypes.forEach((type, i) => {
            setTimeout(() => {
                bird.chirp(type, 1.0);
                debugLog(`Testing chirp type: ${Object.keys(CHIRP_TYPES).find(k => CHIRP_TYPES[k] === type)}`);
            }, i * 1000);
        });
    } else {
        debugLog("No birds available to test chirps");
    }
});

// Add a regular rat (not rat king)
const addRatBtn = document.getElementById('addRatBtn');
addRatBtn.addEventListener('click', () => {
    const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
    const y = canvas.height * GROUND_HEIGHT_RATIO;
    const rat = new Rat(x, y, false);
    rats.push(rat);
    debugLog(`Regular rat spawned at (${x}, ${y})`);
});

// Spawn a pond
const spawnPondBtn = document.getElementById('spawnPondBtn');
spawnPondBtn.addEventListener('click', () => {
    // Create pond at random location
    const x = 100 + Math.random() * (canvas.width - 200);
    const width = 80 + Math.random() * 40;
    const height = 40 + Math.random() * 20;

    // Position pond so top edge aligns with ground (appears to be in the ground)
    const y = canvas.height * GROUND_HEIGHT_RATIO + height / 2;

    if (!ponds) ponds = [];

    ponds.push({
        x: x,
        y: y,
        width: width,
        height: height,
        rippleTimer: 0,
        ripples: []
    });

    debugLog(`Pond spawned at (${x}, ${y}), size: ${width}x${height}`);
});

// Spawn a frog
const spawnFrogBtn = document.getElementById('spawnFrogBtn');
spawnFrogBtn.addEventListener('click', () => {
    if (!frogs) frogs = [];

    const x = 100 + Math.random() * (canvas.width - 200);
    const y = canvas.height * GROUND_HEIGHT_RATIO;

    frogs.push({
        x: x,
        y: y,
        jumpTimer: 0,
        tongueOut: false
    });

    debugLog(`Frog spawned at (${x}, ${y})`);
});

// Spawn a koi fish
const spawnKoiBtn = document.getElementById('spawnKoiBtn');
spawnKoiBtn.addEventListener('click', () => {
    if (ponds && ponds.length > 0) {
        if (!koi) koi = [];

        const pond = ponds[0];
        const koiColors = ['#FF6B35', '#FFD700', '#FF4500', '#FFA500', '#DC143C', '#FF8C00', '#8B4513', '#708090'];
        koi.push({
            id: Math.random().toString(36).substring(2, 11), // Unique ID for naming
            x: pond.x + pond.width / 2,
            y: pond.y + pond.height / 2,
            pondIndex: 0,
            swimAngle: Math.random() * Math.PI * 2,
            color: koiColors[Math.floor(Math.random() * koiColors.length)]
        });

        debugLog(`Koi spawned in pond`);
    } else {
        debugLog("No ponds available - spawn a pond first!");
    }
});

// Trigger rainbow manually
const triggerRainbowBtn = document.getElementById('triggerRainbowBtn');
triggerRainbowBtn.addEventListener('click', () => {
    if (typeof createRainbow === 'function') {
        // Directly create rainbow regardless of conditions
        createRainbow();
        debugLog("Rainbow triggered manually");
    } else {
        debugLog("createRainbow function not found");
    }
});

// FIXED: Added all missing feature triggers
const triggerMeteorBtn = document.getElementById('triggerMeteorBtn');
triggerMeteorBtn.addEventListener('click', () => {
    if (!meteorShower) {
        meteorShower = {
            active: true,
            meteors: [],
            duration: 30000,
            elapsed: 0,
            nextMeteorTime: 0
        };
        debugLog("Meteor shower triggered manually");
    } else {
        debugLog("Meteor shower already active");
    }
});

const triggerEclipseBtn = document.getElementById('triggerEclipseBtn');
triggerEclipseBtn.addEventListener('click', () => {
    if (!eclipse) {
        // FIXED: Start at totality (phase 1) so eclipse sun/moon is visible immediately
        eclipse = {
            active: true,
            phase: 1,
            elapsed: 18000, // 30% of 60000ms (start of totality phase)
            totalDuration: 60000,
            darkness: 1.0
        };
        debugLog("Eclipse triggered manually at totality");
    } else {
        debugLog("Eclipse already active");
    }
});

const triggerUFOBtn = document.getElementById('triggerUFOBtn');
triggerUFOBtn.addEventListener('click', () => {
    if (!ufo) {
        // Find potential targets
        const potentialTargets = [];
        birdhouses.forEach(house => {
            if (house.isComplete) potentialTargets.push({type: 'birdhouse', entity: house});
        });
        if (scarecrow) potentialTargets.push({type: 'scarecrow', entity: scarecrow});
        if (ants.length >= 3) potentialTargets.push({type: 'ant', entity: null});

        if (potentialTargets.length > 0) {
            const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];

            // FIXED: If target is ant, select a specific ant entity
            if (target.type === 'ant') {
                target.entity = ants[Math.floor(Math.random() * ants.length)];
            }

            const startX = Math.random() < 0.5 ? -100 : canvas.width + 100;

            // FIXED: Added missing properties for UFO animation
            ufo = {
                x: startX,
                y: -50,
                vx: 0,
                vy: 1.5,
                state: 'approaching',
                target: target,
                beamProgress: 0,
                beamWidth: 0,
                rotation: 0,
                glowPhase: 0,
                hoverOffset: 0
            };
            debugLog(`UFO triggered manually targeting ${target.type}`);
        } else {
            debugLog("No valid UFO targets available");
        }
    } else {
        debugLog("UFO already active");
    }
});

const triggerMigrationBtn = document.getElementById('triggerMigrationBtn');
triggerMigrationBtn.addEventListener('click', () => {
    if (!migrationWave) {
        const birdCount = 10 + Math.floor(Math.random() * 6);
        migrationWave = {
            active: true,
            birds: [],
            duration: 20000,
            elapsed: 0,
            formation: Math.random() < 0.5 ? 'V' : 'line'
        };

        const startY = canvas.height * 0.2 + Math.random() * (canvas.height * 0.3);
        const direction = Math.random() < 0.5 ? 1 : -1;
        const startX = direction > 0 ? -50 : canvas.width + 50;

        for (let i = 0; i < birdCount; i++) {
            let offsetX = 0, offsetY = 0;
            if (migrationWave.formation === 'V') {
                const side = i % 2 === 0 ? 1 : -1;
                const row = Math.floor(i / 2);
                offsetX = row * 30 * direction;
                offsetY = row * 20 * Math.abs(side);
            } else {
                offsetX = i * 40 * direction;
                offsetY = Math.sin(i * 0.5) * 15;
            }

            migrationWave.birds.push({
                x: startX + offsetX,
                y: startY + offsetY,
                targetX: (direction > 0 ? canvas.width + 50 : -50) + offsetX,
                targetY: startY + offsetY,
                speed: 2 + Math.random() * 0.5,
                wingFlap: 0, // FIXED: Synchronized wing flaps
                size: 0.8 + Math.random() * 0.4
            });
        }
        debugLog(`Migration wave triggered manually (${birdCount} birds, ${migrationWave.formation} formation)`);
    } else {
        debugLog("Migration wave already active");
    }
});

const triggerFirefliesBtn = document.getElementById('triggerFirefliesBtn');
triggerFirefliesBtn.addEventListener('click', () => {
    fireflyNightActive = true;
    const count = 3 + Math.floor(Math.random() * 6);
    for (let i = 0; i < count; i++) {
        fireflies.push({
            x: Math.random() * canvas.width,
            y: canvas.height * 0.3 + Math.random() * (canvas.height * 0.4),
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            glowPhase: Math.random() * Math.PI * 2
        });
    }
    debugLog(`Firefly night triggered manually (${count} fireflies)`);
});

// REMOVED: Trigger Lightning button - was causing white screen issues

const toggleWindChimeBtn = document.getElementById('toggleWindChimeBtn');
if (toggleWindChimeBtn) {
    toggleWindChimeBtn.addEventListener('click', () => {
        // Toggle to opposite state
        windChimeEnabled = !windChimeEnabled;
        
        if (windChimeEnabled) {
    // Start wind chimes
    windChimeStartTime = Date.now();
    lastWindChimeTime = 0; // Set to 0 to trigger immediate chime

    // Add visual wind chime if none exist and we have trees
    if (windChimes.length === 0 && trees.length > 0) {
        const randomTree = trees[Math.floor(Math.random() * trees.length)];
        const windChime = createWindChime(randomTree.x, randomTree.y, randomTree.trunkHeight);
        windChime.treeId = randomTree.id;
        windChimes.push(windChime);
        debugLog(`Wind chime added to tree at (${randomTree.x}) via debug button`);
        addDiaryEntry("Wind chimes now hang from a tree, ready to sing.", 'discovery');
    }

    // Initialize audio context if needed
    if (!audioContext) {
        try {
            initializeAudio();
            // User gesture is required to create audio context in many browsers
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        } catch (e) {
            console.error("Could not initialize audio:", e);
        }
    }
    
    // Cancel any existing timeout/interval to be safe
    if (windChimeTimeout) {
        if (typeof windChimeTimeout === 'number') {
            clearTimeout(windChimeTimeout);
        } else {
            clearInterval(windChimeTimeout);
        }
        windChimeTimeout = null;
    }
    
    // Call playWindChimes directly to start immediately
    playWindChimes();
    
    // Update button text
    toggleWindChimeBtn.textContent = 'üîî Wind Chimes: ON';
    toggleWindChimeBtn.style.background = '#4CAF50'; // Green background
    
    debugLog("Wind chimes enabled with improved timer logic");
} else {
    // FIXED: Turn off wind chimes properly
    // Clear any active timers
    if (windChimeTimeout) {
        if (typeof windChimeTimeout === 'number') {
            clearTimeout(windChimeTimeout);
        } else {
            clearInterval(windChimeTimeout);
        }
        windChimeTimeout = null;
    }

    // Reset wind chime timers
    windChimeStartTime = 0;
    lastWindChimeTime = 0;

    // Update button
    toggleWindChimeBtn.textContent = 'üîî Wind Chimes: OFF';
    toggleWindChimeBtn.style.background = '#f44336'; // Red background
    debugLog("Wind chimes disabled and timers cleared");
}
        
        // Force a user interaction with audio context (needed for browsers)
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                debugLog("Audio context resumed from button click");
            });
        }
    });
}

 // Add event handler for the "Close(Keep Debug Visuals)" button
 const keepVisualsBtn = document.getElementById('keepVisualsBtn');
            if (keepVisualsBtn) {
                keepVisualsBtn.addEventListener('click', () => {
                    // Create a marker element to track this state
                    if (!document.getElementById('keepVisualsActive')) {
                        const keepVisualElem = document.createElement('div');
                        keepVisualElem.id = 'keepVisualsActive';
                        keepVisualElem.style.display = 'none'; // Hidden element
                        document.body.appendChild(keepVisualElem);
                    }
        const controlPanel = document.getElementById('controlPanel');
        if (controlPanel) {
            controlPanel.style.display = 'none';
        }
        
        // Keep debug visuals on
        debugVisuals = true;
        
        debugLog("Control panel hidden, debug visuals retained. Press 'C' to restore panel.");
    });
}


            
          // Triple click detection variables - ADD THIS CODE HERE
let clickCount = 0;
let lastClickTime = 0;
const clickTimeout = 500; // ms between clicks to count as multi-click

// Canvas click for food and triple-click detection
canvas.addEventListener('click', (e) => {
    // Initialize audio on first click (required by browsers)
    if (!audioContext) {
        initializeAudio();
    }
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
    }

    // Prevent any default behaviors and stop propagation
    e.preventDefault();
    e.stopPropagation();

    // Get the correct bounding rectangle, accounting for scrolling
    const rect = canvas.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    // Calculate the correct coordinates, accounting for scroll position
    const x = e.clientX - rect.left - scrollLeft;
    const y = e.clientY - rect.top - scrollTop;

    // Scale coordinates if needed
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const scaledX = x * scaleX;
    const scaledY = y * scaleY;

    // Restore show info button if it was hidden by Escape key
    const toggleInfo = document.getElementById('toggleInfo');
    if (window.showInfoButtonHidden && toggleInfo) {
        toggleInfo.style.display = 'block';
        window.showInfoButtonHidden = false;
        debugLog("Show info button restored on click");
    }
    
    // Triple-click detection logic
    const currentTime = Date.now();
    if (currentTime - lastClickTime < clickTimeout) {
        clickCount++;
    } else {
        clickCount = 1;
    }
    lastClickTime = currentTime;
    
    // Check for triple click in top third of screen (mobile-friendly)
    if (clickCount === 3) {
        // Check if click is in the top third of the screen
        const topThird = canvas.height / 3;
        const inTopThird = scaledY < topThird;
        
        if (inTopThird) {
            // Toggle debug control panel
            const controlPanel = document.getElementById('controlPanel');
            if (controlPanel) {
                controlPanel.style.display = controlPanel.style.display === 'none' ? 'block' : 'none';
                debugLog(`Debug control panel ${controlPanel.style.display === 'none' ? 'hidden' : 'shown'} via triple-click in top third of screen`);
            }
            
            // Also toggle debug visuals
            debugVisuals = controlPanel.style.display === 'block';
            
            // Reset click counter
            clickCount = 0;
            return; // Skip food scattering
        }
    }

// Check if gameboy was clicked
if (gameboy) {
    const wasClicked = checkGameboyClicks(scaledX, scaledY);
    if (wasClicked) {
        return; // Skip food scattering
    }
}

    // Enhanced: Check if any animal was clicked for lock-on
    let clickedAnAnimal = false;

    // Check birds
    for (const bird of birds) {
        const birdDist = Math.sqrt(
            Math.pow(scaledX - bird.x, 2) +
            Math.pow(scaledY - bird.y, 2)
        );
        if (birdDist < 30) { // 30px click radius
            clickedAnAnimal = true;
            // Toggle lock on this bird
            if (lockedAnimal === bird && lockedAnimalType === 'bird') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from bird`);
            } else {
                lockedAnimal = bird;
                lockedAnimalType = 'bird';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto bird: ${getBirdName(bird)}`);

                // Make the bird chirp when clicked/locked
                if (bird.chirp && typeof bird.chirp === 'function') {
                    bird.chirp(CHIRP_TYPES.SOCIAL, 0.8);
                }
            }
            return; // Skip food scattering
        }
    }

    // Check squirrels
    for (const squirrel of squirrels) {
        const squirrelDist = Math.sqrt(
            Math.pow(scaledX - squirrel.x, 2) +
            Math.pow(scaledY - squirrel.y, 2)
        );
        if (squirrelDist < 30) { // 30px click radius
            clickedAnAnimal = true;
            // Toggle lock on this squirrel
            if (lockedAnimal === squirrel && lockedAnimalType === 'squirrel') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from squirrel`);
            } else {
                lockedAnimal = squirrel;
                lockedAnimalType = 'squirrel';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto squirrel: ${getSquirrelName(squirrel)}`);
            }
            return; // Skip food scattering
        }
    }

    // Check rats
    for (const rat of rats) {
        const ratDist = Math.sqrt(
            Math.pow(scaledX - rat.x, 2) +
            Math.pow(scaledY - rat.y, 2)
        );
        if (ratDist < 30) { // 30px click radius
            clickedAnAnimal = true;
            // Toggle lock on this rat
            if (lockedAnimal === rat && lockedAnimalType === 'rat') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from rat`);
            } else {
                lockedAnimal = rat;
                lockedAnimalType = 'rat';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto rat: ${getRatName(rat)}`);
            }
            return; // Skip food scattering
        }
    }

    // Check crows
    for (const crow of crows) {
        const crowDist = Math.sqrt(
            Math.pow(scaledX - crow.x, 2) +
            Math.pow(scaledY - crow.y, 2)
        );
        if (crowDist < 30) {
            clickedAnAnimal = true;
            if (lockedAnimal === crow && lockedAnimalType === 'crow') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from crow`);
            } else {
                lockedAnimal = crow;
                lockedAnimalType = 'crow';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto crow: ${getCrowName(crow)}`);
            }
            return;
        }
    }

    // Check owls
    for (const owl of owls) {
        const owlDist = Math.sqrt(
            Math.pow(scaledX - owl.x, 2) +
            Math.pow(scaledY - owl.y, 2)
        );
        if (owlDist < 30) {
            clickedAnAnimal = true;
            if (lockedAnimal === owl && lockedAnimalType === 'owl') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from owl`);
            } else {
                lockedAnimal = owl;
                lockedAnimalType = 'owl';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto owl: ${getOwlName(owl)}`);
            }
            return;
        }
    }

    // FIXED: Trees are no longer lockable (click-to-lock disabled, hover info still works)
    // Check trees - DISABLED for locking
    // for (const tree of trees) {
    //     const treeDist = Math.sqrt(
    //         Math.pow(scaledX - tree.x, 2) +
    //         Math.pow(scaledY - (tree.y - tree.trunkHeight/2), 2)
    //     );
    //     if (treeDist < tree.trunkWidth * 2 + 50) { // Larger click area for trees
    //         clickedAnAnimal = true;
    //         if (lockedAnimal === tree && lockedAnimalType === 'tree') {
    //             lockedAnimal = null;
    //             lockedAnimalType = null;
    //             debugLog(`Unlocked from tree`);
    //         } else {
    //             lockedAnimal = tree;
    //             lockedAnimalType = 'tree';
    //             lockedAnimalTime = Date.now(); // Set lock time for auto-fade
    //             debugLog(`Locked onto tree: ${getTreeName(tree)}`);
    //         }
    //         return;
    //     }
    // }

    // Check frogs
    for (const frog of frogs) {
        const frogDist = Math.sqrt(
            Math.pow(scaledX - frog.x, 2) +
            Math.pow(scaledY - frog.y, 2)
        );
        if (frogDist < 20) { // 20px click radius (smaller for frogs)
            clickedAnAnimal = true;
            if (lockedAnimal === frog && lockedAnimalType === 'frog') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from frog`);
            } else {
                lockedAnimal = frog;
                lockedAnimalType = 'frog';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto frog: ${getFrogName(frog)}`);
            }
            return;
        }
    }

    // Check koi
    for (const koiFish of koi) {
        const koiDist = Math.sqrt(
            Math.pow(scaledX - koiFish.x, 2) +
            Math.pow(scaledY - koiFish.y, 2)
        );
        if (koiDist < 25) { // 25px click radius
            clickedAnAnimal = true;
            if (lockedAnimal === koiFish && lockedAnimalType === 'koi') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from koi`);
            } else {
                lockedAnimal = koiFish;
                lockedAnimalType = 'koi';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto koi: ${getKoiName(koiFish)}`);
            }
            return;
        }
    }

    // Check ants
    for (const ant of ants) {
        const antDist = Math.sqrt(
            Math.pow(scaledX - ant.x, 2) +
            Math.pow(scaledY - ant.y, 2)
        );
        if (antDist < 15) { // 15px click radius (smaller for ants)
            clickedAnAnimal = true;
            if (lockedAnimal === ant && lockedAnimalType === 'ant') {
                lockedAnimal = null;
                lockedAnimalType = null;
                debugLog(`Unlocked from ant`);
            } else {
                lockedAnimal = ant;
                lockedAnimalType = 'ant';
                lockedAnimalTime = Date.now(); // Set lock time for auto-fade
                debugLog(`Locked onto ant: ${getAntName(ant)}`);
            }
            return;
        }
    }

    // Mobile-friendly unlock: If locked on an animal but clicked elsewhere, unlock
    if (lockedAnimal && !clickedAnAnimal) {
        lockedAnimal = null;
        lockedAnimalType = null;
        debugLog(`Unlocked by clicking elsewhere (mobile-friendly)`);
        return; // Don't scatter food when unlocking
    }

    // Check if windchime was clicked
    if (windChimes && windChimes.length > 0) {
        for (const chime of windChimes) {
            const chimeDist = Math.sqrt(
                Math.pow(scaledX - chime.x, 2) +
                Math.pow(scaledY - chime.y, 2)
            );
            if (chimeDist < 40) { // 40px click radius
                // Play a quick cascade when clicking on windchime directly
                if (windChimeEnabled && audioContext) {
                    const notes = ['C', 'D', 'E', 'G']; // 4-note cascade
                    notes.forEach((note, i) => {
                        setTimeout(() => {
                            playNote(note, 3);
                        }, i * 70);
                    });
                }
                debugLog(`Clicked on windchime at (${chime.x}, ${chime.y})`);
                return; // Don't scatter food when clicking windchime
            }
        }
    }

    // ADD THIS CODE: Check if magic mushroom was clicked
    if (magicMushroom && !mushroomMode) {
        const distance = Math.sqrt(
            Math.pow(scaledX - magicMushroom.x, 2) + 
            Math.pow(scaledY - magicMushroom.y, 2)
        );
        
        if (distance < magicMushroom.size * 2) {
            // Add a special effect when mushroom is clicked
            addSpecialEffect({
                type: 'sparkle',
                x: magicMushroom.x,
                y: magicMushroom.y,
                duration: 2000,
                intensity: 1.0
            });
            
            activateMushroomMode();
            magicMushroom.clicked = true;
            
            // Play a magical sound if wind chimes are enabled
            // Play pleasant windchime cascade on clock click
            if (windChimeEnabled && audioContext) {
                const notes = ['C', 'E', 'G', 'A', 'C']; // Pentatonic cascade
                for (let i = 0; i < notes.length; i++) {
                    setTimeout(() => {
                        playNote(notes[i], 3);
                    }, i * 100);
                }
            }
            
            return; // Skip food scattering
        }
    }
    
    // Use the scaled coordinates - mark as player-added for bird priority
    scatterFood(scaledX, scaledY, 3, true);
    debugLog(`Food scattered at web coordinates (${scaledX}, ${scaledY})`);

    // FIXED: Removed wind chime sound feedback on food scatter
    // Wind chime sounds should only play when clicking ON the wind chime or from ambient wind
});

// Enhanced: Mouse move handler for bird hover detection
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    mouseX = (e.clientX - rect.left) * scaleX;
    mouseY = (e.clientY - rect.top) * scaleY;

    // Find bird under cursor
    hoveredBird = null;
    for (const bird of birds) {
        const dist = Math.sqrt(
            Math.pow(mouseX - bird.x, 2) +
            Math.pow(mouseY - bird.y, 2)
        );
        if (dist < 25) { // 25px hover radius
            hoveredBird = bird;
            break;
        }
    }

    // Find baby bird under cursor
    hoveredBabyBird = null;
    if (!hoveredBird) { // Only check baby birds if not hovering over an adult
        for (const baby of babyBirds) {
            const dist = Math.sqrt(
                Math.pow(mouseX - baby.x, 2) +
                Math.pow(mouseY - baby.y, 2)
            );
            if (dist < 15) { // 15px hover radius for smaller baby birds
                hoveredBabyBird = baby;
                break;
            }
        }
    }

    // Find tree under cursor with timeout support
    const previousHoveredTree = hoveredTree;
    hoveredTree = null;
    for (const tree of trees) {
        const dist = Math.sqrt(
            Math.pow(mouseX - tree.x, 2) +
            Math.pow(mouseY - (tree.y - tree.trunkHeight/2), 2)
        );
        if (dist < tree.trunkWidth * 2 + 50) { // Larger hover area for trees
            hoveredTree = tree;
            // Reset timer if hovering over a different tree
            if (previousHoveredTree !== tree) {
                hoveredTreeStartTime = Date.now();
            }
            break;
        }
    }
    // Clear timer if no longer hovering
    if (!hoveredTree) {
        hoveredTreeStartTime = 0;
    }
});

// Touch events for mobile
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent scrolling
    if (e.touches.length > 0) {
        // Initialize audio on first touch (required by browsers)
        if (!audioContext) {
            initializeAudio();
        }
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }

        const rect = canvas.getBoundingClientRect();
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        // Calculate the correct coordinates, accounting for scroll position
        const x = e.touches[0].clientX - rect.left - scrollLeft;
        const y = e.touches[0].clientY - rect.top - scrollTop;

        // Scale coordinates to match canvas coordinate system (same as desktop)
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const scaledX = x * scaleX;
        const scaledY = y * scaleY;

        // Restore show info button if it was hidden by Escape key
        const toggleInfo = document.getElementById('toggleInfo');
        if (window.showInfoButtonHidden && toggleInfo) {
            toggleInfo.style.display = 'block';
            window.showInfoButtonHidden = false;
            debugLog("Show info button restored on touch");
        }

        let clickedAnAnimal = false;

        // Check if bird was clicked
        for (const bird of birds) {
            const birdDist = Math.sqrt(
                Math.pow(scaledX - bird.x, 2) +
                Math.pow(scaledY - bird.y, 2)
            );
            if (birdDist < 30) { // 30px click radius for birds
                clickedAnAnimal = true;
                if (lockedAnimal === bird && lockedAnimalType === 'bird') {
                    // Unlock if clicking same bird
                    lockedAnimal = null;
                    lockedAnimalType = null;
                    debugLog(`Unlocked from bird (mobile)`);
                } else {
                    // Lock onto bird
                    lockedAnimal = bird;
                    lockedAnimalType = 'bird';
                    lockedAnimalTime = Date.now();
                    debugLog(`Locked onto bird: ${getBirdName(bird)} (mobile)`);

                    // Make the bird chirp when clicked/locked
                    if (bird.chirp && typeof bird.chirp === 'function') {
                        bird.chirp(CHIRP_TYPES.SOCIAL, 0.8);
                    }
                }
                return; // Don't scatter food when clicking bird
            }
        }

        // Check squirrels
        for (const squirrel of squirrels) {
            const squirrelDist = Math.sqrt(
                Math.pow(scaledX - squirrel.x, 2) +
                Math.pow(scaledY - squirrel.y, 2)
            );
            if (squirrelDist < 30) {
                clickedAnAnimal = true;
                if (lockedAnimal === squirrel && lockedAnimalType === 'squirrel') {
                    lockedAnimal = null;
                    lockedAnimalType = null;
                    debugLog(`Unlocked from squirrel (mobile)`);
                } else {
                    lockedAnimal = squirrel;
                    lockedAnimalType = 'squirrel';
                    lockedAnimalTime = Date.now();
                    debugLog(`Locked onto squirrel: ${getSquirrelName(squirrel)} (mobile)`);
                }
                return;
            }
        }

        // Check rats
        for (const rat of rats) {
            const ratDist = Math.sqrt(
                Math.pow(scaledX - rat.x, 2) +
                Math.pow(scaledY - rat.y, 2)
            );
            if (ratDist < 30) {
                clickedAnAnimal = true;
                if (lockedAnimal === rat && lockedAnimalType === 'rat') {
                    lockedAnimal = null;
                    lockedAnimalType = null;
                    debugLog(`Unlocked from rat (mobile)`);
                } else {
                    lockedAnimal = rat;
                    lockedAnimalType = 'rat';
                    lockedAnimalTime = Date.now();
                    debugLog(`Locked onto rat: ${getRatName(rat)} (mobile)`);
                }
                return;
            }
        }

        // Mobile-friendly unlock: If locked on an animal but touched elsewhere, unlock
        if (lockedAnimal && !clickedAnAnimal) {
            lockedAnimal = null;
            lockedAnimalType = null;
            debugLog(`Unlocked by touching elsewhere (mobile)`);
            return; // Don't scatter food when unlocking
        }

        // FIX: Check if windchime was touched (mobile support)
        if (windChimes && windChimes.length > 0) {
            for (const chime of windChimes) {
                const chimeDist = Math.sqrt(
                    Math.pow(scaledX - chime.x, 2) +
                    Math.pow(scaledY - chime.y, 2)
                );
                if (chimeDist < 40) { // 40px touch radius
                    // Play a quick cascade when touching windchime directly
                    if (windChimeEnabled && audioContext) {
                        const notes = ['C', 'D', 'E', 'G']; // 4-note cascade
                        notes.forEach((note, i) => {
                            setTimeout(() => {
                                playNote(note, 3);
                            }, i * 70);
                        });
                    }
                    debugLog(`Touched windchime at (${chime.x}, ${chime.y}) on mobile`);
                    return; // Don't scatter food when touching windchime
                }
            }
        }

        // If didn't click an animal, scatter food
        if (!clickedAnAnimal) {
            scatterFood(scaledX, scaledY, 5, true);
            debugLog(`Food scattered via touch at (${scaledX}, ${scaledY})`);
        }
    }
});


        }







        
        // Initialize the simulation
        function initialize() {
            // Update canvas size
            resizeCanvas();

            // Generate initial stars
            generateStars();

            // Generate initial weather forecast
            generateWeatherForecast();

            // Initialize hourly melody playlist
            initializeHourlyPlaylist();

            // Setup event handlers
            setupEventHandlers();

            // Update debug visuals
            updateDebugVisuals();

            // Start animation
            startAnimation();
        }

        // Initialize when page is loaded
        window.addEventListener('load', () => {
            initialize();
        });
    </script>
</body>
</html>
